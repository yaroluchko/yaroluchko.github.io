
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Creativitas Exported Code</title>
                
                <!-- External Dependencies -->
                <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/15.0.4/Tone.js"></script>
                <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.0/p5.js"></script>
                
                <style>
                
            body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
            canvas { display: block; margin-bottom: 10px; }
            #controls { margin-bottom: 20px; }
            .canvas-container { margin-bottom: 20px; }
            .span-container {
                display: flex;
                align-items: center;
                gap: 10px;
            }
            .invisible-button {
                background: none;
                border: none;
                cursor: pointer;
                padding: 4px;
            }
            .icon {
                height: 24px;
                transition: opacity 0.1s ease;
            }
            .active {
                opacity: 1;
            }
            .inactive {
                opacity: 0.5;
            }
            #notes-display {
                display: flex;
                flex-direction: row;
                flex-wrap: nowrap;
                gap: 8px;
                overflow-x: auto;
                white-space: nowrap;
                max-width: 70vw;
            }
            .note-pill {
                background-color: #f0f0f0;
                border-radius: 12px;
                padding: 4px 8px;
                font-size: 12px;
            }

                </style>
            </head>
            <body>
                <div id="controls">
                    <button onclick="stopCode()">Restart</button>
                    <p>BPM: <span id="bpmValue">120</span></p>
                    
                    <input 
                        type="range" 
                        id="bpmSlider" 
                        min="10" 
                        max="300" 
                        value="120"
                        oninput="updateBPM(this.value)"
                    >
                    
                    <input 
                        type="number" 
                        id="bpmInput" 
                        min="10" 
                        max="300" 
                        value="120"
                        oninput="updateBPM(this.value)"
                    >
                <div class="span-container" id="keyboard-container">
                    <button class="invisible-button" id="keyboard-button">
                        <img class="icon inactive" id="keyboard-icon" src="https://n54omxuiol.ufs.sh/f/K0nF6SKQt5rdQI0fYSZ76iwjnab1uNgOfU42I3KsEv8Yh9Cr" alt="Keyboard" />
                    </button>
                    <div id="notes-display"></div>
                </div>
                </div>

                <!-- Canvas container -->
                <div class="canvas-container" id="Canvas"></div>

                <div id="volumeWarning" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 1000;">
                    <div style="background: white; padding: 20px; border-radius: 8px; text-align: center;">
                        <h2>⚠️ Volume Warning</h2>
                        <p>This page contains audio content. Please ensure your volume is at a comfortable level.</p>
                        <button onclick="acknowledgeWarning()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">I understand</button>
                    </div>
                </div>

                <script>
                    // Synth class definitions and dependencies
                    //Sometimes you have to ask chatGPT to start from scratch :-)

class AsciiCallback {
    constructor() {
        this.asciiOn = false;
        this.handler = (key, upOrDown) => {
            console.log('Ascii', key, upOrDown,
                '\nadd a new handler like: \nsetAsciiHandler((num,state)=>{\nconsole.log(num, state)})');
        };
        this.activeKeys = {};
        
        // Bind the event handlers
        this.keyDown = this.keyDown.bind(this);
        this.keyUp = this.keyUp.bind(this);
    }

    keyDown(event) {
        if (!this.asciiOn) return;

        const keyCode = event.keyCode;
        let key = keyCode
        if( keyCode == 32 ) key = 'Space'
        else key = event.key;
        if (!this.activeKeys[key]) {
            this.activeKeys[key] = true;
            this.handler(key, 'down');
        }
    }

    keyUp(event) {
        if (!this.asciiOn) return;

        const keyCode = event.keyCode;
        let key = keyCode
        if( keyCode == 32 ) key = 'Space'
        else key = event.key;
        if (this.activeKeys[key]) {
            this.activeKeys[key] = false;
            this.handler(key, 'up');
        }
    }

    enable() {
        if (!this.asciiOn) {
            this.asciiOn = true;
            document.addEventListener('keydown', this.keyDown);
            document.addEventListener('keyup', this.keyUp);
        }
    }

    disable() {
        if (this.asciiOn) {
            this.asciiOn = false;
            document.removeEventListener('keydown', this.keyDown);
            document.removeEventListener('keyup', this.keyUp);
        }
    }

    setHandler(newHandler) {
        this.handler = newHandler;
    }
}

const asciiCallbackInstance = new AsciiCallback();



let _ = -123456
function orn (note, pattern=1, scalar=1, length=4){
	const patts = [
		[0,1,2,3],
		[0,2,1,3],
		[0,1,-1,0],
		[1,0,-1,0],
		[1,'.','.',0],
		[1,0,'.','.'],
		['.',0,0,0],
		['.',0,'.',0]

	]
	let arr = []
	pattern = pattern % patts.length
	for(let i=0;i<length;i++){
		arr.push( note + patts[pattern][i]*scalar)
	}
	return arr
}

/**
 * The MusicGenerator class handles the generation and manipulation of musical elements such as chords, harmony, scales,
 * harmonic progressions, rhythmic attributes like tempo, beat, and time signature, and provides setters and getters
 * to interact with these properties.
 *
 * @class
 * 
 * @property {string} tonic - The tonic or root note (setter: `setTonic`), which can be set using `tonic`, `root`, or `key`.
 * @property {string} root - Alias for `tonic`, allows setting the root note (setter: `setTonic`).
 * @property {string} key - Alias for `tonic`, allows setting the key (setter: `setTonic`).
 * @property {string[]} progression - The chord progression (setter: `setProgression`).
 * @property {number} tempo - The tempo of the piece in beats per minute (BPM), controlled via Tone.js's `Tone.Transport.bpm`.
 * @property {string} scale - The scale type (e.g., 'major', 'minor') used for the chord progression.
 * @property {string} chord - The current chord in the progression.
 * @property {string} timeSignature - The time signature of the piece (e.g., '4/4').
 * @property {number} harmonicTempo - The harmonic tempo, or how quickly harmonic changes occur (in BPM).
 * @property {number} beat - The current beat in the measure.
 * @property {number} bar - The current bar of the piece.
 * @property {number} beatsPerBar - The number of beats in each bar.
 * 
 * @example
 * // Create an instance of the MusicGenerator class
 * const Theory = new MusicGenerator();
 * 
 * // Set the tonic
 * Theory.tonic = 'C';
 * 
 * // Set the progression
 * Theory.progression = ['I', 'IV', 'V'];
 * 
 * // Set the tempo
 * Theory.tempo = 120;
 * 
 */


;


class MusicGenerator {
  constructor() {
    this._tonic = 'C';
    this.tonicNumber = 0; // MIDI note of tonic, 0-11
    this.keyType = 'major';
    this.octave = 4;
    this.voicing = 'closed';
    this.previousChord = [];

    this._scale = 'major'; // Private variable for scale
    this._chord = 'I'; // Private variable for chord
    this._timeSignature = '4/4'; // Private variable for time signature
    this._harmonicTempo = 120; // Private variable for harmonic tempo
    this._beat = 0; // Private variable for beat
    this._bar = 0; // Private variable for bar
    this._beatsPerBar = 4;
    this._startingBar = 0;
    this._startingBeat = 0;
    this._barOffset = 0; // Store the tick offset to reset the index
    this._prevBarOffset = 0;
    this._ticks = 0

    this.pulsePerChord = 16;
    this.harmonicRhythm = 8;
    this.progressionChords = [];
    this._progression = [];
    
    this.voicings = {
      "closed": [0, 2, 4, 6],
      "open": [0, 4, 6, 9],
      "drop2": [-3, 0, 2, 6],
      "drop3": [-1, 0, 3, 4]
    };
    this.notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    this.noteToInterval = {
      'C': 0, 'B#': 12, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 
      'Fb': 4, 'E#': 5, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 
      'A': 9, 'A#': 10, 'Bb': 10, 'B': 11, 'Cb': 11
    };
    this.chordIntervals = {
      "major": [0, 4, 7],
      "minor": [0, 3, 7],
      "dominant7": [0, 4, 7, 10],
      "minor7": [0, 3, 7, 10],
      "major7": [0, 4, 7, 11],
      "minorMaj7": [0, 3, 7, 11],
      "diminished": [0, 3, 6],
      "diminished7": [0, 3, 6, 9],
      "add9": [0, 4, 7, 14] // Major triad with added ninth
    };
    this.chordScales = {
      "major": [0, 2, 4, 5, 7, 9, 11],
      "minor": [0, 2, 3, 5, 7, 8, 10], // aeolian
      "lydianDominant": [0, 2, 4, 6, 7, 9, 10], //lydian dominant?
      "mixolydian": [0,2,4,5,7,9,10], //for V7
      "phrygianDominant": [0,1,4,5,7,8,10], //for minor V7
      "minor7": [0, 2, 3, 5, 7, 9, 10], //dorian
      "major7": [0, 2, 4, 5, 7, 9, 11],
      "minorMaj7": [0, 2, 3, 5, 7, 9, 11], //melodic minor
      "diminished": [0, 2, 3, 5, 6, 8, 9, 11],
      "diminished7": [0, 2, 3, 5, 6, 8, 9, 11],
      "add9": [0, 2, 4, 5, 7, 9, 11],
      "dorian": [0,2,3,5,7,9,10], //minor natural-6
      "phrygian": [0,1,3,5,7,8,10], //minor flat-2
      "lydian": [0,2,4,6,7,9,11], //major sharp-4
      "locrian": [0,1,3,5,6,8,10], //half-diminished
    };
    this.MajorScaleDegrees = {
      'I': 0, 'bII': 1, 'II': 2, 'bIII': 3,'III': 4, 'IV': 5, '#IV': 6, 
      'bV': 6,'V': 7,'#V': 8, 'bVI': 8,'VI': 9, 'bVII': 10,'VII': 11,
      'i': 0, 'bii': 1, 'ii': 2, 'biii': 3,'iii': 4, 'iv': 5, '#iv': 6, 
      'bv': 6,'v': 7, 'bvi': 8,'vi': 9, 'bvii': 10,'vii': 11 
    };
    this.MinorScaleDegrees = {
      'I': 0, 'bII': 1, 'II': 2, 'III': 3,'#III': 4, 'IV': 5, '#IV': 6, 
      'bV': 6,'V': 7,'#V': 8, 'VI': 8,'#VI': 9, 'VII': 10,'#VII': 11,
      'i': 0, 'bii': 1, 'ii': 2, 'iii': 3,'#iii': 4, 'iv': 5, '#iv': 6, 
      'bv': 6,'v': 7, 'vi': 8,'#vi': 9, 'bvii': 10,'vii': 11
    };
  }

  set tonic(value) {this.setTonic(value);}
  get tonic() {return this._tonic;}
  set root(value) {this.setTonic(value);}
  get root() {return this._tonic;}
  set key(value) {this.setTonic(value);}
  get key() { return this._tonic; }
  set progression(value) {this.setProgression(value);}
  get progression() {return this._progression;}
  set tempo(value) {Tone.Transport.bpm.value = value;}
  get tempo() {return Tone.Transport.bpm.value;}
  
  set scale(value) { this._scale = value;}
  get scale() { return this._scale;}
  set chord(value) { this._chord = value;}
  get chord() {   return this._chord; }
  set timeSignature(value) {  this._timeSignature = value; }
  get timeSignature() { return this._timeSignature; }
  set harmonicTempo(value) {  this._harmonicTempo = value; }
  get harmonicTempo() {   return this._harmonicTempo;  }

  //Tone.transport time setters
  //Transport info https://tonejs.github.io/docs/r13/Transport
  set beat(value) { 
    let pos = this.transportToArray(Tone.Transport.position)
    pos[1] = value
    Tone.Transport.position = this.arrayToTransport(pos)  
  }
  get beat() {   return  this.transportToArray(Tone.Transport.position)[1] }
  set bar(value) {  
    let pos = this.transportToArray(Tone.Transport.position)
    pos[0] = value
    Tone.Transport.position = this.arrayToTransport(pos)   
  }
  get bar() {  return this.transportToArray(Tone.Transport.position)[0] } 
  set beatsPerBar(value) {  
    this._beatsPerBar = value; 
    Tone.Transport.timeSignature = value
  }
  get beatsPerBar() {  return this._beatsPerBar; }
  set ticks(value) {  this._ticks = value }
  get ticks() {  return this.getTicks()+2; }
  set start(value=0){}
  get now() {
    const time = Tone.Transport.position.split(':').map(Number); // Split and convert to numbers
    return time[0] * 4 + time[1] + (time[2] || 0) / 4; // Handle undefined time[2]
  }

  getIndex(subdiv) { return Math.floor(this.ticks / Tone.Time(subdiv).toTicks()) }

  start(num=0){
    Tone.Transport.position = this.arrayToTransport([num,0,0])
    Tone.Transport.start()
  }
  stop(){ Tone.Transport.stop()}

  transportToArray(position){ return position.split(':').map(Number);}
  arrayToTransport(arr){return arr.join(':')}

  onBar(cb, bar){
    Tone.Transport.schedule(cb, this.arrayToTransport([bar,0,0]))
  }
  /**
 * Sets the tonic (root note) of the scale or chord and updates related properties like key type and octave.
 * Accepts either a string representing a musical note (e.g., "C4", "G#3") or a MIDI note number.
 *
 * If the input is a string, the tonic is derived from the note part, and the key type is determined based on 
 * whether the note is uppercase (for major keys) or lowercase (for minor keys). The octave is set from 
 * the numeric part of the string.
 *
 * If the input is a number, it is treated as a MIDI note number, and both the tonic and octave are computed.
 *
 * @param {string|number} val - The tonic value. Can be a musical note (e.g., "C4", "g#") or a MIDI note number.
 *
 * @example
 * // Set tonic using a musical note string
 * setTonic('C4'); // Sets tonic to 'C', key type to 'major', octave to 4
 * 
 * @example
 * // Set tonic using a MIDI note number
 * setTonic(60); // Sets tonic to 'C', key type remains unchanged, octave to 4
 */
  setTonic(val) {
    if (typeof val === 'string') {
      const noteRegex = /[A-Ga-g][#b]?/;
      const numberRegex = /\d+/;
  
      const noteMatch = val.match(noteRegex);
      const numberMatch = val.match(numberRegex);
  
      if (noteMatch) {
        this._tonic = noteMatch[0].toUpperCase();
        this.keyType = noteMatch[0] === noteMatch[0].toUpperCase() ? 'major' : 'minor';
      }
  
      if (numberMatch) {
        this.octave = parseInt(numberMatch[0], 10);
      }
    } else if (typeof val === 'number') {
      this.octave = Math.floor(val / 12) - 1;
      const noteIndex = val % 12;
      this._tonic = this.notes[noteIndex];
    }
  
    this.tonicNumber = this.noteToInterval[this._tonic];
    console.log(`Tonic: ${this._tonic}, Number: ${this.tonicNumber}, Key Type: ${this.keyType}, Octave: ${this.octave}`);
  }

  /**
  * Sets the chord progression and validates the input.
  * The progression can be passed as either a string or an array of strings representing chords.
  * 
  * If provided as a string, it will split the string into an array by spaces or commas. Each chord
  * in the progression is validated by checking its Roman numeral and corresponding scale type.
  * 
  * If the progression is valid, it is stored and the corresponding chord objects are generated.
  * In case of an error, a message is logged indicating the problematic chord element.
  *
  * @param {string|string[]} val - The chord progression, either as a string (e.g., "I IV V") or an array of chord strings.
  *
  * @example
  * // Set progression using a string
  * setProgression('I IV V');
  * 
  * @example
  * // Set progression using an array of chords
  * setProgression(['I', 'IV', 'V']);
  */
  setProgression(val) {
    let newProgression = [];
    let error = -1;
  
    if (val.constructor !== Array) {
      val = val.replaceAll(',', ' ').split(' ');
    }
  
    for (let i = 0; i < val.length; i++) {
      let chord = val[i];
      try {
        if (val[i] !== '') {
          const romanNumeral = chord.match(/[iIvVb#]+/)[0];
          const quality = this.getChordType(chord);
          console.log(chord, quality)
          if (typeof this.MajorScaleDegrees[romanNumeral] !== "number") error = i;
          if (this.chordScales[quality].constructor !== Array) error = i;
          if (error < 0) newProgression.push(chord);
        }
      } catch {
        console.log("error with element ", val[i]);
        error = 0;
      }
    }
  
    if (error < 0) {
      this._progression = newProgression;
      this.progressionChords = [];
      for (let i = 0; i < this._progression.length; i++) {
        this.progressionChords.push(new Chord(this._progression[i]));
      }
    } else {
      console.log("error in progression element", val[error]);
    }
  }

  setVoicing(name) {
    if (this.voicings.hasOwnProperty(name)) this.voicing = name;
    else console.log('invalid voicing name ', name);
    console.log('current voicing: ', this.voicing);
  }

  getChord(index) {
    let index2 = this.getChordIndex();
    if (this.progressionChords.length < 1) this.progressionChords.push(new Chord('I'));
    return this.progressionChords[Math.floor(index2 % this.progressionChords.length)];
  }

  getChordIndex() {
    let index = Math.floor((this.ticks + 2) / (Tone.Time('4n').toTicks() * this._beatsPerBar));
    return index;
  }

  getChordType(name) {
    const suffix = name.replace(/[iIvVb#]+/, '');
    let majorMinor = name.match(/[iIvV]+/)[0];

    if(!majorMinor) majorMinor = 'I'

    const defaultMode = this.getDefaultMode(majorMinor, this.keyType)
    //console.log(name, this.keyType, defaultMode)
      //look for a specific scale defined in suffix
    for (const key of Object.keys(this.chordScales)) {
      if (suffix.toLowerCase().includes(key.toLowerCase())) {
        console.log('key', key)
        return key;
      }
    }
    //look for special cases
    if (suffix.includes('dim'))  return 'diminished';
    if (suffix.includes('m6'))  return 'dorian';
    if (suffix.includes('min6'))  return 'dorian';
    if (suffix.includes('m13'))  return 'dorian';
    if (suffix.includes('min13'))  return 'dorian';
    if (suffix.includes('m7b9'))  return 'phrygian';
    if (suffix.includes('7b9'))  return 'phrygianDominant';
    if (suffix.includes('Maj7#11'))  return 'lydian';
    if (suffix.includes('m7b5'))  return 'locrian';
    if (suffix.includes('7b5'))  return 'lydianDominant';
    if (suffix.includes('Maj7')) {
      const isMajor = majorMinor === majorMinor.toUpperCase() 
      if(defaultMode === 'lydian') return defaultMode
      return isMajor === true ? 'major7' : 'minorMaj7'
    }
    if (suffix.includes('7')) {
      // if(defaultMode !== 'none') return defaultMode
      // else 
    return majorMinor === majorMinor.toUpperCase() ? 'mixolydian' : 'minor7'; 
    }
    if (suffix.includes('2')) return 'major9';

    if( defaultMode !== 'none') return defaultMode
    return majorMinor === majorMinor.toUpperCase() ? 'major' : 'minor';
  }

  getDefaultMode(numeral, key){
    if (key === 'major'){
      switch(numeral){
      case 'I': return 'major'
      case 'ii': return 'dorian'
      case 'iii': return 'phrygian'
      case 'IV': return 'lydian'
      case 'V': return 'mixolydian'
      case 'vi': return 'minor'
      case 'vii': return 'locrian'
      }
    }
    if (key === 'minor'){
      switch(numeral){
      case 'i': return 'minor'
      case 'ii': return 'locrian'
      case 'III': return 'major'
      case 'iv': return 'dorian'
      case 'v': return 'phrygian'
      case 'V': return 'phrygianDominant'
      case 'VI': return 'lydian'
      case 'VII': return 'mixolydian'
      }
    }
    return 'none'
  }

  /************************************
 * Time keeping
 * ************************************/
  getTicks(){
    const currentTicks = Tone.Transport.ticks - this._barOffset
    if(currentTicks < 0) return Tone.Transport.ticks - this._prevBarOffset
    else return currentTicks
  }
  // resetBar(){
  //   let index = Math.floor((Tone.Transport.ticks + 8) / Tone.Time('1n').toTicks());
  // }

  // calcTicks(val){

  // }


  resetBar(val) {
    const currentTicks = Tone.Transport.ticks;
    const ticksInBar = Tone.Time('4n').toTicks() * this._beatsPerBar; // Get tick value for a quarter note

    // Calculate the next quarter note by rounding up to the nearest quarter note
    const nextBar = Math.ceil(currentTicks / ticksInBar) * ticksInBar ;

    // Store the offset to be subtracted from future index calculations
    this._barOffset = nextBar + val*ticksInBar - val*ticksInBar;

    //console.log(`Bar reset. Next downbeat tick: ${nextBar}, current tick: ${currentTicks}`);
  }

  /************************************
 * Helper functions
 * ************************************/

  getChordRoot(name){
    //parse chord name
    const romanNumeral = name.match(/[iIvVb#]+/)[0];

    //set keyType
    if (!romanNumeral) {
      console.log('incorrect chord name ${name}')
      return this.tonicNumber
    }
    let degree = 0
    
    if (this.keyType == 'major') {
      degree =  this.MajorScaleDegrees[romanNumeral];
      if(degree == undefined) degree = this.MinorScaleDegrees[romanNumeral];
      if(degree == undefined) degree = 0
    }
    else {
      degree =  this.MinorScaleDegrees[romanNumeral];
      if(degree == undefined) degree = this.MajorScaleDegrees[romanNumeral];
      if(degree == undefined) degree = 0
    }
    if(degree == undefined) degree = 0

    return degree % 12
  }

  //return midi note numbers for current chord
  getChordTones(root, quality, scale){
    let chord = []
    let len = 3
    if( /\d/.test(quality)) len = 4
    for(let i=0;i<len;i++) chord[i] = scale[i*2]+root
  }

  getInterval(num,scale){
    let len = scale.length
    if (typeof num === 'number') {
      let _octave = Math.floor(num/len)
      if(num<0) num = len+num%len //check negative numbers
      num = scale[num%len] + _octave*12
      return num
    } else if (typeof num === 'string') {
      //parse num to look for # and b notes
      const match = num.match(/^([^\d-]+)?(-?\d+)$/);

      //get scale degree
      num = Number(match[2])
      let _octave = Math.floor(num/len)
      if(num<0) num = 7+num%7
      num = scale[num%len] + _octave*12

      //apply accidentals
      if(match[1]== '#')num+=1
      else if (match[1] == 'b') num-=1

      num += this.tonicNumber

      return num
    }
    return 0
  }

  minimizeMovement(chord, previousChord) {
    let distance = Math.abs(chord[0]%12-previousChord[0]%12)
    let lowNote = 0

    for(let i=1;i<chord.length;i++){
      if(Math.abs(chord[i]%12-previousChord[0]%12) < distance){
        distance = Math.abs(chord[i]%12-previousChord[0]%12)
          lowNote = i
      }
    }

    while(chord[lowNote] < previousChord[0]-2)chord = chord.map(x=>x+12)
   
    for(let i=0;i<chord.length;i++){
      if(chord[i] < previousChord[0])chord[i]+=12
    }

    return chord.sort((a, b) => a - b);
  }
}

const Theory = new MusicGenerator()

/****************** 
 * CHORD Class
 * Methods
 * - constructor(name,octave,voicing)
 * - getChordTones(lowNote): gets array of MIDI notes
 * - getInterval(degree): midi note number of scale degree
 * - setChord: set custom chord
 * 
 * Parameters
 * - notes: midi note numbers of current chord degrees
 * - root: midi note
 * - octave
 * - voicing: name 'closed' or interval pattern [0,2,4]
 * - scale: name 'major' or custom e.g. [0,2,4,5,7,9,11]
 *  * ******************/

/**
 * Class representing a musical chord.

 */
class Chord {
  /**
   * Create a chord.
  
   * @param {string} name - The name of the chord (e.g., "Cmaj7", "Dm7").
   * @param {number} [_octave=octave] - The octave in which the chord is played.
   * @param {string} [_voicing=voicing] - The voicing to use for the chord.
   */
  constructor(name, _octave = Theory.octave, _voicing = Theory.voicing) {
    this.name = name;
    this.octave = _octave;
    this.voicing = _voicing;
    this.rootValue = Theory.getChordRoot(name); //integer 0-11
    this.quality = Theory.getChordType(name) //'Maj7'
    this.scale = Theory.chordScales[this.quality];
    if(this.name == 'V7') this.scale = Theory.chordScales['mixolydian']
    this.chordTones = this.getChordTones(this.rootValue,this.quality,this.scale);
    this.length = this.chordTones.length
  }
  /**
   * Calculate the interval for the chord within a specified range.
   * @param {number} num - The scale degree or interval number.
   * @param {number} [min=48] - The minimum MIDI note number for the interval.
   * @param {number} [max=null] - The maximum MIDI note number for the interval. Defaults to min + 12.
   * @returns {number} - The MIDI note number for the interval.
   */
  interval(num, min = 12, max = null){
    if(max === null) max = min + 12
    return this.getInterval(num,min,max)
  }

  getInterval(num, min = 0, max = 127){ 
    num = Theory.getInterval(num, this.scale) + this.rootValue + this.octave*12 
    if(num<min) {
      const count = Math.floor((min-num)/12)+1
      for(let i=0;i<count;i++)num += 12
        //console.log('min', count)
    }
    else if(num>max) {
      const count = Math.floor((num-max)/12)+1
      for(let i=0;i<count;i++)num -= 12
        //console.log('max', count)
    }
    return num
  }

  /**
   * Get the root note of the chord adjusted for a specified low note.
  
   * @param {number} [lowNote=36] - The lowest note to start the chord from.
   * @returns {number} - The root note as a MIDI note number.
   */
  root(lowNote = 36){
    return this.rootValue + lowNote
  }

  /**
   * Get the chord tones starting from a specified low note.
  
   * @param {number} [lowNote=48] - The lowest note to start the chord from.
   * @returns {number[]} - An array of MIDI note numbers representing the chord tones.
   */
  tones(lowNote = 48){
    return this.getChordTones(lowNote)
  }

  getChordTones(lowNote=48, highNote = null) {
    if(highNote === null) highNote  = lowNote + 12
    const chordTones = this.getChord(this.name, lowNote, this.voicing)
    //console.log(chordTones)
    return chordTones;
  }

  /**
   * Set a custom chord with specified notes.
  
   * @param {number[]} customChord - An array of MIDI note numbers representing the custom chord.
   */
  setChord(customChord) {
    this.notes = customChord;
  }

  applyVoicing(chordTones) {
    const voicingOffsets = Theory.voicings[this.voicing];
    return Theory.chordTones.map((tone, index) => tone + (voicingOffsets[index] || 0));
  }

  getChord(name,  lowNote = null, _voicing = null){

    if(_voicing == null) _voicing = Theory.voicing

    // Adjust the chord tones based on the voicing type
    //let chord = applyVoicing(name, _voicing, this.scale);

    let chord = [this.scale[0], this.scale[2], this.scale[4]];

    //check for numeric extensions
    const regex = /\d/;
    if( regex.test(name) && this.scale.length >= 7 ) {
      const match = name.match(/\d+/); // Match one or more digits
      if (match) {
        chord.push( this.scale [parseInt(match[0], 10)%7]); // Convert the matched string to a number
      }
    }
    chord = chord.map(x=> x+ this.octave*12 + this.rootValue)// + Theory.tonicNumber)

    // Adjust the chord tones to be as close as possible to the previous chord
    if (Theory.previousChord.length > 0) {
      if(lowNote){ Theory.previousChord[0] = lowNote}
      chord = Theory.minimizeMovement(chord, Theory.previousChord);
    }

    Theory.previousChord = chord;
    return chord.map(x=> x + Theory.tonicNumber)
  }
}

/************************************
 * String parsing functions
 * ************************************/
/** parseStringSequence

 * 
 * takes an input string and:
 * - replaces groups like *@4 with ****
 * - splits the string into an array of strings, one string per beat
 * - preserves characters inside [] inside one beat
 */
function parseStringSequence(str){
    str = str.replace(/\s/g, ""); // Remove all whitespace

    //replace the expression  *@4 with ****
    str = str.replace(/(.)@(\d+)/g, (match, p1, p2) => {
        // p1 is the character before the @
        // p2 is the number after the @, so repeat p1 p2 times
        return p1.repeat(Number(p2));
    });

    //split original string into an array of strings
    //items within [] are one entry of the array
    const regex = /\[.*?\]|./g;
    str.match(regex);
    str = str.match(regex);

    return str
}

function parsePitchStringSequence(str) {
    
    const firstElement = str.replace(/\[/g, "")[0]
    const usesPitchNames = /^[a-ac-zA-Z?]$/.test(firstElement);


    // Step 1: Remove all whitespace
    if( usesPitchNames ) str = str.replace(/\s/g, "");
    //str = str.replace(/\,/g, "");

    // Step 2: Split into an array
    // - Matches items inside brackets as one element
    // - Groups numbers, 'b', and '#' with the preceding pitch
    // - Ensures '@' and the number following it are in their own array element
    //const regex = /\[.*?\]|[A-Ga-g][#b]?\d*|@(\d+)|./g;
    // - Preserves periods '.' as their own array elements
    let regex = /\[.*?\]|[A-Ga-g][#b]?\d*|@(\d+)|\.|\?/g;

    if (!usesPitchNames) { // true if the first element is a number
        regex = /\[.*?\]|-?[b#]?\d+[b#]?|@(\d+)|\.|\?/g;
    }

    let arr = str.match(regex);

    // Step 3: Process '@' elements
    for (let i = 0; i < arr.length; i++) {
        if (arr[i].startsWith("@")) {
            const repeatCount = parseInt(arr[i].slice(1), 10)-1; // Get the number after '@'
            const elementToRepeat = arr[i - 1]; // Get the previous element
            const repeatedElements = new Array(repeatCount).fill(elementToRepeat); // Repeat the element
            arr.splice(i, 1, ...repeatedElements); // Replace '@' element with the repeated elements
            i += repeatCount - 1; // Adjust index to account for the newly inserted elements
        }
    }


    return arr;
}

//handles rhythm sequences
function parseStringBeat(curBeat, time){
  let outArr = []
  //handle when a beat contains more than one element
    const bracketCheck = /^\[.*\]$/;
    if (bracketCheck.test(curBeat)) {
      //remove brackets and split into arrays by commas
      curBeat =curBeat.slice(1, -1).split(',');
      //console.log(curBeat)
      curBeat.forEach(arr => {
          const length = arr.length;
          for (let i = 0; i < length; i++) {
              const val = arr[i];
              outArr.push([val,i/length])
              //console.log('out', outArr)
            }
      });
    } else { //for beats with only one element
      outArr.push([curBeat, 0])
        //callback(curBeat, time);
    }
    return  outArr 
}

//handles pitch sequences
function parsePitchStringBeat(curBeat, time){
  //console.log(curBeat)
  try{
    if (typeof curBeat === 'number')  curBeat = curBeat.toString();
    const firstElement = curBeat.replace(/\[/g, "")[0]
    const usesPitchNames = /^[a-ac-zA-Z]$/.test(firstElement);

    let outArr = []
    //handle when a beat contains more than one element
      const bracketCheck = /^\[.*\]$/;
      if (bracketCheck.test(curBeat)) {
        //remove brackets and split into arrays by commas
        curBeat =curBeat.slice(1, -1).split(',');
        //console.log(curBeat)
        curBeat.forEach(arr => {
          let regex = /\[.*?\]|[A-Ga-g][#b]?\d*|@(\d+)|./g;
          if( !usesPitchNames){ //true if first element is a number
            regex = /\[.*?\]|-?\d+[#b]?|@(\d+)|\./g;
          } 
          arr = arr.match(regex)

           for (let i = 0; i < arr.length; i++) {
                if (arr[i].startsWith("@")) {
                    const repeatCount = parseInt(arr[i].slice(1), 10)-1; // Get the number after '@'
                    const elementToRepeat = arr[i - 1]; // Get the previous element
                    const repeatedElements = new Array(repeatCount).fill(elementToRepeat); // Repeat the element
                    arr.splice(i, 1, ...repeatedElements); // Replace '@' element with the repeated elements
                    i += repeatCount - 1; // Adjust index to account for the newly inserted elements
                }
            }
            // console.log(arr)
            
            const length = arr.length;
            for (let i = 0; i < length; i++) {
                const val = arr[i];
                outArr.push([val,i/length])
            }
        });
        //console.log(outArr)
      } else { //for beats with only one element
        outArr.push([curBeat, 0])
      }
      return  outArr 
    }
  catch(e){
    console.log('error with parsePitchStringBeat')
    return ['.']
  }
}

/**
 * Converts a pitch name (e.g., "C4", "g#", "Bb3") to a MIDI note number.

 *
 * @param {string} name - The pitch name to convert. This can include a pitch class (A-G or a-g), 
 *                        an optional accidental (# or b), and an optional octave number.
 *                        If no octave number is provided, uppercase letters default to octave 3,
 *                        and lowercase letters default to octave 4.
 * @returns {number} - The corresponding MIDI note number.
 */
function pitchNameToMidi(name) {
    const pitchClasses = Theory.noteToInterval

    // Normalize input to remove spaces
    name = name.trim()
    
    // Determine the pitch class and accidental if present
    let pitchClass = name.match(/[A-G]?[a-g]?[#b]?/)[0];

    // Determine the octave:
    // - Uppercase letters (C-B) should be octave 3
    // - Lowercase letters (c-a) should be octave 4
    let octave;
    if (/[A-G]/.test(name[0])) {
        octave = 3;
    } else {
        octave = 4;
    }

    //convert first character to uppercase
    pitchClass = pitchClass.charAt(0).toUpperCase() + pitchClass.slice(1)

    // Adjust for any explicit octave provided (e.g., "C4" or "c5")
    let explicitOctave = name.match(/\d+$/);
    if (explicitOctave) octave = parseInt(explicitOctave[0], 10)

    // Adjust the MIDI note for flats (# and b are already handled in pitchClasses)
    let midiNote = pitchClasses[pitchClass] + (octave+1) * 12;

    return midiNote;
}

/**
 * Converts an to a MIDI note number, taking into account the current chord.

 *
 * @param {string} interval - The interval to convert. This will include a integer number, 
 *                        and an optional accidental (# or b).
 * @returns {number} - The corresponding MIDI note number.
 */
function intervalToMidi(interval, min=12, max = 127) {
    // Normalize input to remove spaces
  //console.log(interval)
    interval = interval.trim()
    
    // Determine the pitch class and accidental if present
    const degree = interval.match(/\[.*?\]|-?\d+|@(\d+)|\./g)[0];
    const accidental = interval.match(/[b#]+/g);

    let midiNote = -1
    //console.log(degree, min, max, Theory.getChord())
    try{  midiNote = Theory.getChord().interval(degree,min,max)}
    catch(e){ console.log('bad interval: ', degree)}

    //console.log(midiNote)
    if (accidental !== null) {
      if (Array.isArray(accidental)) {
        for (const sign of accidental) {
          if (sign === "#") midiNote += 1;
          else if (sign === "b") midiNote -= 1;
        }
      } else {
        if (accidental === "#") midiNote += 1;
        else if (accidental === "b") midiNote -= 1;
      }
    }

    // Adjust the MIDI note for flats (# and b are already handled in pitchClasses)
    //let midiNote = pitchClasses[pitchClass] + (octave+1) * 12;
    //return 60

    //console.log(interval, midiNote, Theory.getChord())

    return midiNote //+ Theory.tonicNumber;
}

//parses a symbol and makes sure it is in correct order
function rearrangeAccidentals(arr, usesPitchNames) {

    // Regular expression to separate sign, letters, numbers, and accidentals
    const match = arr.match(/^(-?)([A-Za-ac-z]*)(\d*)([#b]*)$/);
    console.log(arr, usesPitchNames, match)
    if (match) {
        const [, sign, letters, numbers, accidentals] = match;
        //console.log(`letters ${accidentals}${numbers} ${usesPitchNames}`);
        if (usesPitchNames) {
            // For pitch names: letter/accidental/octaveNumber
            //console.log(`letters ${sign}${letters}${accidentals}${numbers}`);
            return `${letters}${accidentals}${numbers}`;
        } else {
            // For scale degrees: sign,number,accidental
            //console.log(`numbers ${sign}${letters}${numbers}${accidentals}`);
            return `${sign}${numbers}${accidentals}`;
        }
    }

    // Return the original string if no match
    return arr;
}



window.p5Themes = {
  "themes": {
    "default": {
      "border": 6,
      "backgroundColor": [240, 240, 240], 
      "borderColor": [100, 100, 100],     
      "accentColor": [0, 128, 255],       
      "textColor": [0, 0, 0],             
      "labelFont": "Arial",
      "valueFont": "Helvetica",
      "textFont": "Verdana",
      "titleFont": "Verdana",
      "borderRadius": 5,
      "showValue" :true
    },
    "dark": {
      "border": 3,
      "backgroundColor": [20, 20, 20],     
      "borderColor": [50, 50, 50],        
      "accentColor": [255, 0, 0],         
      "textColor": [255, 255, 255],       
      "labelFont": "Helvetica",
      "valueFont": "Arial",
      "textFont": "Verdana",
      "titleFont": "Verdana",
      "borderRadius": 8
    },
    "custom": {
      "border": 2,
      "backgroundColor": [255, 255, 200], 
      "borderColor": [0, 128, 0],         
      "accentColor": [255, 165, 0],       
      "textColor": [0, 0, 0],             
      "labelFont": "Georgia",
      "valueFont": "Courier New",
      "textFont": "Palatino",
      "titleFont": "Verdana",
      "borderRadius": 10
    }
  }
};;

/*
p5Elements.js
created by Kayli Requenez F23
*/

;
;

let activeTheme = p5Themes.themes['default']; // Default theme preset



function debug(){
    console.log('esy')
    console.log(activeTheme)
}

//************** THEME DEFINITIONS *************/
// Function to list available themes
function listThemes() {
  console.log( Object.keys(p5Themes.themes) ) 
}

function setTheme(themeName) {
    if (!p5Themes.themes[themeName]) {
        console.error(`Theme '${themeName}' not found.`);
        return;
  } 
    activeTheme = p5Themes.themes[themeName]; // Default theme preset
}

// Function to update theme parameters
function setThemeParameters(parameters) {
  if (activeTheme) {
    // Merge the provided parameters with the active theme
    activeTheme = { ...activeTheme, ...parameters };
  } else {
    console.error(`Active theme '${activeTheme}' not found.`);
  }
}

// Function to get the current theme values in JSON format
function exportTheme() {
    console.log(`exporting ` + activeTheme);
    console.log( JSON.stringify(activeTheme, null, 2))
    return JSON.stringify(activeTheme, null, 2);
}

//************** INITIALIZE **************

function initialize(p, div) {
    p.div = div;
    p.createCanvas(div.offsetWidth, div.offsetWidth*.4);
    p.width = div.offsetWidth;
    p.height = div.offsetWidth*.4;
    p.elements = {};

    return [p.width, p.height]
}

p5.prototype.initialize = function (div) {
    return initialize(this, div);
};

function resizeP5(string, scaleWidth, scaleHeight) {
    var regex = /(\w+)\.(\w+)\((.*?)\)/;
    var match = string.match(regex);

    if (match) {
        // Extract the canvas, function name, and items inside the parentheses
        var canvasName = match[1]
        var functionName = match[2];
        let items = match[3].split(',').map(item => item.trim());

        // New values
        for (let i = 0; i < (functionName === 'arc' ? 4 : items.length); i++) {
            if (functionName === 'circle' && i > 1) {
                items[i] *= (scaleWidth + scaleHeight) / 2;
            }
            else {
                if (i % 2 === 0) {
                    items[i] *= scaleWidth;
                }
                else {
                    items[i] *= scaleHeight;
                }
            }
        }

        // Replace the items with new values
        return string.replace(match[0], canvasName + '.' + functionName + '(' + items.join(', ') + ')');
    }
    return string;
}

function divResized(p, maxClicked, canvasLength) {
    let prevWidth = p.width;
    let prevHeight = p.height;
    p.resizeCanvas(0, 0);
    let canvasesCont = document.getElementById("canvases");
    let controlsCont = document.getElementById("controls");
    let flexCont = document.getElementById('flex');
    if (maxClicked === '+h') {
        p.height = canvasesCont.offsetHeight - controlsCont.offsetHeight;
        p.width = p.div.offsetWidth;
    }
    else if (maxClicked === '-h') {
        p.height = canvasesCont.offsetHeight / canvasLength - controlsCont.offsetHeight;
        p.width = prevWidth;
    }
    else if (maxClicked === '+w') {
        p.width = flexCont.offsetWidth;
        p.height = p.div.offsetHeight;
    }
    else if (maxClicked === '-w') {
        p.width = flexCont.offsetWidth / 2;
        p.height = prevHeight;
    }
    else {
        p.width = p.div.offsetWidth;
        p.height = p.div.offsetHeight;
    }
    let scaleWidth = p.width / prevWidth;
    let scaleHeight = p.height / prevHeight;
    p.resizeCanvas(p.width, p.height);
    for (let [key, element] of Object.entries(p.elements)) {
        if (typeof (element) === "string") {
            p.elements[key] = resizeP5(element, scaleWidth, scaleHeight);
        }
        else {
            element.resize(scaleWidth, scaleHeight);
        }
    }
    p.drawElements();
};

p5.prototype.divResized = function (maxClicked = false, canvasLength = null) {
    divResized(this, maxClicked, canvasLength);
};

function drawGrid(p) {
    let margin = 10;
    let spacingX = Math.ceil((p.width - 2 * margin) / 3) - 5;
    let spacingY = Math.ceil((p.height - 2 * margin) / 3) - 5;
    p.textSize(12);
    let bgColorSum = activeTheme.backgroundColor.reduce((a,b)=>a+b)
    //let isBlack = p.red(p.backgroundColor) === 0 && p.green(p.backgroundColor) === 0 && p.blue(p.backgroundColor) === 0;
    p.fill(bgColorSum < 382 ? 255 : 0);
    p.noStroke();
    for (let i = 0; i < 4; i++) {
        let x = margin + i * spacingX;
        let y = margin + i * spacingY;
        p.text(x, x, margin);
        p.text(y, margin, y);
    }
}

let updateCanvas = 1;

//************** DRAW ELEMENTS //**************

function drawBackground(p) {
    if( updateCanvas > 0 ){
        updateCanvas = 1
        p.background(activeTheme.backgroundColor);
    }
}

p5.prototype.drawBackground = function () {
    drawBackground(this);
};

function drawElements(p) {
    if( updateCanvas > 0 ){
        updateCanvas = 1
        //drawGrid(p);
        for (let element of Object.values(p.elements)) {
            if (typeof (element) === "string") {
                //when would this be called?
                eval(element);
            }
            else {
                //draw gui elements
                element.draw();
            }
        }
    }
}

p5.prototype.drawElements = function () {
    drawElements(this);
};

const scaleOutput = function (input, inLow, inHigh, outLow, outHigh, curve) {
    if (curve === undefined) curve = 1;
    let val = (input - inLow) * (1 / (inHigh - inLow));
    val = Math.pow(val, curve);
    return val * (outHigh - outLow) + outLow;
  }

const unScaleOutput = function (input, outLow, outHigh, inLow, inHigh, curve) {
    if (curve === undefined) curve = 1;
    else curve = 1/curve;
    let val = (input - inLow) * (1 / (inHigh - inLow));
    val = Math.pow(val, curve);
    return val * (outHigh - outLow) + outLow;
  }

/*
 * returns an element by querying its id
 * - the id of an element is unique
 * - multiple elements with the same label are id as label, label1, etc.
*/
// Function to retrieve an element by its label
const getElementByLabel = (p, label) => {
  const elementArray = Object.values(p.elements);
  for (const element of elementArray) {
    console.log(element.id)
    if (element.id === label) {
      return element;
    }
  }
  return null; // Return null if no matching element is found
};

p5.prototype.getElementByLabel = function (label) {
    getElementByLabel(this,label);
};



/********************** COLORS & FONTS ***********************/
const setColor = function(name, value) {
    if( name === 'border' ) activeTheme.borderColor = value
    else if( name === 'accent' )  activeTheme.accentColor = value
    else if( name === 'background' )  activeTheme.backgroundColor = value
    else if( name === 'text' )  activeTheme.textColor = value

    else if( typeof( name )==='string' && Array.isArray(value)){
        if(value.length = 3){
            activeTheme[name] = value;
            console.error(`new Color added: ${name}`);
        } else console.error('second argument must be an array of three values in RGB format')
    }
    else console.error(`incorrect color values: ${name}, ${value} `)
}

const getColor = function(name) {
    if( name === 'border' ) return activeTheme.borderColor
    if( name === 'accent' ) return activeTheme.accentColor
    if( name === 'background' ) return activeTheme.backgroundColor
    if( name === 'text' ) return activeTheme.textColor

    if (Array.isArray(name)){
        return name
    } else {
        console.error(`Invalid color property: ${name}`);
        return [0,0,0]
    }
}

const GuiFonts = {
    label: 'Helvetica',
    value: 'Courier',
    text: 'Times New Roman',
    title: 'Verdana',
};

const setFont = function(name, value) {
    if( name === 'label' ) activeTheme.labelFont = value
    else if( name === 'value' )  activeTheme.valueFont = value
    else if( name === 'text' )  activeTheme.textFont = value
    else if( name === 'title' )  activeTheme.titleFont = value

    else if( typeof( name ) === 'string' && typeof(value) === 'string'){
        activeTheme[name] = value;
            console.error(`new Font added: ${name}`);
    }
    else console.error(`incorrect font values: ${name}, ${value} `)
}

const getFont = function(name) {
    if( name === 'label' ) return activeTheme.labelFont 
    if( name === 'value' )  return activeTheme.valueFont 
    if( name === 'text' )  return activeTheme.textFont 
    if( name === 'title' )  return activeTheme.titleFont 

    if (typeof(name) === 'string'){
        return name
    } else {
        console.error(`Invalid font property: ${name}`);
        return 'Geneva'
    }
}

/**************************************** ELEMENT ******************************************/
let elementXPosition = 0;
let elementYPosition = 25;
let prevElementSize = 0;
let prevYElementSize = 0;
class Element {
    constructor(p, options) {
        this.p = p;
        this.ch = window.chClient;
        //console.log(this.ch)
        this.theme = activeTheme;
        this.label = options.label || "myElement";
        this.id = this.label;
        this.hide = false;
        let i = 1;
        while (this.id in p.elements) {
            this.id += i;
            i++;
        }
        //appearance
        this.style = options.style || 1;
        this.size = options.size || 1;
        this.textSize = options.textSize || 1;
        this.border = options.border || 'theme' || 6;
        this.borderColor = options.borderColor || 'border';
        this.accentColor = options.accentColor || 'accent';
        this.borderRadius = options.borderRadius || activeTheme.borderRadius || 0;
        
        //text
        this.textColor = options.textColor || 'text';
        this.showLabel = typeof(options.showLabel) === 'undefined' ? true : options.showLabel; //|| activeTheme.showLabel
        this.showValue = typeof(options.showValue) === 'undefined' ? true : options.showValue; //|| activeTheme.showValue
        this.labelFont = options.labelFont || 'label'
        this.valueFont = options.valueFont || 'value'
        this.textFont = options.textFont || 'text'
        this.labelX = options.labelX || 0
        this.labelY = options.labelY || 0
        this.valueX = options.valueX || 0
        this.valueY = options.valueY || 0
        this.textX = options.textX || 0
        this.textY = options.textY || 0

        //position
        let currentGap = (prevElementSize+this.size) / 2
        elementXPosition+=(8*currentGap+5);
        if(elementXPosition>(100-this.size*8)){
            elementXPosition = this.size/2*8+5
            elementYPosition += (20*prevYElementSize+10)
            prevYElementSize=this.size
        }
        this.x = options.x || elementXPosition;
        this.y = options.y || elementYPosition;
        prevElementSize = this.size
        prevYElementSize = this.size>prevYElementSize ? this.size : prevYElementSize;
        this.cur_x = (this.x/100)*this.p.width
        this.cur_y = (this.y/100)*this.p.height
        this.cur_size = (this.size/6)*this.p.width
        this.x_box = this.cur_size;
        this.y_box = this.cur_size;

        //parameter values
        this.active = 0;
        this.min = options.min || 0;
        this.max = options.max || 1;
        this.curve = options.curve || 1;
        if(typeof(options.mapto)=='string') this.mapto = eval(options.mapto)
        else this.mapto = options.mapto || null;
        this.callback = options.callback || null;
        if( this.mapto || this.callback) this.maptoDefined = 'true'
        else this.maptoDefined = 'false'
        this.rawValue = unScaleOutput(options.value,0,1,this.min,this.max,this.curve) || 0.5;
        this.value = options.value !=undefined ? options.value : scaleOutput(0.5,0,1,this.min,this.max,this.curve);
        p.elements[this.id] = this;

        //collab-hub sharing values
        this.linkName = typeof options.link === 'string' ? options.link : null; // share params iff link is defined
        this.linkFunc = typeof options.link === 'function' ? options.link : null; 
        
        // set listener for updates from collab-hub (for linkName only)
        if (this.linkName) {
            this.ch.on(this.linkName, (incoming) => {
                this.forceSet(this.ch.getControl(this.linkName));
            })
        }

        this.mapValue(this.value, this.mapto);
        this.runCallBack()
    }

    getParam(param,val){ return val==='theme' ? activeTheme[param] : val}

    isPressed(){
        if(this.hide===true) return;
        //console.log('isPressed', this.label, this.p.mouseX,this.cur_x , this.x_box);
        if( this.p.mouseX < (this.cur_x + this.x_box/2) &&
            this.p.mouseX > (this.cur_x - this.x_box/2) &&
            this.p.mouseY > (this.cur_y - this.y_box/2) &&
            this.p.mouseY < (this.cur_y + this.y_box/2) )
        {
            this.active = 1
            //console.log('pressedas', this.label, this.p.mouseX.toFixed(1), this.p.mouseY.toFixed(1), this.cur_x.toFixed(1), this.cur_y.toFixed(1), this.x_box, this.y_box)
        }
    }

    isReleased(){
        if(this.hide===true) return;
        if( this.active===1 )  this.active = 0
    }

    resize(scaleWidth, scaleHeight) {
        this.x *= scaleWidth;
        this.y *= scaleHeight;
    }

    drawLabel(x,y){
        this.p.textSize(this.textSize*10);
        this.p.stroke(this.setColor(this.textColor))
        this.p.strokeWeight(0.00001 * this.textSize*20);
        this.p.textAlign(this.p.CENTER, this.p.CENTER);
        this.p.fill(this.setColor(this.textColor));
        this.p.textFont(getFont(this.labelFont))
        this.p.text(this.label, x + (this.labelX/100)*this.p.width, y + (this.labelY/100)*this.p.height);
    }

    drawValue(x,y){
        let output = this.value
        this.p.stroke(this.setColor(this.textColor))
        this.p.textSize(this.textSize*10);
        this.p.strokeWeight(0.00001 * this.textSize*20);
        this.p.textAlign(this.p.CENTER, this.p.CENTER);
        this.p.fill(this.setColor(this.textColor));
        this.p.textFont(getFont(this.valueFont))
        if(Math.abs(output) < 1) output = output.toFixed(4)
        else if(Math.abs(output) < 5) output = output.toFixed(3) 
        else if(Math.abs(output) < 100) output = output.toFixed(2) 
        else  output = output.toFixed(1)   
        this.p.text(output, x + (this.valueX/100)*this.p.width, y + (this.valueY/100)*this.p.height);
    }

    drawText(text,x,y){
        this.p.textSize(this.textSize*10);
        this.p.stroke(this.setColor(this.textColor))
        this.p.strokeWeight(0.00001 * this.textSize*20);
        this.p.textAlign(this.p.CENTER, this.p.CENTER);
        this.p.fill(getColor(this.textColor));
        this.p.textFont(getFont(this.textFont))
        this.p.text(text, x + (this.textX/100)*this.p.width, y + (this.textY/100)*this.p.height);
    }

    setPosition(x, y) {
        this.x = x;
        this.y = y;
    }

    setColor( arg ){
        if( typeof(arg)==='string'){
            return getColor( arg )
        }
        else if( Array.isArray(arg) ){
            if( arg.length===3) return arg
        } 
        console.log(this.label, typeof(arg), 'invalid color')
        return [0,0,0]
    }

    mapValue(output, destination) {
        if (destination) {
            try {
                destination.value.rampto(output, .1);
            } catch {
                try {
                    destination.value = output;
                } catch {
                    try {
                        //console.log(destination, output)
                        destination = output;
                    } catch (error) {
                        console.log('Error setting Mapto to value: ', error);
                    }
                }
            }
        } else if( this.maptoDefined==='false'){ console.log(this.label, 'no destination defined')}
    }

    runCallBack() {
        if (this.callback) {
            let output = this.value
            try {
                this.callback(output);
            } catch {
                try {
                    this.callback();
                } catch (error) {
                    console.log('Error with Callback Function: ', error);
                }
            }
        } else if( this.maptoDefined==='false'){ console.log(this.label, 'no destination defined')}

        // send updates to collab-hub
        if (this.sendName) { 
            this.ch.control(this.sendName, this.value);
        }
    }

    set(value){
        if(typeof(value) === 'string') this.value = value;
        else{
            this.value = value
            this.rawValue = unScaleOutput(value,0,1,this.min,this.max,this.curve);
            this.mapValue(this.value, this.mapto);
        }

        this.runCallBack()

        // send updates to collab-hub
        if (this.linkName) { 
            this.ch.control(this.linkName, this.value);
        }
        if (this.linkFunc) { 
            this.linkFunc();
        }
    }

    forceSet(value){
        // sets value without sending data to collab-hub
        if(typeof(value) === 'string') this.value = value;
        else{
            this.value = value
            this.rawValue = unScaleOutput(value,0,1,this.min,this.max,this.curve) || 0.5;
            this.mapValue(this.value, this.mapto);
        }

        this.runCallBack()
    }
}

/**************************************** KNOB ******************************************/
class Knob extends Element {
    constructor(p, options) {
        super(p, options);
        this.incr = options.incr || 0.01;
        this.degrees = options.degrees || 320;
        this.startAngle = this.p.PI * (4/8 + (360 - this.degrees)/360);
        this.endAngle = this.p.PI * (4/8 - (360 - this.degrees)/360 ) + 2 * this.p.PI;

        // send initial val to collab-hub
        if (this.linkName) { 
            this.ch.control(this.linkName, this.value);
        }
        if (this.linkFunc) this.linkFunc();
    }

    resize(scaleWidth, scaleHeight) {
        super.resize(scaleWidth, scaleHeight);
        if (Math.max(Math.abs(1 - scaleWidth)) > Math.max(Math.abs(1 - scaleHeight))) this.size *= scaleWidth;
        else this.size *= scaleHeight;
    }

    draw() {
        if(this.hide===true) return;
        // Calculate the angle based on the knob's value
        this.startAngle = this.p.PI * (4/8 + (360 - this.degrees)/360);
        this.endAngle = this.p.PI * (4/8 - (360 - this.degrees)/360 ) + 2 * this.p.PI;
        let angle = this.p.map(this.rawValue, 0,1, 0, this.endAngle-this.startAngle);

        this.cur_x = (this.x/100)*this.p.width
        this.cur_y = (this.y/100)*this.p.height
        this.cur_size = (this.size/6)*this.p.width/2
        this.x_box = this.cur_size
        this.y_box = this.cur_size

        let border = this.getParam('border',this.border)

        // clear the previously drawn knob
        // this.p.fill(getColor('background'));
        // let  strokeWeight = this.border;
        // this.p.strokeWeight(strokeWeight);
        // this.p.stroke(getColor('background'));
        // this.p.arc(cur_x, cur_y, cur_size*1.2, cur_size*1.2,0,2*this.p.PI);

        // Display the label string beneath the knob
        this.p.textSize(this.textSize*10);
        let textWidthValue = this.p.textWidth(this.label);
        let textHeightValue = this.p.textAscent() + this.p.textDescent();
        if(this.showLabel) this.drawLabel(this.cur_x, this.cur_y + this.cur_size/2 + textHeightValue * .5 )
        if(this.showValue) this.drawValue(this.cur_x, this.cur_y + this.cur_size/2 + textHeightValue * (this.showLabel ? 1.5 : .5))

        // Draw the inactive knob background
        this.p.noFill();
        this.p.strokeWeight(border);
        this.p.stroke(this.setColor(this.borderColor))
        this.p.arc(this.cur_x, this.cur_y, this.cur_size, this.cur_size, this.p.constrain(this.startAngle + angle + (border/30/this.size/2),this.startAngle,this.endAngle), this.endAngle);

        // Draw the active knob background
        this.p.stroke(this.setColor(this.accentColor));
        this.p.arc(this.cur_x, this.cur_y, this.cur_size, this.cur_size, this.startAngle, this.p.constrain(this.startAngle + angle - (border/30/this.size/2),this.startAngle,this.endAngle));

        // Draw the knob value indicator as a line
        let indicatorLength = this.cur_size / 2 // Length of the indicator line
        let indicatorX = this.cur_x + this.p.cos(this.startAngle+angle) * indicatorLength;
        let indicatorY = this.cur_y + this.p.sin(this.startAngle+angle) * indicatorLength;
        this.p.stroke(this.setColor(this.accentColor));
        this.p.line(this.cur_x, this.cur_y, indicatorX, indicatorY);
    }

    isDragged() {
        if(this.hide===true) return;
        if(this.active){
        
            if(this.p.movedY != 0 ){ 
                if( this.p.keyIsDown(this.p.ALT)) this.rawValue -= this.p.movedY * this.incr/10;
                else this.rawValue -= this.p.movedY * this.incr;
            }
            
            if( this.rawValue > 1 ) this.rawValue = 1
            if( this.rawValue < 0 ) this.rawValue = 0
            this.value = scaleOutput(this.rawValue,0,1,this.min,this.max,this.curve)
            this.mapValue(this.value, this.mapto);

            this.runCallBack()

            // send updates to collab-hub
            if (this.linkName) { 
                this.ch.control(this.linkName, this.value);
            }
            if (this.linkFunc) this.linkFunc();
        }
    }
}

p5.prototype.Knob = function (options = {}) {
    return new Knob(this, options);
};

p5.prototype.Dial = function (options = {}) {
    return new Knob(this, options);
};

/**************************************** FADER ******************************************/
class Fader extends Element {
    constructor(p, options) {
        super(p, options);
        this.incr = options.incr || 0.01;
        this.orientation = options.orientation === 'horizontal'? 'horizontal' : 'vertical';
        this.isHorizontal = this.orientation==='horizontal'
        this.value = this.value || 0.5
        this.dragging = false;
        this.size = options.size || 1

        // send initial val to collab-hub
        if (this.linkName) { 
            this.ch.control(this.linkName, this.value);
        }
        if (this.linkFunc) this.linkFunc();
    }

    resize(scaleWidth, scaleHeight) {
        super.resize(scaleWidth, scaleHeight);
        this.size *= this.isHorizontal ? scaleWidth : scaleHeight;
    }

    draw() {
        if(this.hide===true) return;
        this.isHorizontal = this.orientation==='horizontal'
        this.cur_size = (this.size/6)*this.p.width/2
        let border = this.getParam('border',this.border)
        
        let x_corner = (this.x/100)*this.p.width
        let y_corner = (this.y/100)*this.p.height
        if( this.isHorizontal ) {
            this.x_box = this.cur_size
            this.y_box = border * 3 * this.size
            this.cur_x = (this.x/100)*this.p.width + this.cur_size/2
            this.cur_y = (this.y/100)*this.p.height + border
        }
        else  {
            this.y_box = this.cur_size
            this.x_box = border * 3 * this.size
            this.cur_x = (this.x/100)*this.p.width + border
            this.cur_y = (this.y/100)*this.p.height + this.cur_size/2
        }
        let strokeWeight = border*this.size;
        this.thickness = border // cur_size * .1; //Indicator thickness
        let rectThickness = this.thickness * .95;

        // Display the label and value strings
        this.p.textSize(this.textSize*10);
        let textWidthValue = this.p.textWidth(this.label);
        let textHeightValue = this.p.textAscent() + this.p.textDescent();
        let curTextY = this.isHorizontal ? this.cur_y+border*2 + textHeightValue* .5 : this.cur_y+this.cur_size/2+ border + textHeightValue * .5
        if(this.showLabel) this.drawLabel(this.cur_x, curTextY)
        if(this.showValue) this.drawValue(this.cur_x, curTextY + (this.showLabel ? 1: 0 ) * textHeightValue)

        //Display Actual Fader
        this.p.noFill();
        this.p.stroke(this.setColor(this.borderColor))
        this.p.strokeWeight(border*1.5);
        if (this.isHorizontal) this.p.rect(x_corner, y_corner, this.cur_size, border*2);
        else this.p.rect(x_corner, y_corner, border*2, this.cur_size);
        // this.p.stroke(getColor(this.accentColor))
        // if (this.isHorizontal) this.p.rect(this.cur_x, this.cur_y, this.cur_size, border);
        // else this.p.rect(this.cur_x, this.cur_y, rectThickness, this.cur_size);

        //Clear beneath Display Indicator
        this.p.fill(getColor('background') )
        this.p.stroke(this.setColor('background') )
        this.pos = this.p.map(this.rawValue, 0,1, this.isHorizontal ? x_corner : y_corner + this.cur_size - this.thickness, this.isHorizontal ? x_corner + this.cur_size - this.thickness : y_corner);
        let clearSize = border*.25
        if (this.isHorizontal) this.p.rect(this.pos-clearSize, y_corner, this.thickness+clearSize*2, this.thickness*2);
        else this.p.rect(x_corner, this.pos-clearSize, this.thickness*2, this.thickness+clearSize*2);
        //Display indicator
        this.p.fill(this.setColor(this.accentColor));
        this.p.stroke(this.setColor(this.accentColor))
        this.pos = this.p.map(this.rawValue, 0,1, this.isHorizontal ? x_corner : y_corner + this.cur_size - this.thickness, this.isHorizontal ? x_corner + this.cur_size - this.thickness : y_corner);
        if (this.isHorizontal) this.p.rect(this.pos, y_corner, this.thickness, this.thickness*2);
        else this.p.rect(x_corner, this.pos, this.thickness*2, this.thickness);
    }

    isDragged() {
        if(this.hide===true) return;
        if( this.active ){
            if (this.isHorizontal){
                if(this.p.movedX !== 0 ){ 
                    if( this.p.keyIsDown(this.p.ALT)) this.rawValue += this.p.movedX * this.incr/10;
                    else this.rawValue += this.p.movedX * this.incr / this.size;
                }
            }
            else {
                if(this.p.movedY !== 0 ){ 
                    if( this.p.keyIsDown(this.p.ALT)) this.rawValue -= this.p.movedY * this.incr/10;
                    else this.rawValue -= this.p.movedY * this.incr / this.size;
                }
            }
            if( this.rawValue > 1 ) this.rawValue = 1
            if( this.rawValue < 0 ) this.rawValue = 0
            this.value = scaleOutput(this.rawValue,0,1,this.min,this.max,this.curve)
            this.mapValue(this.value, this.mapto);
            
            this.runCallBack()

            // send updates to collab-hub
            if (this.linkName) { 
                this.ch.control(this.linkName, this.value);
            }
            if (this.linkFunc) this.linkFunc();
        }
    }
}

p5.prototype.Fader = function (options = {}) {
    return new Fader(this, options);
};

p5.prototype.Slider = function (options = {}) {
    return new Fader(this, options);
};

/**************************************** PAD ******************************************/
// NOTE THIS LOOKS BROKEN!!
// It's the only element that has a custom valueX, valueY thingy
// var value gets ignored and so the callback doesn't work asa expected
// maybe represent values of x and y as a string instead??
// doesn't support collab-hub features as of now for the same reason

class Pad extends Element {
    constructor(p, options) {
        super(p, options);
        this.incr = options.incr || 0.01;
        this.valueX = this.valueX || 0.5
        this.valueY = this.valueY || 0.5
        this.rawValueX = this.valueX
        this.rawValueY = this.valueY
        this.dragging = false;
        this.sizeX = options.sizeX || options.size || 5
        this.sizeY = options.sizeY || options.size || 5
        if(typeof(options.maptoX)=='string') this.maptoX = eval(options.maptoX)
        else this.maptoX = options.maptoX || null;
        if(typeof(options.maptoY)=='string') this.maptoY = eval(options.maptoY)
        else this.maptoY = options.maptoY || null;

        // send initial val to collab-hub
        if (this.linkName) { 
            this.ch.control(this.linkName, this.value);
        }
        if (this.linkFunc) this.linkFunc();
    }

    resize(scaleWidth, scaleHeight) {
        super.resize(scaleWidth, scaleHeight);
        //this.size *= this.isHorizontal ? scaleWidth : scaleHeight;
    }

    draw() {
        if(this.hide===true) return;
        this.cur_size = (this.size/6)*this.p.width/2
        this.cur_sizeX = (this.sizeX/6)*this.p.width/2
        this.cur_sizeY = (this.sizeY/6)*this.p.width/2
        let border = this.getParam('border',this.border)
        
        let x_corner = (this.x/100)*this.p.width-this.cur_sizeX/2
        let y_corner = (this.y/100)*this.p.height-this.cur_sizeY/2

        this.x_box = this.cur_sizeX*2
        this.y_box = this.cur_sizeY*2
        this.cur_x = (this.x/100)*this.p.width //+ this.cur_sizeX/2
        this.cur_y = (this.y/100)*this.p.height //+ this.cur_sizeY/2

        //console.log(this.cur_x, this.cur_y, this.x_box,this.y_box)
      
        let strokeWeight = border
        this.thickness = border // cur_size * .1; //Indicator thickness
        let rectThickness = this.thickness * .95;

        //Display Actual Fader
        this.p.fill(this.setColor(this.borderColor));
        this.p.stroke(this.setColor(this.borderColor))
        this.p.strokeWeight(border*1.5);
        this.p.rect(x_corner, y_corner, this.cur_sizeX, this.cur_sizeY);
        
        //Display indicator
        this.p.fill(this.setColor(this.accentColor));
        this.p.stroke(this.setColor(this.accentColor))
        let indicatorX = x_corner + this.rawValueX *  (this.cur_sizeX - 0*border)
        let indicatorY = y_corner + this.rawValueY * ( this.cur_sizeY - 0*border)
        //this.pos = this.p.map(this.value, 0,1,  x_corner  + this.cur_size - this.thickness, this.isHorizontal ? x_corner + this.cur_size - this.thickness : y_corner);
        this.p.circle(indicatorX, indicatorY, (this.cur_sizeX+this.cur_sizeY)/30)    
   
        // Display the label and values
        let textHeightValue = this.p.textAscent() + this.p.textDescent();
        if(this.showLabel) this.drawLabel(this.cur_x,  this.cur_y - this.cur_sizeY/2 - textHeightValue)

             // Display the label and value strings
        // this.p.textSize(this.textSize*10);
        // let textWidthValue = this.p.textWidth(this.label);
        // let textHeightValue = this.p.textAscent() + this.p.textDescent();
        // let curTextY = this.isHorizontal ? this.cur_y+border*2 + textHeightValue* .5 : this.cur_y+this.cur_size/2+ border + textHeightValue * .5
        // if(this.showLabel) this.drawLabel(this.cur_x, curTextY)
        // if(this.showValue) this.drawValue(this.cur_x, curTextY + textHeightValue)

    }

    isDragged() {
        if(this.hide===true) return;
        if( this.active ){
            if(this.p.movedX !== 0 ){ 
                if( this.p.keyIsDown(this.p.ALT)) this.rawValueX += this.p.movedX * this.incr/10;
                else this.rawValueX += this.p.movedX * this.incr / this.sizeX;
            }

            if(this.p.movedY !== 0 ){ 
                if( this.p.keyIsDown(this.p.ALT)) this.rawValueY += this.p.movedY * this.incr/10;
                else this.rawValueY += this.p.movedY * this.incr / this.sizeY;
            }

            if( this.rawValueX > 1 ) this.rawValueX = 1
            if( this.rawValueX < 0 ) this.rawValueX = 0
            this.valueX = scaleOutput(this.rawValueX,0,1,this.min,this.max,this.curve)
            this.mapValue(this.valueX,this.maptoX);

            if( this.rawValueY > 1 ) this.rawValueY = 1
            if( this.rawValueY < 0 ) this.rawValueY = 0
            this.valueY = scaleOutput(this.rawValueY,0,1,this.min,this.max,this.curve)
            this.mapValue(this.valueY,this.maptoY);
            this.runCallBack()

            //collab-hub....
        }
    }
}

p5.prototype.Pad = function (options = {}) {
    return new Pad(this, options);
};

p5.prototype.JoyStick = function (options = {}) {
    return new Pad(this, options);
};

/**************************************** BUTTON ******************************************/
class Button extends Element {
    constructor(p, options) {
        super(p, options);
        this.value = options.value || 0
        this.rawValue = this.value
        this.cornerRadius = options.cornerRadius || 1

        // send initial val to collab-hub
        if (this.linkName) { 
            this.ch.control(this.linkName, this.value);
        }
        if (this.linkFunc) this.linkFunc();
    }

    resize(scaleWidth, scaleHeight) {
        super.resize(scaleWidth, scaleHeight)
        this.size *= this.horizontal !== false ? scaleWidth : scaleHeight;
    }

    draw() {
        if(this.hide===true) return;
        this.cur_x = (this.x/100)*this.p.width
        this.cur_y = (this.y/100)*this.p.height
        this.cur_size = (this.size/6)*this.p.width/2
        this.x_box = this.cur_size
        this.y_box = this.cur_size
        let border = this.getParam('border',this.border)

        if( this.rawValue ){            
            this.p.fill(this.setColor(this.accentColor))
            this.p.stroke(this.setColor(this.borderColor));
            this.p.strokeWeight(border/2);
            this.p.rect(this.cur_x - this.cur_size/2, this.cur_y - this.cur_size/2, this.cur_size, this.cur_size, this.cur_size/2 * this.cornerRadius);
        }
        else{
            this.p.noFill()
            this.p.stroke(this.setColor(this.borderColor));
            this.p.strokeWeight(border/2);
            this.p.rect(this.cur_x - this.cur_size/2, this.cur_y - this.cur_size/2, this.cur_size, this.cur_size, this.cur_size/2 * this.cornerRadius);
        }

        // Display the label string inside the button
        if(this.showLabel) this.drawLabel(this.cur_x, this.cur_y)//if(this.showValue) this.drawValue(this.cur_x, this.cur_y+6*(2+this.size*2.5) )
    }

    isPressed(){
        if(this.hide===true) return;
        if( this.p.mouseX < (this.cur_x + this.x_box/2) &&
            this.p.mouseX > (this.cur_x - this.x_box/2) &&
            this.p.mouseY > (this.cur_y - this.y_box/2) &&
            this.p.mouseY < (this.cur_y + this.y_box/2) )
        {
            this.active = 1
            this.rawValue = 1
            this.value = scaleOutput(this.rawValue,0,1,this.min,this.max,this.curve)
            this.mapValue(this.value,this.mapto);
            this.runCallBack();
            if( this.maptoDefined==='false') postButtonError('Buttons')

            // send updates to collab-hub
            if (this.linkName) { 
                this.ch.control(this.linkName, this.value);
            }
            if (this.linkFunc) this.linkFunc();

        }
    }

    isReleased(){
        if(this.hide===true) return;
        if( this.active===1 )  {
            this.active = 0
            this.rawValue = 0
            this.value = scaleOutput(this.rawValue,0,1,this.min,this.max,this.curve)

            // send updates to collab-hub
            if (this.linkName) { 
                this.ch.control(this.linkName, this.value);
            }
            if (this.linkFunc) this.linkFunc();
        }
    }

    forceSet(value){
        // sets value without sending data to collab-hub
        if (value) {
            this.active = 1
            this.rawValue = 1
            this.value = scaleOutput(this.rawValue,0,1,this.min,this.max,this.curve)
            this.mapValue(this.value,this.mapto);

            this.runCallBack();
            if( this.maptoDefined==='false') postButtonError('Buttons')

        } else {
            this.active = 0
            this.rawValue = 0
            this.value = scaleOutput(this.rawValue,0,1,this.min,this.max,this.curve)
        }
    }
}

p5.prototype.Button = function (options = {}) {
    return new Button(this, options);
};

function postButtonError(name){
    if(name === 'Buttons') console.log(name + ' generally work by defining a callback function. For buttons, the value is 1 on every press.')
    if(name === 'Toggle buttons') console.log(name + ' generally work by defining a callback function. The value for toggle buttons alternates between 1 and 0.')
    if(name === 'RadioButtons') console.log(name + ' generally work by defining a callback function. The value for radio buttons is the text string of the selected button.')
    
    if(name === 'Buttons') console.log(`An example of defining a callback for a button is: 
callback: function(val){ env.triggerAttackRelease(0.1) }`)
    if(name === 'Toggle buttons') console.log(`An example of defining a callback for a toggle is: 
callback: function(val){ 
    if(val==1) vco.type = 'square'; 
    else vco.type = 'sawtooth'; 
}`)
    if(name === 'RadioButtons') console.log(`An example of defining a callback for a radio button is: 
callback: function(val){ vco.type = val }`)
}

/**************************************** MOMENTARY ******************************************/
class Momentary extends Button {
    constructor(p, options) {
        super(p, options);
        this.value = options.value || 0
        this.rawValue = this.value
    }

    isReleased(){
        if(this.hide===true) return;
        if( this.active===1 )  {
            this.active = 0
            this.rawValue = 0
            this.value = scaleOutput(this.rawValue,0,1,this.min,this.max,this.curve)
            this.mapValue(this.value,this.mapto);
            this.runCallBack();
        }
    }
}

p5.prototype.Momentary = function (options = {}) {
    return new Momentary(this, options);
};

/**************************************** TOGGLE ******************************************/
class Toggle extends Button {
    constructor(p, options) {
        super(p, options);
        this.state = options.state || false;

        // send initial val to collab-hub
        if (this.linkName) { 
            this.ch.control(this.linkName, this.value);
        }
        if (this.linkFunc) this.linkFunc();
    }

    isPressed(){
        if(this.hide===true) return;
        if( this.p.mouseX < (this.cur_x + this.x_box/2) &&
            this.p.mouseX > (this.cur_x - this.x_box/2) &&
            this.p.mouseY > (this.cur_y - this.y_box/2) &&
            this.p.mouseY < (this.cur_y + this.y_box/2) )
        {
            this.active = 1
            this.rawValue = this.rawValue ? 0 : 1
            this.value = scaleOutput(this.rawValue,0,1,this.min,this.max,this.curve)
            this.mapValue(this.value,this.mapto);
            this.runCallBack();
            if( this.maptoDefined==='false') postButtonError('Toggle buttons')

            // send updates to collab-hub
            if (this.linkName) { 
                this.ch.control(this.linkName, this.value);
            }
            if (this.linkFunc) this.linkFunc();
        }
    }

    isReleased(){
        if(this.hide===true) return;
        if( this.active===1 )  {
            this.active = 0
        }
    }

    forceSet(value){
        // sets value without sending data to collab-hub
        this.rawValue = value
        this.value = scaleOutput(this.rawValue,0,1,this.min,this.max,this.curve)
        this.mapValue(this.value,this.mapto);

        this.runCallBack();
        if( this.maptoDefined==='false') postButtonError('Toggle buttons')
    }
}

p5.prototype.Toggle = function (options = {}) {
    return new Toggle(this, options);
};

/**************************************** RADIO BUTTON ******************************************/
class RadioButton extends Button {
    constructor(p, options) {
        super(p, options);
        this.radioOptions = options.radioOptions || ['on', 'off'];
        this.orientation = options.orientation || 'vertical';
        this.isHorizontal = this.orientation==='horizontal'
        this.value = options.value || this.radioOptions[0]; //default first radioOption
        this.radioHeight = this.cur_size / 2;
        this.radioWidth = this.cur_size * 2;
        this.border = options.border ||activeTheme.radioBorder || 2

        // send initial val to collab-hub
        if (this.linkName) { 
            this.ch.control(this.linkName, this.value);
        }
        if (this.linkFunc) this.linkFunc();
    }

    draw() {
        if(this.hide===true) return;
        this.radioClicked = {};

        this.isHorizontal = this.orientation==='horizontal'
        this.cur_size = (this.size/6)*this.p.width/2
        
        this.radioHeight = this.cur_size / 2;
        this.radioWidth = this.cur_size * 2;
        let border = this.getParam('border',this.border)


        //calculate widest radioOption for radioButton width
        this.p.textSize(this.textSize*10);
        let textWidth = 0 
        for (let i = 0; i < this.radioOptions.length; i++){
            let width = this.p.textWidth(this.radioOptions[i]);
            if( width > textWidth) textWidth = width
        }
        this.cur_size = textWidth
        this.radioWidth = this.cur_size * 1.5;

        if( this.isHorizontal ) {
            this.cur_x = (this.x/100)*this.p.width
            this.cur_y = (this.y/100)*this.p.height

            this.x_corner = this.cur_x - this.radioWidth * this.radioOptions.length / 2
            this.y_corner = this.cur_y - this.radioHeight/2

            this.x_box = this.radioWidth * this.radioOptions.length
            this.y_box = this.radioHeight    
        }
        else  {
            this.cur_x = (this.x/100)*this.p.width
            this.cur_y = (this.y/100)*this.p.height

            this.x_corner = this.cur_x - this.radioWidth/2
            this.y_corner = this.cur_y - this.radioHeight * this.radioOptions.length / 2 

            this.y_box = this.radioHeight * this.radioOptions.length
            this.x_box = this.radioWidth
        }
        
        if(this.showLabel) this.drawLabel(this.cur_x, 
            this.isHorizontal ? this.cur_y+this.radioHeight : this.cur_y+this.radioHeight*(this.radioOptions.length / 2 + 0.5 ) 
            )

        for (let i = 0; i < this.radioOptions.length; i++) {
            let option = this.radioOptions[i];
            let x = this.isHorizontal ? this.x_corner + i * this.radioWidth : this.x_corner;
            let y = this.isHorizontal ? this.y_corner : this.y_corner + this.radioHeight * i;

            this.p.fill(this.value===option ? this.setColor(this.accentColor) : this.setColor(this.borderColor));
            this.p.stroke(0);
            this.p.strokeWeight(border);
            this.p.rect(x, y, this.radioWidth, this.radioHeight);

            this.drawText(option,  x+this.radioWidth/2,  y + this.radioHeight/2 )
             this.radioClicked[this.radioOptions[i]] = () => {
                if (this.isHorizontal) return this.p.mouseX >= x && this.p.mouseX <= x + this.radioSize
                else return this.p.mouseY >= y && this.p.mouseY <= y + this.radioSize / 2
            };
        }
    }


    isPressed() {
        if(this.hide===true) return;
        if( this.p.mouseX < (this.cur_x + this.x_box/2) &&
            this.p.mouseX > (this.cur_x - this.x_box/2) &&
            this.p.mouseY > (this.cur_y - this.y_box/2) &&
            this.p.mouseY < (this.cur_y + this.y_box/2) )
        {
            
            if( this.isHorizontal){
                let position = (this.cur_x + this.x_box/2) -  this.p.mouseX
                position = Math.floor(position / this.radioWidth)
                position = this.radioOptions.length - position - 1
                this.value = this.radioOptions[position]
            } else{
                let position = (this.cur_y + this.y_box/2) - this.p.mouseY 
                position = Math.floor(position / this.radioHeight)
                position = this.radioOptions.length - position - 1
                this.value = this.radioOptions[position]
            }
            this.active = 1

            this.runCallBack();
            this.mapValue(this.value, this.mapto);
            if( this.maptoDefined==='false') postButtonError('RadioButtons')

            // send updates to collab-hub
            if (this.linkName) { 
                this.ch.control(this.linkName, this.value);
            }
            if (this.linkFunc) this.linkFunc();
        }
    }

    isReleased() {
        //so super isReleased not called
    }
}

p5.prototype.RadioButton = function (options = {}) {
    return new RadioButton(this, options);
};

p5.prototype.Radio = function (options = {}) {
    return new RadioButton(this, options);
};

/**************************************** DROPDOWN MENU ******************************************/

class Dropdown extends Button {
    constructor(p, options) {
        super(p, options);
        this.dropdownOptions = options.dropdownOptions || ['on', 'off'];
        this.value = options.value || this.dropdownOptions[0]; // Default to the first dropdown option
        this.isOpen = false; // Track whether the dropdown is open
        this.cur_size = this.size || 30; // Increase the size for better readability
        this.border = options.border || activeTheme.radioBorder || 2;
        this.accentColor = options.accentColor || [200, 50, 0]; // Default accent color

        // Send initial value to collab-hub if linked
        if (this.linkName) { 
            this.ch.control(this.linkName, this.value);
        }
        if (this.linkFunc) this.linkFunc();
    }

    draw() {
        if (this.hide === true) return;

        this.cur_x = (this.x / 100) * this.p.width;
        this.cur_y = (this.y / 100) * this.p.height;

        this.p.textSize(this.cur_size * 0.9); // Larger text size
        let textWidth = this.p.textWidth(this.value);
        this.boxWidth = Math.max(textWidth + 20, 100); // Ensure a minimum width for the dropdown
        this.boxHeight = this.cur_size;

        // Draw the main dropdown box
        this.p.fill(255); // Background color
        this.p.stroke(0); // Border color
        this.p.strokeWeight(this.border);
        this.p.rect(this.cur_x, this.cur_y, this.boxWidth, this.boxHeight);

        this.drawText(this.value, this.cur_x + this.boxWidth / 2, this.cur_y + this.boxHeight / 2);

        if (this.isOpen) {
            for (let i = 0; i < this.dropdownOptions.length; i++) {
                let option = this.dropdownOptions[i];
                let y = this.cur_y + (i + 1) * (this.boxHeight + 2); // Increase spacing between options

                if (this.value === option) {
                    this.p.fill(this.accentColor); // Selected option background
                } else {
                    this.p.fill(200); // Unselected option background color (light grey)
                }

                this.p.stroke(0);
                this.p.rect(this.cur_x, y, this.boxWidth, this.boxHeight);
                this.p.fill(0); // Text color
                this.drawText(option, this.cur_x + this.boxWidth / 2, y + this.boxHeight / 2);
            }
        }
    }

    isPressed() {
        if (this.hide === true) return;

        if (this.p.mouseX >= this.cur_x && this.p.mouseX <= this.cur_x + this.boxWidth &&
            this.p.mouseY >= this.cur_y && this.p.mouseY <= this.cur_y + this.boxHeight) {
            this.isOpen = !this.isOpen; // Toggle dropdown open/close state
        } else if (this.isOpen) {
            // Check if click is on one of the options
            for (let i = 0; i < this.dropdownOptions.length; i++) {
                let y = this.cur_y + (i + 1) * (this.boxHeight + 2); // Calculate the position of each option
                if (this.p.mouseX >= this.cur_x && this.p.mouseX <= this.cur_x + this.boxWidth &&
                    this.p.mouseY >= y && this.p.mouseY <= y + this.boxHeight) {
                    this.value = this.dropdownOptions[i];
                    this.isOpen = false;
                    this.runCallBack();
                    this.mapValue(this.value, this.mapto);
                    if (this.maptoDefined === 'false') postButtonError('Dropdown');

                    // Send updates to collab-hub if linked
                    if (this.linkName) {
                        this.ch.control(this.linkName, this.value);
                    }
                    if (this.linkFunc) this.linkFunc();
                    return; // Exit after selecting an option
                }
            }

            // Close dropdown if clicked outside
            this.isOpen = false;
        } else {
            this.isOpen = false; // Close dropdown if clicked outside
        }
    }

    isReleased() {
        // Override to prevent calling the superclass method
    }
}

p5.prototype.Dropdown = function (options = {}) {
    return new Dropdown(this, options);
};



/**************************************** LINES ******************************************/
class Line extends Element {
    constructor(p, x1,y1,x2,y2, options) {
        super(p, options);
        this.x1 = x1 || 0
        this.x2 = x2 || 0
        this.y1 = y1 || 0
        this.y2 = y2 || 0
        this.showLabel = options.showLabel || 'false'
        this.border = options.border || 2
        this.color = options.color ||activeTheme.lineColor || 'border'
    }

    resize(scaleWidth, scaleHeight) {
        super.resize(scaleWidth, scaleHeight)
        this.size *= this.horizontal !== false ? scaleWidth : scaleHeight;
    }

    draw() {
        if(this.hide===true) return;
        let x1 = (this.x1/100)*this.p.width
        let x2 = (this.x2/100)*this.p.width
        let y1 = (this.y1/100)*this.p.height
        let y2 = (this.y2/100)*this.p.height
        let border = this.getParam('border',this.border)

        this.p.fill(this.setColor(this.color));
        this.p.stroke(this.setColor(this.color));
        this.p.strokeWeight(border*2);
        this.p.line(x1,y1,x2,y2)
    }

    isPressed() {}
    pressed() { }
    isReleased() {}
}

p5.prototype.Line = function (x1,y1,x2,y2, options = {}) {
    return new Line(this, x1,y1,x2,y2, options);
};

/**************************************** TEXT ******************************************/
class Text extends Element {
    constructor(p, options) {
        super(p, options);
        this.border = options.border || activeTheme['border'] || 0
        this.textSize = options.size || activeTheme['textSize'] || options.textSize || 1
    }

    resize(scaleWidth, scaleHeight) {
        super.resize(scaleWidth, scaleHeight)
        this.size *= this.horizontal !== false ? scaleWidth : scaleHeight;
    }

    draw() {
        if(this.hide===true) return;
        this.cur_x = (this.x/100)*this.p.width
        this.cur_y = (this.y/100)*this.p.height
        this.cur_size = (this.size/6)*this.p.width/2
        let border = this.getParam('border',this.border)
        let borderRadius = this.getParam('borderRadius',this.borderRadius)

        this.drawText(this.label,this.cur_x, this.cur_y)
        
        if(border > 0 ){
            let textWidthValue = this.p.textWidth(this.label);
            let textHeightValue = this.p.textAscent() + this.p.textDescent();
            this.p.noFill()
            this.p.stroke(this.setColor(this.borderColor));
            this.p.strokeWeight(border);
            this.p.rect(this.cur_x-textWidthValue/2-2-borderRadius/2,this.cur_y-textHeightValue/2-1,
                textWidthValue+4+borderRadius, textHeightValue+1,
                borderRadius,borderRadius)
        }
    }

    isPressed() {}
    pressed() {}
    isReleased() {}
}

p5.prototype.Text = function (options = {}) {
    return new Text(this, options);
};




;

const sketch = (p) => {
    let grey = p.color(220, 229, 234);
    let div;
    p.setColor = setColor;
    p.setFont = setFont;
    p.debug = debug

    //theme functions
    p.setTheme = setTheme
    p.listThemes = listThemes
    p.setThemeParameters = setThemeParameters
    p.exportTheme = exportTheme

    p.p5Code = '';

    p.Debug = function(){ p.debug(); }

    p.setup = function () {
        let divID = p.canvas.parentElement.id;
        let div = document.getElementById(p.canvas.parentElement.id);
        // div = document.getElementById(props.id);
        let dim =  p.initialize(div, grey) 

        p.width = dim[0]
        p.height = dim[1]
        p.frame = 0
        p.x = 0
        p.y = 0
        p.capture = null
    };

    p.draw = function () {
        p.drawBackground();        

        try {
            eval(p.p5Code);
        } catch (error) {
            console.log("Error in p5Code: ", error);
        }
        p.frame += 1

        p.drawElements();
        
    };

    p.mousePressed = function () {
        for (const element of Object.values(p.elements)) {
            if (typeof (element) !== 'string') {
                try {
                    element.isPressed();
                } catch (e) {
                    //no pressed function
                }
            }
        }
    }

    p.mouseReleased = function () {
        for (const element of Object.values(p.elements)) {
            if (typeof (element) !== 'string') {
                try {
                    element.isReleased();
                } catch (e) {
                    //no releaed function
                }
            }
        }
    }

    p.mouseClicked = function () {
        for (const element of Object.values(p.elements)) {
            if (typeof (element) !== 'string') {
                try {
                    element.isClicked();
                } catch (e) {
                    //no clicked function
                }
            }
        }
    }

    p.mouseDragged = function () {
        for (const element of Object.values(p.elements)) {
            if (typeof (element) !== 'string') {
                try {
                    element.isDragged();
                } catch (e) {
                    //no clicked function
                }
            }
        }
    }

    p.windowResized = function () {
        //p.divResized();
    };

    p.openWebcam = function(width, height) {
      p.capture = p.createCapture(p.VIDEO);
      p.capture.size(width, height);
      p.capture.hide();
      console.log("Webcam opened with resolution:", width, "x", height);
    }
};


var midi = null;
var muted = false;

var outputMidiID = null;

var midiMsgs = {};
var ccCallbacks = {};

/****** load webMIDI API ******/
if (navigator.requestMIDIAccess) {
    navigator.requestMIDIAccess()
        .then(onMIDISuccess)
        .catch(onMIDIFailure);
} else {
    console.log("Web MIDI API is not supported in this browser.");
    // Handle the situation gracefully, e.g., show a notification to the user
}

function onMIDISuccess(midiAccess) {
    console.log("MIDI ready!");
    midi = midiAccess;  // store in the global
    // Tone.Transport.start()
    console.log(getMidiIO())
    // initializeCodeBox();
    //setupClock();

    eval('globalThis.setMidiInput1 = setMidiInput;');
}

function onMIDIFailure(msg) {
    console.error(`Failed to get MIDI access - ${msg}`);
}

function setMidiInput(inputID) {
    //in case only one id is inputted, turn into array
    if (!Array.isArray(inputID)) inputID = [inputID];

    //reset inputs
    midi.inputs.forEach(function (key, val) { key.onmidimessage = null; })

    for (var id of inputID) {
        if (id in midi_input_ids & midi.inputs.get(midi_input_ids[id]) != null) {
            midi.inputs.get(midi_input_ids[id]).onmidimessage = handleMidiInput;
            console.log("MIDI input set to: " + midi_input_names[id]);
        } else { console.warn('Invalid input ID'); }
    }
}

function setMidiOutput(outputID) {
    if (Array.isArray(outputID)) {
        console.warn('Can only handle one MIDI output. Please enter one ID.')
    }
    if (outputID in midi_output_ids & midi.outputs.get(midi_output_ids[outputID]) != null) {
        outputMidiID = midi_output_ids[outputID];
        console.log("MIDI output set to: " + midi_output_names[outputID]);
        
        // Set the MIDI output in MidiHandler
        midiHandlerInstance.setOutput(midi.outputs.get(outputMidiID));
    } else { console.warn('Invalid output ID'); }
}

/****** load webMIDI API ******/
class MidiHandler {
    constructor() {
        this.noteOnHandler = (note, velocity=127, channel=1) => {
            console.log('Default Note On Handler:', note, velocity);
            console.log(`Define your own note on handler like this:\nsetNoteOnHandler(( note, vel, (optional:channel) ) => { <your code here> }) `)
        };
        this.noteOffHandler = (note, velocity=0, channel=1) => {
            console.log('Default Note Off Handler:', note, velocity);
            console.log(`Define your own note off handler like this:\nsetNoteOffHandler(( note, vel, (optional:channel) ) => { <your code here> }) `)
        };
        this.CCHandler = (controller, value, channel=1) => {
            console.log('Default CC Handler:', controller, value);
            console.log(`Define your own CC handler like this:\nsetCCHandler(( cc, value, (optionaL:channel) ) => { <your code here> }) `)
        };

        this.midiOutput = null; // Reference to the active MIDI output
    }

    // Set the MIDI output port
    setOutput(output) {
        this.midiOutput = output;
    }

    // Send Note On message
    sendNoteOn(note, velocity = 127, channel = 1) {
        console.log(note, velocity, channel)
        if (this.midiOutput) {
            const status = 0x90 | (channel - 1); // Note On status byte
            this.midiOutput.send([status, note, velocity]);
        } else {
            console.warn('No MIDI output is set.');
        }
    }

    // Send Note Off message
    sendNoteOff(note, velocity = 0, channel = 1) {
        console.log(note, velocity, channel)
        if (this.midiOutput) {
            const status = 0x80 | (channel - 1); // Note Off status byte
            this.midiOutput.send([status, note, velocity]);
        } else {
            console.warn('No MIDI output is set.');
        }
    }

    // Send Control Change (CC) message
    sendCC(controller, value, channel = 1) {
        if (this.midiOutput) {
            const status = 0xB0 | (channel - 1); // Control Change status byte
            this.midiOutput.send([status, controller, value]);
        } else {
            console.warn('No MIDI output is set.');
        }
    }

    handleNoteOn(note, velocity, channel) {
        this.noteOnHandler(note, velocity, channel);
    }
    handleNoteOff(note, velocity, channel) {
        this.noteOffHandler(note, velocity, channel);
    }
    handleCC(controller, value, channel) {
        this.CCHandler(controller, value, channel);
    }

    setNoteOnHandler(func) {
        this.noteOnHandler = func;
    }
    setNoteOffHandler(func) {
        this.noteOffHandler = func;
    }
    setCCHandler(func) {
        this.CCHandler = func;
    }
}
const midiHandlerInstance = new MidiHandler();

var midi_input_ids = {};
var midi_output_ids = {};
var midi_input_names = {};
var midi_output_names = {};

function getMidiIO() {
    var midiInputs = 'MIDI Inputs:\n';
    var midiOutputs = 'MIDI Outputs:\n';
    var inputID = null;
    var outputID = null;

    var num = 1;
    for (var output of midi.outputs) {
        midiOutputs += num + ': ' + output[1].name + '\n'; //+ '\', ID: \'' + output[1].id + '\'\n';
        outputID = output[1].id;
        midi_output_ids[num] = outputID;
        midi_output_names[num] = output[1].name;
        num += 1;
    }

    num = 1;
    for (var input of midi.inputs) {
        midiInputs += num + ': ' + input[1].name + '\n'; // + '\', ID: \'' + input[1].id + '\'\n';
        inputID = input[1].id;
        midi_input_ids[num] = inputID;
        midi_input_names[num] = input[1].name;
        num += 1;
    }
    return midiInputs + midiOutputs
}

function handleMidiInput(message) {
    //console.log(message)
    let channel = (message.data[0] & 15) + 1
    
    if (message.data[1] != null) {
        let status = message.data[0]
        //console.log('midi', status, message.data[1], message.data[2])
        if (status >= 128 && status <= 159) {
            let note = message.data[1]
            let velocity = message.data[2]
            //note off msg
            if (status >= 128 && status <= 143 || velocity < 1) {
                midiHandlerInstance.handleNoteOff(note, velocity, channel)
            }
            //note on msg
            else {
                midiHandlerInstance.handleNoteOn(note, velocity, channel)
            }
        } else if (status >= 176 && status <= 191) {
            let cc = message.data[1]
            let value = message.data[2]
            midiHandlerInstance.handleCC(cc, value, channel)
        }
    }
}

/*
This class mimics the midi keyboard react component.
It is a hassle to find a way to programmatically convert the component to usable html and js,
so here is an alternative
*/
class MidiKeyboard {
    constructor() {
        this.midiOn = false;
        this.notesOn = new Set();
        this.activeKeys = {};
        this.octave = 4;
        this.keyToNote = {
            90: { "midi": 60, "pitch": "C" },     // Z
            83: { "midi": 61, "pitch": "C#/Db" }, // S
            88: { "midi": 62, "pitch": "D" },     // X
            68: { "midi": 63, "pitch": "D#/Eb" }, // D
            67: { "midi": 64, "pitch": "E" },     // C
            86: { "midi": 65, "pitch": "F" },     // V
            71: { "midi": 66, "pitch": "F#/Gb" }, // G
            66: { "midi": 67, "pitch": "G" },     // B
            72: { "midi": 68, "pitch": "G#/Ab" }, // H
            78: { "midi": 69, "pitch": "A" },     // N
            74: { "midi": 70, "pitch": "A#/Bb" }, // J
            77: { "midi": 71, "pitch": "B" },     // M
            188: { "midi": 72, "pitch": "C" },    // ,
            76: { "midi": 73, "pitch": "C#/Db" }, // L
            190: { "midi": 74, "pitch": "D" },    // .
            186: { "midi": 75, "pitch": "D#/Eb" }, // ;
            191: { "midi": 76, "pitch": "E" },    // /

            // second octave
            81: { "midi": 72, "pitch": "C" },     // Q
            50: { "midi": 73, "pitch": "C#/Db" }, // 2
            87: { "midi": 74, "pitch": "D" },     // W
            51: { "midi": 75, "pitch": "D#/Eb" }, // 3
            69: { "midi": 76, "pitch": "E" },     // E
            82: { "midi": 77, "pitch": "F" },     // R
            53: { "midi": 78, "pitch": "F#/Gb" }, // 5
            84: { "midi": 79, "pitch": "G" },     // T
            54: { "midi": 80, "pitch": "G#/Ab" }, // 6
            89: { "midi": 81, "pitch": "A" },     // Y
            55: { "midi": 82, "pitch": "A#/Bb" }, // 7
            85: { "midi": 83, "pitch": "B" },     // U
            73: { "midi": 84, "pitch": "C" },     // I
            57: { "midi": 85, "pitch": "C#/Db" }, // 9
            79: { "midi": 86, "pitch": "D" },     // O
            48: { "midi": 87, "pitch": "D#/Eb" }, // 0
            80: { "midi": 88, "pitch": "E" }      // P
        };

        this.init();
    }

    init() {
        // Add event listeners
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('keyup', this.handleKeyUp.bind(this));

        // Get DOM elements
        // WARNING: These are assumed to be defined
        this.keyboardButton = document.getElementById('keyboard-button');
        this.keyboardIcon = document.getElementById('keyboard-icon');
        this.notesDisplay = document.getElementById('notes-display');

        // Add click handler
        this.keyboardButton.addEventListener('click', this.toggleMidi.bind(this));
    }

    handleKeyDown(event) {
        if (this.midiOn) {
            const keyCode = event.keyCode;
            if (!this.activeKeys[keyCode]) {
                this.activeKeys[keyCode] = true;
                try {
                    let note = this.keyToNote[keyCode];
                    let midiNote = note["midi"] + (this.octave - 4) * 12;
                    if (midiNote <= 127) {
                        this.notesOn.add(midiNote);
                        this.updateNotesDisplay();
                        if (window.midiHandlerInstance) {
                            window.midiHandlerInstance.handleNoteOn(midiNote, 100);
                        }
                    }
                } catch (error) {
                    if (keyCode === 37) {
                        this.decreaseOctave();
                    } else if (keyCode === 39) {
                        this.increaseOctave();
                    }
                }
            }
        }
    }

    handleKeyUp(event) {
        if (this.midiOn) {
            const keyCode = event.keyCode;
            this.activeKeys[keyCode] = false;
            try {
                let note = this.keyToNote[keyCode];
                let midiNote = note["midi"] + (this.octave - 4) * 12;
                if (midiNote <= 127) {
                    this.notesOn.delete(midiNote);
                    this.updateNotesDisplay();
                    if (window.midiHandlerInstance) {
                        window.midiHandlerInstance.handleNoteOff(midiNote, 0);
                    }
                }
            } catch (error) {
                // Ignore errors for non-mapped keys
            }
        }
    }

    toggleMidi() {
        this.midiOn = !this.midiOn;
        this.keyboardIcon.className = `icon ${this.midiOn ? 'active' : 'inactive'}`;
    }

    increaseOctave() {
        if (this.octave < 7) {
            this.octave++;
        }
    }

    decreaseOctave() {
        if (this.octave > 1) {
            this.octave--;
        }
    }

    updateNotesDisplay() {
        this.notesDisplay.innerHTML = Array.from(this.notesOn)
            .map(note => `<div class="note-pill">${note}</div>`)
            .join('');
    }
}

// Initialize the keyboard when the page loads
document.addEventListener('DOMContentLoaded', () => {
    window.midiKeyboard = new MidiKeyboard();
});


/*
DelayOp

Delays
* input->hpf->feedbackDelay->drive->waveShaper->lpf->panner->output
* 
* 

methods:


properties:

- 
*/

;
;

class DelayOp{
  constructor(){
    //signal
    this.input = new Tone.Multiply(1)
    this.hpf = new Tone.OnePoleFilter({type:'highpass',frequency:100})
    this.delay = new Tone.FeedbackDelay()
    this.drive = new Tone.Multiply(0.8)
    this. waveShaper = new Tone.WaveShaper((x)=>{
      return Math.tanh(x*16) *.9
    })
    this.lpf = new Tone.Filter({frequency:2000})
    this.panner = new Tone.Panner(0)
    this.output = new Tone.Multiply(1)
    //mod
    this.delayTime = new Tone.Signal(.1)
    //connections
    this.input.connect(this.hpf)
    this.hpf.connect(this.delay)
    this.delay.connect(this.drive)
    this.drive.connect(this.waveShaper)
    this.waveShaper.connect(this.lpf)
    this.lpf.connect(this.panner)
    this.panner.connect(this.output)
    //mod connections
    this.delayTime.connect(this.delay.delayTime)
  }
  connect(destination) {
    if (destination.input) {
      this.output.connect(destination.input);
    } else {
      this.output.connect(destination);
    }
  }
}

window.basicLayout = {
  "basicLayout": {
    "vco": {
      "color": [150, 0, 0],
      "boundingBox": { "x": 10, "y": 20, "width": 30, "height": 50 },
      "offsets": { "x": 12, "y": 30 },
      "groupA": ["type"],
      "controlTypeA": "radioButton",
      "controlTypeB": "knob",
      "sizeA": 0.8,
      "sizeB": 0.75,
      "theme": "dark"
    },
    "vcf": {
      "color": [100, 0, 150],
      "boundingBox": { "x": 30, "y": 20, "width": 40, "height": 50 },
      "offsets": { "x": 10, "y": 30 },
      "groupA": ["cutoff"],
      "controlTypeA": "knob",
      "controlTypeB": "knob",
      "sizeA": 0.8,
      "sizeB": 0.6
    },
    "vca": {
      "color": [100, 50, 100],
      "boundingBox": { "x": 70, "y": 20, "width": 30, "height": 50 },
      "offsets": { "x": 12, "y": 0 },
      "groupA": ["level"],
      "controlTypeA": "knob",
      "controlTypeB": "knob",
      "sizeA": 0.8,
      "sizeB": 0.6
    },
    "env": {
      "color": [20, 100, 100],
      "boundingBox": { "x": 10, "y": 60, "width": 50, "height": 50 },
      "offsets": { "x": 8, "y": 300 },
      "groupA": [],
      "controlTypeA": "knob",
      "controlTypeB": "fader",
      "sizeA": 0.8,
      "sizeB": 1.2
    },
    "lfo": {
      "color": [20, 0, 100],
      "boundingBox": { "x": 50, "y": 70, "width": 50, "height": 50 },
      "offsets": { "x": 12, "y": 30 },
      "groupA": ["rate"],
      "controlTypeA": "knob",
      "controlTypeB": "knob",
      "sizeA": 0.8,
      "sizeB": 0.6
    }
  }
};;

/*
*/

;

class Parameter {
  constructor(options, gui = null, layout = basicLayout) {

    this.name = options.name || 'param'
    this.min = options.min || 0;
    this.max = options.max || 1;
    this.curve = options.curve || 1; // Curve for value scaling
    this.rawValue = this.unScaleValue(options.value || 0.5, 0, 1, this.min, this.max, this.curve); // Normalized to real
    this.normalizedValue = 0
    this.group = options.group || 'default'; // Group assignment
    this._value = Array.isArray(options.value) ? options.value
        : options.value !== undefined ? options.value
        : this.scaleValue(0.5, 0, 1, this.min, this.max, this.curve);
    this.callback = options.callback || function () {};
    this.control = null; // GUI control
    this.gui = gui; // GUI framework
    this.layout = layout || basicLayout; // Layout info
    this.type = options.type || 'vcf'
    this.radioOptions = options.radioOptions || null; // Store available options for radioBox
    this.guiElements = []; // Store references to GUI elements for array values
    this.labels = options.labels || null;
    this.set(this._value)
  };

  get(index = null) {
    if (Array.isArray(this._value)) {
        return index !== null ? this._value[index] : this._value;
    }
    return this._value;
  }
  set(newValue, index = null, calledByGui=false) {
    //console.log('set', this.name, newValue, this._value)
    if (Array.isArray(this._value)) {
        if (Array.isArray(newValue)) {
            // Set entire array
            this._value = [...newValue];
            newValue.forEach((val, i) => this.callback(val, i));
        } else if (index !== null) {
            // Set specific index
            this._value[index] = newValue;
            this.callback(newValue, index);
        } else {
            // Fill array with single value
            this._value.fill(newValue);
            this._value.forEach((val, i) => this.callback(val, i));
        }
    } else {
        // Scalar value
        this._value = newValue;
        this.callback(newValue, null);
    }

    // Update GUI if attached
    // Update GUI elements
    if(calledByGui==false){
      if (Array.isArray(this._value)) {
          this.guiElements.forEach((gui, i) => gui.forceSet(this._value[i]));
      } else if (this.guiElements.length > 0) {
          this.guiElements[0].forceSet(this._value);
      }
    }
  }
  

  // Attach a GUI control to this parameter
  attachControl(control) {
    this.control = control;
    control.onChange = (newValue) => {
      this.value = newValue; // Update the parameter when the control changes
    };
  }

  createGui() {
        const { x, y, width, height } = this.layout;
        const groupColor = this.getGroupColor(this.group);

        this.control = this.gui.Knob({
            label: this.name,
            min: this.min,
            max: this.max,
            size: width,
            x:x,
            y:y,
            accentColor: groupColor,
            callback: (value) => this.set(value),
        });

        // Sync initial value
        this.control.setValue(this.get());
    }

    getGroupColor(group) {
        const colors = {
            vco: [200, 0, 0],
            vcf: [0, 200, 0],
            env: [0, 0, 200],
            default: [100, 100, 100],
        };
        return colors[group] || colors.default;
    }

  /**
   * Set the parameter value in real-world units (e.g., hertz or amplitude).
   * @param {number} realValue - The real-world value of the parameter.
   */
  setRealValue(realValue) {
    this.value = realValue;
    this.rawValue = this.unScaleValue(realValue, this.min, this.max, 0, 1, this.curve);
  }

  /**
   * Get the parameter value in real-world units (e.g., hertz or amplitude).
   * @returns {number} - The real-world value of the parameter.
   */
  getRealValue() {
    return this.value;
  }

  /**
   * Set the parameter value in normalized units (0-1).
   * @param {number} normalizedValue - The normalized value (0-1).
   */
  setNormalizedValue(normalizedValue) {
    this.rawValue = normalizedValue;
    this.value = this.scaleValue(normalizedValue, 0, 1, this.min, this.max, this.curve);
  }

  /**
   * Get the parameter value in normalized units (0-1).
   * @returns {number} - The normalized value (0-1).
   */
  getNormalizedValue() {
    return this.rawValue;
  }

  /**
   * Scale a normalized value (0-1) to a real-world value based on min, max, and curve.
   * @param {number} value - The normalized value (0-1).
   * @param {number} min - The minimum real-world value.
   * @param {number} max - The maximum real-world value.
   * @param {number} curve - The curve factor to adjust scaling.
   * @returns {number} - The scaled real-world value.
   */
  scaleValue(value, min, max, realMin, realMax, curve) {
    return realMin + (Math.pow(value, curve) * (realMax - realMin));
  }

  /**
   * Convert a real-world value back into a normalized value (0-1) based on min, max, and curve.
   * @param {number} value - The real-world value.
   * @param {number} min - The minimum real-world value.
   * @param {number} max - The maximum real-world value.
   * @param {number} curve - The curve factor to adjust scaling.
   * @returns {number} - The normalized value (0-1).
   */
  unScaleValue(value, realMin, realMax, min, max, curve) {
    return Math.pow((value - realMin) / (realMax - realMin), 1 / curve);
  }
}


/**
 * AnalogDelay.js
 * 
 * Simple approximation of an analog delay
 * 
 * Signal path:
 * input -> hpf -> gain -> waveShaper -> lpf -> delay -> wet -> output
 *                                         <- feedback <-
 * input -> dry -> output
 * 
 * @class
 */
;
;
;

// import './userInterface.css';


class AnalogDelay {
  /**
   * Creates an instance of AnalogDelay.
   * @constructor
   * @param {number} [initialTime=0.1] - Initial delay time in seconds.
   * @param {number} [initialFB=0] - Initial feedback amount.
   */
  constructor(initialTime = 1, initialFB = 0) {
    this.input = new Tone.Multiply(1);
    this.highpass = new Tone.Filter({ type: 'highpass', frequency: 20, Q: 0 });
    this.ws_input = new Tone.Multiply(0.125);
    this.waveShaper = new Tone.WaveShaper((x) => { return Math.tanh(x) });
    this.vcf = new Tone.Filter({ type: 'lowpass', frequency: 5000, Q: 0, slope: '-12' });
    this.vcfR = new Tone.Filter({ type: 'lowpass', frequency: 5000, Q: 0, slope: '-12' });
    this.delay = new Tone.Delay(initialTime, initialTime);
    this.delayR = new Tone.Delay(initialTime, initialTime);
    this._delayRatio = 0.75
    this.feedbackMult = new Tone.Multiply(initialFB);
    this.feedbackMultR = new Tone.Multiply(initialFB);
    this.merge = new Tone.Merge(2)
    this.wetSig = new Tone.Multiply(1);
    this.drySig = new Tone.Multiply(0);
    this.output = new Tone.Multiply(1);

    // Connecting signal path
    this.input.connect(this.drySig);
    this.input.connect(this.highpass);
    this.highpass.connect(this.ws_input);
    this.ws_input.connect(this.waveShaper);
    this.waveShaper.connect(this.vcf);
    this.waveShaper.connect(this.vcfR);
    this.vcf.connect(this.delay);
    this.vcfR.connect(this.delayR);
    this.delay.connect(this.feedbackMult);
    this.delayR.connect(this.feedbackMultR);
    this.feedbackMult.connect(this.vcf);
    this.feedbackMultR.connect(this.vcfR);
    this.delay.connect(this.merge,0,0);
    this.delayR.connect(this.merge,0,1);
    this.merge.connect(this.wetSig);
    this.wetSig.connect(this.output);
    this.drySig.connect(this.output);

    this.lfo = new Tone.Oscillator(2).start()
    this.lfoDepth = new Tone.Multiply()
    this.lfo.connect(this.lfoDepth)
    this.lfoDepth.connect(this.delay.delayTime)
    this.lfoDepth.connect(this.delayR.delayTime)

    let paramDefinitions = [
      {name:'time',min:0.01,max:1,curve:2,callback:this.setDelayTime},
      {name:'feedback',min:0.0,max:1.2,curve:.7,callback:this.setFeedback},
      {name:'damping',min:100,max:10000,curve:2,callback:this.setFilterFrequency},
      {name:'hpf',min:10,max:2000,curve:2,callback:value=>this.highpass.frequency.value = value},
      {name:'dry',value:0,min:0.0,max:1.2,curve:2,callback:value=>this.drySig.factor.value = value},
      {name:'wet',min:0.0,max:1.2,curve:2,callback:value=>this.wetSig.factor.value = value},
      {name:'gain',min:0.0,max:1,curve:0.2,callback:value=>this.ws_input.factor.value = value},
      {name:'amp',min:0.0,max:1.2,curve:2,callback:value=>this.output.factor.value = value},
      {name:'delayRatio',value:0,min:0.5,max:1,curve:1,callback:value=>{
        this._delayRatio = value
        this.setDelayTime(this.delay.delayTime.value)}},
    ]


    this.param = this.generateParameters(paramDefinitions)
    this.createAccessors(this, this.param);

//     // Create a label for the slider
//     const div = document.getElementById('canvases');

//     // Create a container div to hold both the label and the slider
// const container = document.createElement('div');
// container.style.display = 'flex'; // Set default display to flex
// container.style.flexDirection = 'column'; // Set default direction to column (vertical)

// // To make it horizontal
// container.className = 'vertical-container';

// const label = document.createElement('label');
// label.innerText = 'Delay Time'; // Set the text for the label
// label.htmlFor = 'mySlider'; // Associate the label with the slider

     
//   const slider = document.createElement('input');
//   slider.type = 'range';
//   slider.min = '0';
//   slider.max = '1';
//   slider.value = '50';
//   slider.step = '0.01';
//   slider.id = 'mySlider';
//   slider.className = 'sliderStyle';

//   // Add an event listener for input changes
//   slider.addEventListener('input', function(event) {
//     console.log('Slider value changed to:', event.target.value);
//     this.time = event.target.value
//   });

//   // Append the slider to the div
//   container.appendChild(label);
//   container.appendChild(slider);
//   div.appendChild(container)
  }



  generateParameters(paramDefinitions) {
        const params = {};
        paramDefinitions.forEach((def) => {
            const param = new Parameter(def);
            params[def.name] = param;
        });
        return params;
    }

    createAccessors(parent, params) {
    Object.keys(params).forEach((key) => {
        const param = params[key];

        // Ensure the Parameter object has a `set` method
        if (typeof param.set !== 'function') {
            throw new Error(`Parameter '${key}' does not have a set method`);
        }

        // Proxy to handle array-like access
        const proxyHandler = {
            get(target, prop) {
                if (typeof prop === 'string' && !isNaN(prop)) {
                    // Access individual array element
                    return target.get(parseInt(prop));
                }
                return target.get();
            },
            set(target, prop, value) {
                console.log(target, prop, value)
                if (typeof prop === 'string' && !isNaN(prop)) {
                    // Set individual array element
                    target.set(value, parseInt(prop));
                    return true;
                }
                // Set the entire array or scalar value
                target.set(value);
                return true;
            }
        };

        // Define the accessor property on the parent
        Object.defineProperty(parent, key, {
            get: () => new Proxy(param, proxyHandler),
            set: (newValue) => param.set(newValue),
        });
    });
}//createAccessors

    setParameter(name, value, time = null) {
        const param = this.param[name];
        if (!param) throw new Error(`Parameter '${name}' does not exist.`);
        
        if (time) {
            // Handle sequenced parameter updates
            param.callback(value, time);
        } else {
            // Handle immediate parameter updates
            param.callback(value);
        }

        // Update associated GUI elements
        if (param.guiElement) {
            param.guiElement.setValue(value);
        }
    }

    get() {
        let output = 'Parameters:\n';
        for (let key in this.param) {
            const param = this.param[key];
            output += `${param.name}: ${param._value}\n`;
        }
        console.log(output);
    }

  setDelayTime = (value)=>{
    this.delay.delayTime.value = value
    this.delayR.delayTime.value = value*this._delayRatio
  }
  setFeedback = (value)=>{
    this.feedbackMult.factor.value = value; 
    this.feedbackMultR.factor.value = value
  }
  setFilterFrequency = (value)=>{
    this.vcf.frequency.value = value; 
    this.vcf.frequency.value = value*0.9;
  }

  /**
   * Connect the output to a destination.
   * @param {Tone.Signal | AudioNode} destination - The destination to connect to.
   */
  connect(destination) {
    if (destination.input) {
      this.output.connect(destination.input);
    } else {
      this.output.connect(destination);
    }
  }

  /**
   * Disconnect the output from a destination.
   * @param {Tone.Signal | AudioNode} destination - The destination to disconnect from.
   */
  disconnect(destination) {
    if (destination.input) {
      this.output.disconnect(destination.input);
    } else {
      this.output.disconnect(destination);
    }
  }

  /**
     * Save a preset by name
     * @param {string} name - Name of the preset to save
     * @returns {void}
     * @example synth.savePreset('default')
     */
    savePreset (name) {
        const _preset = {};
        for (let element of Object.values(this.param)) {
            _preset[element.name] = element._value;
        }
        console.log(this.presets)
        // Update the presetsData in memory
        //console.log(this.presets);
        if (!this.presets[name]) {
            this.presets[name] = {};
        }
        this.presets[name] = _preset;

        console.log(`Preset saved under ${this.name}/${name}`);
    };

    /**
     * Download the presets data as a JSON file
     * @returns {void}
     * @example synth.downloadPresets()
     */
    downloadPresets ()  {
        this.presetsData = this.presets;
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.presetsData, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", `${this.name}Presets.json`);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    };

    /**
     * Load a preset by name
     * @param {string} name - Name of the preset to load
     * @returns {void}
     * @example synth.loadPreset('default')
     */
    loadPreset(name) {
        this.curPreset = name;
        const presetData = this.presets[this.curPreset];

        if (presetData) {
            console.log("Loading preset ", this.curPreset);
            for (let name in presetData) {
                try {
                    for (let element of Object.values(this.param)) {
                        this.param[name].set(presetData[name])
                    }
                } catch (e) {
                    console.log(e);
                }
            }
        } else {
            console.log("No preset of name ", name);
        }
    }

    logPreset() {
        const presetData = this.presets[this.curPreset];

        if (presetData) {

          let output = 'Parameters:\n';
          for (let key in presetData) {
              const param = presetData[key];
              if (Array.isArray(param)) {
                  const formattedArray = param.map((value) => {
                      if (typeof value === "number") {
                          return Number(value.toFixed(2)); // Limit to 2 decimals
                      }
                      return value; // Keep non-numbers unchanged
                  });

                  output += `${key}: [${formattedArray.join(", ")}]\n`; // Add the array to output
              }
              else if(typeof param === 'number') output += `${key}: ${param.toFixed(2)}\n`;
              else output += `${key}: ${param}\n`;
          }
          console.log(output);
        }
        /*

        if (presetData) {
            console.log("Preset " + this.curPreset);
            for (let id in presetData) {
                try {
                    for (let element of Object.values(this.gui.elements)) {
                        if (element.id === id) {
                            if (element.type !== 'momentary') console.log(id, presetData[id]);
                        }
                    }
                } catch (e) {
                    console.log(e);
                }
            }
        } 
  */
        else {
            console.log("No preset of name ", this.curPreset);
        }
    }

    /**
     * Console log all available presets
     * @returns {void}
     * @example synth.listPresets()
     */
    listPresets() {
        console.log("Synth presets", this.presets);
    }
}


/*
Caverns

Cascaded Delays
* input-> all DelayOps -> output
* delays are cascaded to all following delays
* DelayOp: input->hpf->feedbackDelay->drive->waveShaper->lpf->output

methods:
- connect
- setDelayTime
- setFeedback: sets internal fb & feedforward to following delays
- setLowpass
- setHighpass
- setDrive: input into soft clipper in delayOp
- setPanning: uses sine wave by default

properties:
- 
*/
;
;
;

class Caverns{
  constructor(color = [200,200,200]){
      this.input = new Tone.Multiply(1)
      this.delay = []
      for(let i=0;i<8;i++) this.delay.push(new DelayOp())
      this.cross = []
      for(let i=0;i<8;i++) this.cross.push(new Tone.Multiply())
      this.output = new Tone.Multiply(0.125)
      //connections
      for(let i=0;i<8;i++) {
        this.input.connect(this.delay[i].input)
        this.delay[i].connect(this.output)
        for(let j=i+1;j<8;j++) this.delay[i].connect(this.cross[j])
        //this.delay[i].connect(this.cross[i])
        this.cross[i].connect(this.delay[i].input)
      }
  }
  connect(destination) {
    if (destination.input) {
      this.output.connect(destination.input);
    } else {
      this.output.connect(destination);
    }
  }
  setDelayTime = function(val){
    for(let i=0;i<8;i++) this.delay[i].delayTime.value = val*(1.25**i)
  }
  setFeedback = function(val){
    for(let i=0;i<8;i++) {
      this.delay[i].delay.feedback.value = val
      //this.cross[i].factor.value = val
    }
  }
  setCross = function(val){
    for(let i=0;i<8;i++) {
      //this.delay[i].delay.feedback.value = val
      this.cross[i].factor.value = val
    }
  }
  setLowpass = function(val){
    for(let i=0;i<8;i++) {
      this.delay[i].lpf.frequency.value = val
    }
  }
  setHighpass = function(val){
    for(let i=0;i<8;i++) {
      this.delay[i].hpf.frequency = val
    }
  }
  setDrive = function(val){
    for(let i=0;i<8;i++) {
      this.delay[i].drive.factor.value = val
    }
  }
  setPanning = function(val){
    for(let i=0;i<8;i++) {
      this.delay[i].panner.pan.rampTo( Math.sin(i*val),.1)
    }
  }
}



/*
Chorus

Delays
* input->hpf->lpf->wavshapeGain->waveshaper->
    3 chorus stages->output
*   delayTime -> lfoDepthScalar -> lfoDepth.factor
* 

methods:


properties:

- 
*/

;
;

class ModDelay{
    constructor(){
        this.input = new Tone.Multiply(1)
        this.lfoRate = new Tone.Signal(.5)
        this.delay = new Tone.Delay({delayTime:.0})
        this.delayTime= new Tone.Signal(.1)
        this.delayTimeAdd = new Tone.Add()
        this.feedback = new Tone.Multiply(0)
        this.lfo = new Tone.Oscillator().start()
        this.lfoDepthScalar = new Tone.Multiply(.01)
        this.lfoDepth = new Tone.Multiply(.1)
        this.panner = new Tone.Panner(0)
        this.output = new Tone.Multiply(1)
        //
        this.input.connect(this.delay)
        this.delay.connect(this.feedback)
        this.feedback.connect(this.delay)
        this.delay.connect(this.panner)
        this.panner.connect(this.output)
        //
        this.delayTime.connect(this.delayTimeAdd)
        this.delayTimeAdd.connect(this.delay.delayTime)
        this.lfoRate.connect(this.lfo.frequency)
        //this.lfoRate.connect(this.lfoDepthScalar.factor)
        this.lfo.connect(this.lfoDepthScalar)
        this.lfoDepthScalar.connect(this.lfoDepth)
        this.lfoDepth.connect(this.delayTimeAdd.addend)
        this.setDelayTime(0.01)
    }
    setDelayTime(val){
        this.delayTime.value = val
        this.lfoDepthScalar.factor.value = val
    }
}

// class Chorus{
//     constructor(){
//         //signal
//         this.input = new Tone.Multiply(1)
//         this.hpf = new Tone.OnePoleFilter({type:'highpass',frequency:100})
//         this.lpf = new Tone.Filter({frequency:2000})
//         this.frequency = new Tone.Signal(.5)
//         this.stage = []
//         this.rateScale = []
//         for(let i=0;i<3;i++){
//             this.stage.push( new ModDelay())
//             this.rateScale.push( new Tone.Multiply(1+i))
//         }
//         this.drive = new Tone.Multiply(0.8)
//         this. waveShaper = new Tone.WaveShaper((x)=>{
//           return Math.tanh(x*16) *.9
//         })
//         this.output = new Tone.Multiply(1)
//         //mod
//         this.delayTime = new Tone.Signal(.1)
//         this.rate = new Tone.Signal()
//         this.depth = new Tone.Signal()
//         //connections
//         this.input.connect(this.hpf)
//         this.hpf.connect(this.lpf)
//         this.lpf.connect(this.drive)
//         this.drive.connect(this.waveShaper)
//         for(let i=0;i<3;i++){
//             this.waveShaper.connect(this.stage[i].input)
//             this.stage[i].output.connect(this.output)
//             this.rate.connect(this.rateScale[i])
//             this.rateScale.connect(this.stage[i].rate)
//             // this.st
//         }
//     }
//     connect(destination) {
//         if (destination.input) {
//             this.output.connect(destination.input);
//         } else {
//             this.output.connect(destination);
//         }
//     }
// }

// Seq.js
//current sequencer module jan 2025

;
;

class Seq {
     constructor(synth, arr = [0], subdivision = '8n', phraseLength = 'infinite', num = 0, callback = null) {
        this.synth = synth; // Reference to the synthesizer
        this.vals = Array.isArray(arr) ? arr : parsePitchStringSequence(arr);
        this._subdivision = subdivision; // Local alias
        this._octave = 0;                // Local alias
        this._sustain = 0.1;             // Local alias
        this._roll = 0.02;               // Local alias
        this._velocity = 100;            // Local alias
        this._transform = (x) => x;      // Local alias
        this.phraseLength = phraseLength;
        this.enable = 1;
        this.min = 24;
        this.max = 127;
        this.loopInstance = null;
        this.num = num;
        this.callback = callback;
        this.parent = null;
        this.index = 0;

        this.createLoop();
    }

    get subdivision() { return this._subdivision;}
    set subdivision(val) {
        this._subdivision = val;
        this.setSubdivision(val); // Update loop timing if needed
    }
    get octave() {return this._octave; }
    set octave(val) {this._octave = val; }
    get sustain() {return this._sustain;}
    set sustain(val) {  this._sustain = val; }
    get roll() {  return this._roll; }
    set roll(val) {    this._roll = val; }
     get velocity() { return this._velocity; }
    set velocity(val) {  this._velocity = val; }
     get transform() {  return this._transform;}
    set transform(val) {
        if (typeof val !== 'function') {
            throw new TypeError('Transform must be a function');
        }
        this._transform = val;
    }


    sequence(arr, subdivision = '8n', phraseLength = 'infinite') {
        this.vals = Array.isArray(arr) ? arr : parsePitchStringSequence(arr);
        this.phraseLength = phraseLength;
        this.subdivision = subdivision;

        if (this.loopInstance) {
            this.loopInstance.dispose();
        }

        this.createLoop();
    }

    drumSequence(arr, subdivision = '8n', phraseLength = 'infinite') {
        this.vals = Array.isArray(arr) ? arr : parseStringSequence(arr);
        this.phraseLength = phraseLength;
        this.subdivision = subdivision;

        if (this.loopInstance) {
            this.loopInstance.dispose();
        }
        this.createLoop();
    }

    createLoop() {
        // Create a Tone.Loop
        this.loopInstance = new Tone.Loop(time => {
            //console.log('old loop')
            if (this.enable === 0) return;

            this.index = Math.floor(Theory.ticks / Tone.Time(this.subdivision).toTicks());

            let curBeat = this.vals[this.index % this.vals.length];
            if(curBeat == undefined) curBeat = '.'

            //console.log("before transform", '.'+curBeat+'.')
            curBeat = this.perform_transform(curBeat);
            //console.log("after transform", '.'+curBeat+'.')

            curBeat = this.checkForRandomElement(curBeat);

            const event = parsePitchStringBeat(curBeat, time);

            // Roll chords
            const event_timings = event.map(subarray => subarray[1]);
            let roll = this.getNoteParam(this.roll, this.index);
            for (let i = 1; i < event.length; i++) {
                if (event_timings[i] === event_timings[i - 1]) event[i][1] = event[i - 1][1] + roll;
            }
            for (const val of event) this.callback(val, time, this.index, this.num);

            if (this.phraseLength === 'infinite') return;
            this.phraseLength -= 1;
            if (this.phraseLength < 1) this.stop();
        }, this.subdivision).start(0);

        this.setSubdivision(this.subdivision);

        Tone.Transport.start();
    }

    checkForRandomElement(curBeat) {
        if (typeof curBeat === 'number') {
            return curBeat;
        }

        if (typeof curBeat === 'string' && curBeat.includes('?')) {
            let validElements = [];

            this.vals.forEach(item => {
                if (typeof item === 'string') {
                    const letterPattern = /[#b]?[A-Ga-g]/g;
                    const symbolPattern = /[oOxX\*\^]/g;
                    const numberPattern = /(-?\d+)/g;
                    const symbolNumberPattern = /([oOxX\*\^])\s*(1|2|3)/g;

                    let letterMatches = item.match(letterPattern);
                    if (letterMatches) {
                        validElements.push(...letterMatches);
                    }

                    let symbolMatches = item.match(symbolPattern);
                    if (symbolMatches) {
                        validElements.push(...symbolMatches);

                        let symbolNumberMatches = item.match(symbolNumberPattern);
                        if (symbolNumberMatches) {
                            symbolNumberMatches.forEach(match => {
                                const [symbol, number] = match.split(/\s*/);
                                validElements.push(number);
                            });
                        }
                    }

                    let otherNumbers = item.match(numberPattern);
                    if (otherNumbers) {
                        validElements.push(...otherNumbers);
                    }
                }
            });

            function getRandomElement() {
                return validElements[Math.floor(Math.random() * validElements.length)];
            }

            curBeat = curBeat.replace(/\?/g, () => getRandomElement());
        }

        return curBeat;
    }

    getNoteParam(val, index) {
        if (Array.isArray(val)) return val[index % val.length];
        else return val;
    }

    setNoteParam(val, arr) {
        for (let i = 0; i < arr.length; i++) arr[i] = val;
        return arr;
    }

    start() {
        this.enable = 1;
        if (this.loopInstance) this.loopInstance.start();
    }

    stop() {
        this.enable = 0;
        if (this.loopInstance) this.loopInstance.stop();
    }

    expr(func, len = 32, subdivision = '16n') {
        const arr = Array.from({ length: len }, (_, i) => {
            return func(i);
        });

        this.vals = arr.map(element => {
            return typeof element === 'string' ? element : Array.isArray(element) ? JSON.stringify(element) : element;
        });

        this.phraseLength = 'infinite';
        this.sequence(this.vals, subdivision);
    }

    setSubdivision(sub = '8n') {
        this._subdivision = sub;
        if (this.loopInstance) {
            this.loopInstance.interval = Tone.Time(this.subdivision);
        }
    }

    perform_transform(curBeat){
        if(curBeat === '[]') return '.'
        if(!isNaN(Number(curBeat))){ //make sure it's a number
            // console.log("returning", String(this.transform(Number(curBeat))))
            return String((this.transform(Number(curBeat))));
        }else if(curBeat[0]==='['){ //it's an array
            if(curBeat.length <3) return '.'
            for(let i = 0; i < curBeat.length; i++){
                if(!isNaN(Number(curBeat[i])) && curBeat[i].trim() !== ""){
                    let curNum = curBeat[i];
                    let lastInd = i;
                    while(true){ //check for multiple digit numbers
                        if(lastInd<curBeat.length-1){
                            if(!isNaN(Number(curBeat[lastInd+1])) && curBeat[lastInd+1].trim() !== ""){
                                // console.log("It says this is a number", curBeat[lastInd+1]);
                                curNum += curBeat[lastInd+1]
                                lastInd += 1;
                            }else{
                                break;
                            }
                        }else{
                            break;
                        }
                    }
                    // console.log("after while", curNum);
                    // console.log("returning", curBeat.slice(0, i) + String(this.transform(Number(curNum))) + curBeat.slice(lastInd + 1))
                    let transformedNum = String((this.transform(Number(curNum))));
                    curBeat = curBeat.slice(0, i) + transformedNum + curBeat.slice(lastInd + 1);
                    lastInd += transformedNum.length - curNum.length;
                    i = lastInd;
                }
            }
            return curBeat;
        }else{
            // console.log("returning", curBeat);
            return curBeat;
        }
    }

    setTransform(func){
        this.transform = func;
    }
}


// Seq.js

;
;

class TuringMachine {
  constructor(){
    this.seq = new Array(32).fill(0)
    this.bigKnob = 0
    this.index = 0
    this.len = 16
    this.init()
    this.val = 0
    this.pitchScalar = 1
    this.pitchVal = 0
    this.scale = [0,2,4,5,7,9,11,12]
  }
  init(){
    for(let i=0;i<32;i++)this.seq[i] = Math.random()>0.5
  }
  get(){
    if(Math.random()> Math.abs(this.bigKnob)) this.seq[this.index%this.len] = Math.random()>0.5
    this.val = this.seq[this.index%this.len]
    this.index++
   return this.val
  }
  set knob(val){
    this.len = this.bigKnob>0?16:8
    this.bigKnob = val>1?1: val<-1?-1: val
    this.len = this.bigKnob>0?32:16
  }
  pitch(){
    this.pitchVal = 0
    for(let i=0;i<8;i++)this.pitchVal+=(this.seq[(this.index+i)%8]*i)
    this.pitchVal = this.pitchVal*this.pitchScalar/32
    console.log(this.pitchVal)
    return this.scale[Math.floor(this.pitchVal)]
  }
  getStep(num){
    if(Array.isArray(num)) num = num.reduce((a,b)=>a+b)
    return this.seq[(this.index+num)%this.len]
  }
}


;

class ArrayVisualizer {
    constructor(parent, array, _target = 'Canvas', ratio = 4 / 10) {
        this.parent = parent
        this._array = array;
        this._target = document.getElementById(_target);
        this._ratio = ratio;
        this._type = 'horizontal'; // Default type
        this._color =  [
            '#FF5733',  // Base orange
            '#33A1FF',  // Light blue (complementary)
            '#FF33B1',  // Magenta (opposite on color wheel)
            '#33FF57',  // Bright green (vibrant contrast)
            '#5733FF',  // Purple (contrasting tone)
            '#FFBD33',  // Warm yellow (vibrant and complementary)
            '#33FFBD',  // Mint green (cool contrast)
            '#FF3380'   // Pink (near complementary)
        ];

        this._backgroundColor = '#3C3D37'
        this._activeColor = '#ECDFCC'; // Default color
        this._rows = 1; // Default to single row
        this._columns = array.length; // Default to length of array
        this._width = this._target.offsetWidth;
        this._height = this._width * this._ratio;
        this.elementWidth = this._width / this._columns;
        this.elementHeight = this._height / this._rows;
        //need to keep track of min and max acroos multiple frames
        //in order to catch when we draw multiply seqs
        this._min = 0
        this._max = 1
        this._minActive = 0
        this._maxActive = 1
        this._seqNum = 0
        this._displayLength = 8 //x dimension of drawing
        this._activeLength = 8 //length of longest array of last frame 
        
        this._subDivision = '16n'
        this._enabled = false
        this._svg = null
        this.index = 0

        // this.loop = new Tone.Loop(time=>{
        //     this.index = Math.floor(Tone.Transport.ticks / Tone.Time(this._subDivision).toTicks());
        //     this.visualize(this.index)
        // }, '16n')
    }

    createSVG() {
        // const existingSVG = this._target.querySelector('svg.array-visualizer-svg');
        // if (existingSVG) {
        //     this._target.removeChild(existingSVG);
        // }
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute('width', this._width);
        svg.setAttribute('height', this._height);
        svg.setAttribute('class', 'array-visualizer-svg');

        return svg;
    }

    clearSVG() {
        if (this._svg) {
            while (this._svg.firstChild) {
                this._svg.removeChild(this._svg.firstChild);
            }
        }

        const background = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
        background.setAttribute('x', 0);
        background.setAttribute('y', 0);
        background.setAttribute('width', this._width);
        background.setAttribute('height', this._height);
        background.setAttribute('fill', this._backgroundColor);  // Set background color to white
        this._svg.appendChild(background);  // Append background before drawing elements

    }

    // Visualization logic based on the set type
    startVisualFrame(){
        this.clearSVG();

        //clear min and max values
        this._min = this._minActive
        this._max = this._maxActive
        this._minActive = null
        this._maxActive = null
        this._seqNum = 0
        this._displayLength = this._activeLength
        this._activeLength = 8
    }

    visualize(arr, index) {

        const isMultipleArrays = Array.isArray(arr) && arr.every(item => Array.isArray(item));
        if( arr.length > this._activeLength) this._activeLength = arr.length

        arr = this.transformArray(arr)
        this.calculateMinMax(arr)
       
        index = index % arr.length
        //console.log('drawing', index)
        switch (this._type) {
            case 'horizontal':
                this.drawHorizontalLines(index, arr);
                break;
            case 'vertical':
                this.drawVerticalBars(index, arr);
                break;
            case 'numbers':
                this.drawNumericValues(index, arr);
                break;
            default:
                console.error('Unknown visualization type');
        }
        this._seqNum+=1
    }

    calculateMinMax(arr) {
        // Filter the array to include only numbers and numeric strings
        const numericValues = arr
            .filter(item => !isNaN(item) && item !== '' && item !== null)  // Filter out non-numeric values
            .map(item => Number(item));  // Convert numeric strings to numbers

        // Calculate min and max
        const min = Math.min(...numericValues)-.6;
        const max = Math.max(...numericValues)+.6;

        //apply if there is a new min or max
        if(this._minActive === null || min < this._minActive ) this._minActive = min
        if(this._maxActive === null || max > this._maxActive ) this._maxActive = max
    }

    transformArray(arr) {
        const replacements = {
            'O': -1, 'o': 1,
            'X': 0, 'x': 0,
            '1': 3,
            '2': 2,
            '3': 1,
            '*': 4,
            '^': 5
        };
        const rep = ['*','O','o','x','X','^']
        let isDrum = false
        for( let i in rep) isDrum = arr.includes(rep[i]) ? true : isDrum
        if( isDrum) return arr.map(item => replacements[item] !== undefined ? replacements[item] : item);
        else return arr
    }

    // Enable the visualizer: create the SVG and allow drawing
    enable(seqs = null) {
        if(seqs !== null) this.parent.seqToDraw = seqs
        this.parent.drawingLoop.start()
        if (this._enabled) return; // Already enabled

        this._enabled = true;
        this._svg = this.createSVG();
        this._target.appendChild(this._svg);
        this.parent.drawingLoop.start()
    }

    // Disable the visualizer: remove the SVG and prevent drawing
    disable(seqs = null) {
        if (!this._enabled) return; // Already disabled

        this._enabled = false;
        if (this._target && this._svg && this._target.contains(this._svg)) {
            this._target.removeChild(this._svg); // Remove the SVG
        }
        this._svg = null; // Clear reference


    }

    // Getters and Setters for dynamic properties

    // Visualization type
    get type() { return this._type;}
    set type(value) { this._type = value; }

    // Visualization color
    get color() { return this._color; }
    set color(value) { this._color = value; }

    // Size ratio
    get ratio() { return this._ratio; }
    set ratio(value) {
        this._ratio = value;
        this._height = this._width * this._ratio;
        this._svg.setAttribute('height', this._height);
    }

    // Number of rows (for numbers mode)
    get rows() { return this._rows;}
    set rows(value) {  this._rows = value; }

    // Number of columns (for numbers mode)
    get columns() {return this._columns;  }
    set columns(value) { this._columns = value; }

    get enabled() { return this._enabled; }
    set enabled(value) {
        if (value)  this.enable();
        else this.disable();
    }

    // Drawing methods
    drawHorizontalLines(index, arr, elementWidth= this.elementWidth) {
        // Normalize array values between 0 and 1
        arr = arr.map(x => (x - this._min) / (this._max - this._min));

        arr.forEach((value, i) => {
            if(typeof value === 'number' && !isNaN(value)) {
                const line = document.createElementNS("http://www.w3.org/2000/svg", 'line');

                // Calculate the X positions (using a small offset for visual separation)
                const x1 = i * elementWidth/this._displayLength;
                const x2 = (i + 1) * elementWidth/this._displayLength-2;

                // Y position is proportional to the normalized value
                const y = this._height * (1 - value);  // Subtract from height to flip Y axis (0 at bottom)
                let width = this._height/(this._max-this._min) -2
                if(width < 2 ) width = 2
                // Set line coordinates
                line.setAttribute('x1', x1);
                line.setAttribute('x2', x2);
                line.setAttribute('y1', y);
                line.setAttribute('y2', y);

                // Set color based on active index
                if (index === i)  line.setAttribute('stroke', this._activeColor);  // Highlight current index
                else  line.setAttribute('stroke', this._color[this._seqNum]);
                
                // Set line thickness proportional to the available space
                line.setAttribute('stroke-width', width);  // Slightly smaller than the element width

                this._svg.appendChild(line);
            }
        });
    }


    drawVerticalBars(index, arr, elementWidth= this.elementWidth) {
    // Normalize array values between 0 and 1
    arr = arr.map(x => (x - this._min) / (this._max - this._min));

    // Clear the SVG before redrawing
    this.clearSVG();

    arr.forEach((value, i) => {
        if(typeof value === 'number' && !isNaN(value)) {
            const bar = document.createElementNS("http://www.w3.org/2000/svg", 'rect');

            // Calculate the X position for each bar
            const x = i * (elementWidth / this._displayLength);

            // Height of the bar (proportional to the normalized value)
            const barHeight = value * this._height;

            // Y position: Subtract barHeight from the total height to align the bars at the bottom
            const y = this._height - barHeight;
            let barWidth =  elementWidth / this._displayLength*.98
            barWidth = barWidth>4 ? barWidth-2 : barWidth

            // Set the bar's attributes
            bar.setAttribute('x', x);
            bar.setAttribute('y', y);  // Aligns bars at the bottom
            bar.setAttribute('width', barWidth);  // Slightly smaller than the element width for spacing
            bar.setAttribute('height', barHeight);  // Height proportional to normalized value

            // Set the fill color based on the active index
            if (index === i) {
                bar.setAttribute('fill', this._activeColor);
            } else {
                bar.setAttribute('fill', this._color[this._seqNum]);
            }

            this._svg.appendChild(bar);
        }
    });
}


    drawNumericValues(index, arr, elementWidth= this.elementWidth, elementHeight= this.elementHeight) {
        const itemsPerRow = Math.ceil(this.this._displayLength / this._rows);

        arr.forEach((value, i) => {
            const row = Math.floor(index / itemsPerRow);
            const col = i % itemsPerRow;
            const text = document.createElementNS("http://www.w3.org/2000/svg", 'text');
            text.setAttribute('x', col * elementWidth + elementWidth / 2);
            text.setAttribute('y', row * elementHeight + elementHeight / 2);
            if( index == i) text.setAttribute('fill', this._activeColor);
            else text.setAttribute('fill', this._color);
            text.setAttribute('font-size', '16');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('alignment-baseline', 'middle');
            text.textContent = Math.round(value);
            this._svg.appendChild(text);
        });
    }

    // Destroy the visualizer instance and clean up resources
    destroy() {
        if (this._target && this._svg && this._target.contains(this._svg)) {
            this._target.removeChild(this._svg);
        }

        // Nullify references
        this._array = null;
        this._target = null;
        this._svg = null;
    }
}


// MonophonicTemplate.js

;
;


;


/**
 * Represents a Monophonic Synth
 * 
 * Base class for synths. Includes:
 * - methods for loading and saving presets
 * - connect/disconnect
 * - setting ADSR values for env and vcf_env objects
 * - show/hide gui, and custom createKnob function
 *
 * ## Working with presets
 * - all synths can load presets saved in the synth/synthPresets folder.
 *
 * To add preset functionality to a synth:
 * - create the preset file `synths/synthPresets/yourSynthPresets.json`
 *     - your preset file needs an open/close brace {} in it
 *
 * - make sure to:
 *     - import your presets and assign to this.presets 
 *     - name your synth correctly in its constructor
 *     - pass the gui into the synth constructor
 *     - add this optional code to the end of the constructor to load
 *         default preset:
 *     if (this.gui !== null) {
 *         this.initGui()
 *         this.hideGui();
 *         setTimeout(()=>{this.loadPreset('default')}, 500);
 *     }
 *
 * When saving presets you will need to manually download and copy
 * the preset file into synth/synthPresets/
 *
 * @constructor
 */
class MonophonicTemplate {
    constructor() {
        this.presets = {};
        this.gui_elements = [];
        this.gui = null;
        this.poly_ref = null;
        this.super = null;
        this.frequency = new Tone.Signal();
        this.env = new Tone.Envelope();
        this.type = 'Synth';
        this.name = "";
        this.presetsData = null;
        this.curPreset = null;

        // Sequencer related
        this.seq = []; // Array of Seq instances
        this.turingMachine = null;
        this.callback = (i, time) => { }
        this.callbackLoop = new Tone.Loop((time) => {
            this.index = Math.floor(Theory.ticks / Tone.Time('16n').toTicks());
            this.callback(this.index, time = null)
        }, '16n').start()

        // Drawing
        this.seqToDraw = 0;
        this.drawing = new ArrayVisualizer(this, [0], 'Canvas', .2);
        this.drawingLoop = new Tone.Loop(time => {
            if (this.drawing.enabled === true) {
                this.drawing.startVisualFrame();
                if (this.seq[this.seqToDraw]) {
                    const seq = this.seq[this.seqToDraw];
                    if (seq.vals.length > 0) {
                        const index = Math.floor(Theory.ticks / Tone.Time(seq.subdivision).toTicks());
                        this.drawing.visualize(seq.vals, index);
                    }
                }
            }
        }, '16n').start();
    }

    
    /**
     * Save a preset by name
     * @param {string} name - Name of the preset to save
     * @returns {void}
     * @example synth.savePreset('default')
     */
    savePreset (name) {
        const _preset = {};
        for (let element of Object.values(this.gui.elements)) {
            _preset[element.id] = element.value;
        }
        console.log(this.presets, this.gui)
        // Update the presetsData in memory
        //console.log(this.presets);
        if (!this.presets[name]) {
            this.presets[name] = {};
        }
        this.presets[name] = _preset;

        console.log(`Preset saved under ${this.name}/${name}`);
    };

    /**
     * Download the presets data as a JSON file
     * @returns {void}
     * @example synth.downloadPresets()
     */
    downloadPresets ()  {
        this.presetsData = this.presets;
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.presetsData, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", `${this.name}Presets.json`);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    };

    /**
     * Load a preset by name
     * @param {string} name - Name of the preset to load
     * @returns {void}
     * @example synth.loadPreset('default')
     */
    loadPreset(name) {
        setTimeout(()=>{
            this.curPreset = name;
            const presetData = this.presets[this.curPreset];

            if (presetData) {
                console.log("Loading preset ", this.curPreset);
                for (let id in presetData) {
                    try {
                        for (let element of Object.values(this.gui.elements)) {
                            //console.log(element.id, element)
                            if (element.id === id) {
                                if (element.type !== 'momentary') element.set(presetData[id]);
                            }
                        }
                    } catch (e) {
                        console.log(e);
                    }
                }
            } else {
                console.log("No preset of name ", name);
            }
        },50)
    }

    logPreset() {
        const presetData = this.presets[this.curPreset];

        if (presetData) {
            console.log("Preset " + this.curPreset);
            for (let id in presetData) {
                try {
                    for (let element of Object.values(this.gui.elements)) {
                        if (element.id === id) {
                            if (element.type !== 'momentary') console.log(id, presetData[id]);
                        }
                    }
                } catch (e) {
                    console.log(e);
                }
            }
        } else {
            console.log("No preset of name ", this.curPreset);
        }
    }

    /**
     * Console log all available presets
     * @returns {void}
     * @example synth.listPresets()
     */
    listPresets() {
        console.log("Synth presets", this.presets);
    }

    /**
     * Trigger the attack phase of the envelope
     * @param {number} val - MIDI note value
     * @param {number} vel - MIDI velocity value
     * @param {number} time - Time to trigger the attack
     * @returns {void}
     * @example synth.triggerAttack(60, 100, Tone.now())
     */
    triggerAttack(val, vel = 100, time = null) {
        vel = vel / 127;
        if (time) {
            this.frequency.setValueAtTime(Tone.Midi(val).toFrequency(), time);
            this.env.triggerAttack(time);
        } else {
            this.frequency.value = Tone.Midi(val).toFrequency();
            this.env.triggerAttack();
        }
    }

    /**
     * Trigger the release phase of the envelope
     * @param {number} val - MIDI note value
     * @param {number} time - Time to trigger the release
     * @returns {void}
     * @example synth.triggerRelease(60, Tone.now())
     * @example synth.triggerRelease(60)
     */
    triggerRelease(val, time = null) {
        if (time) this.env.triggerRelease(time);
        else this.env.triggerRelease();
    }

    /**
     * Trigger the attack and release phases of the envelope
     * @param {number} val - MIDI note value
     * @param {number} vel - MIDI velocity value
     * @param {number} dur - Duration of the attack and release
     * @param {number} time - Time to trigger the attack and release
     * @returns {void}
     * @example synth.triggerAttackRelease(60, 100, 0.01, Tone.now())
     * @example synth.triggerAttackRelease(60, 100, 0.01)
     */
    triggerAttackRelease(val, vel = 100, dur = 0.01, time = null) {
        console.log('AR ',val,vel,dur,time)
        vel = vel / 127;
        if (time) {
            this.frequency.setValueAtTime(Tone.Midi(val).toFrequency(), time);
            this.env.triggerAttackRelease(dur, time);
        } else {
            this.frequency.value = Tone.Midi(val).toFrequency();
            this.env.triggerAttackRelease(dur);
        }
    }

    generateParameters(paramDefinitions) {
        const params = {};
        paramDefinitions.forEach((def) => {
            const param = new Parameter(def);
            params[def.name] = param;
        });
        return params;
    }

    createAccessors(parent, params) {
    Object.keys(params).forEach((key) => {
        const param = params[key];

        // Ensure the Parameter object has a `set` method
        if (typeof param.set !== 'function') {
            throw new Error(`Parameter '${key}' does not have a set method`);
        }

        // Proxy to handle array-like access
        const proxyHandler = {
            get(target, prop) {
                if (typeof prop === 'string' && !isNaN(prop)) {
                    // Access individual array element
                    return target.get(parseInt(prop));
                }
                return target.get();
            },
            set(target, prop, value) {
                console.log(target, prop, value)
                if (typeof prop === 'string' && !isNaN(prop)) {
                    // Set individual array element
                    target.set(value, parseInt(prop));
                    return true;
                }
                // Set the entire array or scalar value
                target.set(value);
                return true;
            }
        };

        // Define the accessor property on the parent
        Object.defineProperty(parent, key, {
            get: () => new Proxy(param, proxyHandler),
            set: (newValue) => param.set(newValue),
        });
    });
}//createAccessors

    setParameter(name, value, time = null) {
        const param = this.param[name];
        if (!param) throw new Error(`Parameter '${name}' does not exist.`);
        
        if (time) {
            // Handle sequenced parameter updates
            param.callback(value, time);
        } else {
            // Handle immediate parameter updates
            param.callback(value);
        }

        // Update associated GUI elements
        if (param.guiElement) {
            param.guiElement.setValue(value);
        }
    }

    get() {
        let output = 'Parameters:\n';
        for (let key in this.param) {
            const param = this.param[key];
            output += `${param.name}: ${param._value}\n`;
        }
        console.log(output);
    }

    /**
     * Set the ADSR values for the envelope
     * @param {number} a - Attack time
     * @param {number} d - Decay time
     * @param {number} s - Sustain level
     * @param {number} r - Release time
     * @returns {void}
     * @example synth.setADSR(0.01, 0.1, 0.5, 0.1)
     */
    setADSR(a, d, s, r) {
        if (this.env) {
            this.env.attack = a > 0.001 ? a : 0.001;
            this.env.decay = d > 0.01 ? d : 0.01;
            this.env.sustain = Math.abs(s) < 1 ? s : 1;
            this.env.release = r > 0.01 ? r : 0.01;
        }
    }

    /**
     * Set the ADSR values for the filter envelope
     * @param {number} a - Attack time
     * @param {number} d - Decay time
     * @param {number} s - Sustain level
     * @param {number} r - Release time
     * @returns {void}
     * @example synth.setFilterADSR(0.01, 0.1, 0.5, 0.1)
     */
    setFilterADSR(a, d, s, r) {
        if (this.vcf_env) {
            this.vcf_env.attack = a > 0.001 ? a : 0.001;
            this.vcf_env.decay = d > 0.01 ? d : 0.01;
            this.vcf_env.sustain = Math.abs(s) < 1 ? s : 1;
            this.vcf_env.release = r > 0.01 ? r : 0.01;
        }
    }

    /**
     * Initialize the GUI
     * @param {object} gui - p5.gui object
     * @param {number} x - X position of the GUI
     * @param {number} y - Y position of the GUI
     * @returns {void}
     * @example 
     * const gui = new p5(sketch, 'Canvas1');
     * synth.initGui(gui, 10, 10)
     */
    initGui(gui, x = 10, y = 10) {
        this.gui = gui;
        this.x = x;
        this.y = y;
        this.gui_elements = [];
    }

    /**
     * Hide the GUI
     * @returns {void}
     */
    hideGui() {
        for (let i = 0; i < this.gui_elements.length; i++) {
            this.gui_elements[i].hide = true;
        }
    }

    /**
     * Show the GUI
     * @returns {void}
     */
    showGui() {
        for (let i = 0; i < this.gui_elements.length; i++) this.gui_elements[i].hide = false;
    }

    /**
     * Fast way to create a knob GUI element
     * @param {string} _label - Label for the knob
     * @param {number} _x - X position of the knob
     * @param {number} _y - Y position of the knob
     * @param {number} _min - Minimum value of the knob
     * @param {number} _max - Maximum value of the knob
     * @param {number} _size - Size of the knob
     * @param {string} _accentColor - Accent color of the knob
     * @param {function} callback - Callback function for the knob
     * @returns {object} - p5.gui knob object
     * @example
     * this.createKnob('Attack', 10, 10, 0.01, 1, 100, '#ff0000', (val) => {
     *    this.setADSR(val, this.gui.get('Decay').value(), this.gui.get('Sustain').value(), this.gui.get('Release').value());
     * });
     */
    createKnob(_label, _x, _y, _min, _max, _size, _accentColor, callback) {
        return this.gui.Knob({
            label: _label, min: _min, max: _max, size: _size, accentColor: _accentColor,
            x: _x + this.x, y: _y + this.y,
            callback: callback,
            showLabel: 1, showValue: 1,
            curve: 2,
            border: 2
        });
    }

    /**
     * Connects to Tone.js destination
     * @param {object} destination - Tone.js destination object
     * @returns {void}
     * @example 
     * const amp = new Tone.Gain(0.5).toDestination();
     * synth.connect(amp)
     */
    connect(destination) {
        if (destination.input) {
            this.output.connect(destination.input);
        } else {
            this.output.connect(destination);
        }
    }

    /**
     * Disconnects from Tone.js destination
     * @param {object} destination - Tone.js destination object
     * @returns {void}
     * @example
     * const amp = new Tone.Gain(0.5).toDestination();
     * synth.connect(amp)
     * synth.disconnect(amp)
     */
    disconnect(destination) {
        if (destination.input) {
            this.output.disconnect(destination.input);
        } else {
            this.output.disconnect(destination);
        }
    }

    /**
     * Sequences the provided array of notes and initializes a Tone.Loop with the given subdivision.
     *
     * @param {string} arr - The sequence of notes as a string.
     * @param {string} [subdivision] - The rhythmic subdivision for the loop (e.g., '16n', '8n').
     * @param {string} num (default 0) - the sequence number. Up to 10 sequences per instance.
     */
    sequence(arr, subdivision = '8n', num = 0, phraseLength = 'infinite') {
        if (!this.seq[num]) {
            this.seq[num] = new Seq(this, arr, subdivision, phraseLength, num, this.parseNoteString.bind(this));
        } else {
            this.seq[num].sequence(arr, subdivision, phraseLength);
        }
        this.start(num);
    }

    /**
     * Plays the provided sequence array initializes a Tone.Loop with the given subdivision.
     *
     * @param {string} arr - The sequence of notes as a string.
     * @param {number} iterations - The the number of times to play the sequence
     * @param {string} [subdivision] - The rhythmic subdivision for the loop (e.g., '16n', '8n').
     * @param {string} num (default 0) - the sequence number. Up to 10 sequences per instance.
     */
    setSeq(arr, subdivision = '8n', num = 0) {
        if (!this.seq[num]) {
            this.seq[num] = new Seq(this, arr, subdivision, 'infinite', num, this.parseNoteString.bind(this));
        } else {
            this.seq[num].setSeq(arr, subdivision);
        }
    }

    play(num = 0, length = null) {
        if (this.seq[num]) {
            this.seq[num].play(length);
        }
    }

    expr(func, len = 32, subdivision = '16n', num = 0) {
        if (!this.seq[num]) {
            this.seq[num] = new Seq(this, [], subdivision, 'infinite', num, this.parseNoteString.bind(this));
        }
        this.seq[num].expr(func, len, subdivision);
    }

    set velocity(val) {
        for(let i=0;i<10;i++){
            if(this.seq[i])this.seq[i].velocity = val
        }
    }

    set octave(val) {
        for(let i=0;i<10;i++){
            if(this.seq[i])this.seq[i].octave = val
        }
    }

    set sustain(val) {
        for(let i=0;i<10;i++){
            if(this.seq[i])this.seq[i].sustain = val
        }
    }

    set subdivision(val) {
        for(let i=0;i<10;i++){
            if(this.seq[i])this.seq[i].subdivision = val
        }
    }

    set transform(val) {
        if (typeof val !== 'function') {
            console.warn(`Transform must be a function. Received: ${typeof val}`);
            return;
        }
        for(let i=0;i<10;i++){
            if(this.seq[i])this.seq[i].transform = val
        }
    }

    set roll(val) {
        for(let i=0;i<10;i++){
            if(this.seq[i])this.seq[i].roll = val
        }
    }


    /**
     * Sets the transformation for the loop.
     * 
     * @param {string} transform - The transformation to apply.
     */
    setTransform(transform, num = 'all') {
        if (num === 'all') {
            for (let seq of this.seq) {
                if (seq) seq.setTransform(transform);
            }
        } else {
            if (this.seq[num]) this.seq[num].setTransform(transform);
        }
    }

    get sustain() {
        const self = this;
        return new Proxy([], {
            set(target, prop, value) {
                const index = parseInt(prop);
                if (!isNaN(index)) {
                    if (self.seq[index]) {
                        self.seq[index].setSustain(value);
                    }
                }
                return true; // Indicate success
            }
        });
    }

    get velocity() {
        const self = this;
        return new Proxy([], {
            set(target, prop, value) {
                const index = parseInt(prop);
                if (!isNaN(index)) {
                    if (self.seq[index]) {
                        self.seq[index].setVelocity(value);
                    }
                }
                return true;
            }
        });
    }

    get octave() {
        const self = this;
        return new Proxy([], {
            set(target, prop, value) {
                const index = parseInt(prop);
                if (!isNaN(index)) {
                    if (self.seq[index]) {
                        self.seq[index].setOctave(value);
                    }
                }
                return true;
            }
        });
    }

    get subdivision() {
        const self = this;
        return new Proxy([], {
            set(target, prop, value) {
                const index = parseInt(prop);
                if (!isNaN(index)) {
                    if (self.seq[index]) {
                        self.seq[index].setSubdivision(value);
                    }
                }
                return true;
            }
        });
    }

    get roll() {
        const self = this;
        return new Proxy([], {
            set(target, prop, value) {
                const index = parseInt(prop);
                if (!isNaN(index)) {
                    if (self.seq[index]) {
                        self.seq[index].setRoll(value);
                    }
                }
                return true;
            }
        });
    }

    get transform() {
        const self = this;
        return new Proxy([], {
            set(target, prop, value) {
                const index = parseInt(prop);
                if (!isNaN(index)) {
                    if (self.seq[index]) {
                        self.seq[index].setTransform(value);
                    }
                }
                return true;
            }
        });
    }

    start(num = 'all') {
        if (num === 'all') {
            for (let seq of this.seq) {
                if (seq) seq.start();
            }
            this.drawingLoop.start();
        } else {
            if (this.seq[num]) this.seq[num].start();
        }
    }

    stop(num = 'all') {
        if (num === 'all') {
            for (let seq of this.seq) {
                if (seq) seq.stop();
            }
            this.drawingLoop.stop();
        } else {
            if (this.seq[num]) this.seq[num].stop();
        }
    }

    turing(val){

    }

    // Visualizations

    draw(arr = this.drawing.array, target = this.drawing.target, ratio = this.drawing.ratio) {
        this.drawing = new ArrayVisualizer(arr, target, ratio);
    }

    getSeqParam(val, index) {
        //console.log(val, index,)
        if (Array.isArray(val)) return val[index % val.length];
        else return val;
    }

    parseNoteString(val, time, index, num) {
        //console.log(val,time,index, num)
        if (val[0] === ".") return;

        const usesPitchNames = /^[a-gA-G]/.test(val[0][0]);

        let note = '';
        if (usesPitchNames) note = pitchNameToMidi(val[0]);
        else note = intervalToMidi(val[0], this.min, this.max);

        if (note < 0) return;

        let octave = this.getSeqParam(this.seq[num].octave, index);
        let velocity = this.getSeqParam(this.seq[num].velocity, index);
        let sustain = this.getSeqParam(this.seq[num].sustain, index);
        let subdivision = this.getSeqParam(this.seq[num].subdivision, index);
        //octave = 0
        //velocity=100

        try {
            //console.log('trig', time, val[1], Tone.Time(this.subdivision))
            this.triggerAttackRelease(
                note + octave * 12,
                velocity,
                sustain,
                time + val[1] * (Tone.Time(subdivision))
            );
        } catch (e) {
            console.log('invalid note', note + octave * 12, velocity, sustain, time + val[1] * Tone.Time(subdivision));
        }
    }
}


// MonophonicTemplate.js
/*

Base class for drum synths. Inherits from MonophonicTemplate and includes:
*/

;
;

/**
 * Base class for drum synths.
 * extends MonophonicTemplate
 */
class DrumTemplate extends MonophonicTemplate {

    constructor() {
      super()
      this.type = 'Drum'
  }

    /**
     * Function to trigger the drum sound.
     */
    trigger() {
      this.env.triggerAttackRelease(0.001);
    }

    // TODO should we actually reimplement triggerAttack, triggerRelease, and triggerAttackRelease?
    // triggerAttack(val, vel = 100, time = null) {
    //     this.trigger();
    // }

    // triggerRelease(val, time = null) {
    //     // do nothing
    // }

    // triggerAttackRelease(val, vel = 100, dur = 0.01, time = null) {
    //   this.trigger();
    // }
}


;
;
;

/**
 * Class representing a cymbal drum synth.
 * 
 * Synth architecture:
 * - 3 oscillators
 * - 3 noise sources
 * - 2 bandpass filters
 * - 2 amplitude envelopes
 * 
 * @extends DrumTemplate
 * @constructor
 * @param {GUI} gui - The p5 GUI instance to create GUI elements.
 */

class Cymbal extends DrumTemplate {
  
  constructor(gui = null) {
    super();

    this.gui = gui;
    this.name = "Cymbal";

    // Initialize oscillators
    this.oscillators = [];
    this.defaultFrequencies = [893, 2079, 1546];
    this.oscWaveforms = ['sine', 'square', 'triangle', 'sawtooth'];
    for (let i = 0; i < 3; i++) {
      const osc = new Tone.Oscillator({
        type: 'square'
      }).start();
      this.oscillators.push(osc);
    }

    // Initialize noise sources
    this.noises = [];
    this.noiseTypes = ['white', 'pink', 'brown'];
    for (let i = 0; i < 3; i++) {
      const noise = new Tone.Noise('white').start();
      this.noises.push(noise);
    }

    // Mix the oscillators and noise sources
    this.oscMixer = new Tone.Gain(1);
    this.oscillators.forEach(osc => osc.connect(this.oscMixer));
    this.noises.forEach(n => n.connect(this.oscMixer));

    // Filter out lower band and envelope
    this.lowerBandFilter = new Tone.Filter({ type: 'bandpass' });
    this.lowerBandEnv = new Tone.AmplitudeEnvelope({
      attack: 0.01, decay: 0.4, sustain: 0.0, release: 0.1
    });
    this.lowerBandVCA = new Tone.Gain(1);
    // Connect mixer to the lower band filter. Chain filter to envelope and VCA
    this.oscMixer.chain(this.lowerBandFilter, this.lowerBandEnv, this.lowerBandVCA);


    // Filter out upper band, split into two bands, and envelope
    this.upperBandFilter = new Tone.Filter({ type: 'bandpass' });
    this.upperBandFilter1 = new Tone.Filter({ type: 'bandpass' });
    this.upperBandFilter2 = new Tone.Filter({ type: 'bandpass' });
    this.upperBandEnv1 = new Tone.AmplitudeEnvelope({
      attack: 0.01, decay: 0.2, sustain: 0.0, release: 0.1
    });
    this.upperBandEnv2 = new Tone.AmplitudeEnvelope({
      attack: 0.01, decay: 0.3, sustain: 0.0, release: 0.1
    });
    this.upperBandVCA1 = new Tone.Gain(1);
    this.upperBandVCA2 = new Tone.Gain(1);
    // Connect mixer to the upper band filter. Chain filter to envelope and VCA
    this.oscMixer.connect(this.upperBandFilter);
    this.upperBandFilter.chain(this.upperBandFilter1, this.upperBandEnv1, this.upperBandVCA1);
    this.upperBandFilter.chain(this.upperBandFilter2, this.upperBandEnv2, this.upperBandVCA2);

    // Connect VCAs to the ouput node
    this.output = new Tone.Gain(1);
    this.lowerBandVCA.connect(this.output);
    this.upperBandVCA1.connect(this.output);
    this.upperBandVCA2.connect(this.output);

    this.output.toDestination();


    // Initialize GUI if provided
    if (this.gui !== null) {
      this.initGui();
    }
  }

  initGui(gui = this.gui) {
    if (gui === null) {
      console.error('Provide a GUI instance to create GUI elements');
      return;
    }

    for (let i = 0; i < 3; i++) {
      const osc = this.oscillators[i];
      const freq = gui.Knob({
        label: 'freq ' + i,
        mapto: osc.frequency,
        x: 40 + 8 * i,
        y: 12,
        size: 0.5,
        min: 20,
        max: 2500,
        curve: 2,
        value: this.defaultFrequencies[i]
      });

      const oscWaveform = gui.Radio({
        label: 'waveform ' + i,
        radioOptions: this.oscWaveforms,
        callback: (waveform) => {
          osc.type = waveform;
        },
        size: 1,
        x: 7,
        y: 12 + i * 20,
        horizontal: true,
        value: 'square'
      });
    }

    for (let i = 0; i < 3; i++) {
      const noise = this.noises[i];
      const noiseType = gui.Radio({
        label: 'noise ' + i,
        radioOptions: this.noiseTypes,
        callback: (type) => {
          noise.type = type;
        },
        size: 1,
        x: 90,
        y: 12 + i * 16,
        horizontal: true,
        value: 'white'
      });
    }

    const lowerBandFreq = gui.Knob({
      label: 'low band freq',
      mapto: this.lowerBandFilter.frequency,
      x: 20,
      y: 50,
      size: 0.5,
      min: 100,
      max: 5000,
      curve: 2,
      value: 579
    });
    const lowerBandQ = gui.Knob({
      label: 'low band Q',
      mapto: this.lowerBandFilter.Q,
      x: 30,
      y: 50,
      size: 0.5,
      min: 0.5,
      max: 5,
      curve: 2,
      value: 1.45
    });

    const lowerBandDecay = gui.Knob({
      label: 'low decay',
      mapto: this.lowerBandEnv.decay,
      x: 20,
      y: 70,
      size: 0.5,
      min: 0.01,
      max: 1,
      curve: 2,
      value: 0.4
    });
    const lowerBandRelease = gui.Knob({
      label: 'low release',
      mapto: this.lowerBandEnv.release,
      x: 30,
      y: 70,
      size: 0.5,
      min: 0.01,
      max: 1,
      curve: 2,
      value: 0.1
    });

    const upperBandFreq = gui.Knob({
      label: 'up band freq',
      mapto: this.upperBandFilter.frequency,
      x: 57,
      y: 50,
      size: 0.5,
      min: 1000,
      max: 10000,
      curve: 2,
      value: 5976
    });
    const upperBandQ = gui.Knob({
      label: 'up band Q',
      mapto: this.upperBandFilter.Q,
      x: 67,
      y: 50,
      size: 0.5,
      min: 0.5,
      max: 5,
      curve: 2,
      value: 1.4
    });

    const upperBandFreq1 = gui.Knob({
      label: 'up1 band freq',
      mapto: this.upperBandFilter1.frequency,
      x: 45,
      y: 60,
      size: 0.5,
      min: 1000,
      max: 10000,
      curve: 2,
      value: 6795
    });
    const upperBandFreq2 = gui.Knob({
      label: 'up2 band freq',
      mapto: this.upperBandFilter2.frequency,
      x: 70,
      y: 60,
      size: 0.5,
      min: 1000,
      max: 10000,
      curve: 2,
      value: 8735
    });
    const upperBandQ1 = gui.Knob({
      label: 'up1 band Q',
      mapto: this.upperBandFilter1.Q,
      x: 55,
      y: 60,
      size: 0.5,
      min: 0.5,
      max: 5,
      curve: 2,
      value: 1.39
    });
    const upperBandQ2 = gui.Knob({
      label: 'up2 band Q',
      mapto: this.upperBandFilter2.Q,
      x: 80,
      y: 60,
      size: 0.5,
      min: 0.5,
      max: 5,
      curve: 2,
      value: 0.67
    });

    const upperBandDecay1 = gui.Knob({
      label: 'up1 decay',
      mapto: this.upperBandEnv1.decay,
      x: 45,
      y: 70,
      size: 0.5,
      min: 0.01,
      max: 1,
      curve: 2,
      value: 0.2
    });
    const upperBandRelease1 = gui.Knob({
      label: 'up1 release',
      mapto: this.upperBandEnv1.release,
      x: 55,
      y: 70,
      size: 0.5,
      min: 0.01,
      max: 1,
      curve: 2,
      value: 0.1
    });
    const upperBandDecay2 = gui.Knob({
      label: 'up2 decay',
      mapto: this.upperBandEnv2.decay,
      x: 70,
      y: 70,
      size: 0.5,
      min: 0.01,
      max: 1,
      curve: 2,
      value: 0.3
    });
    const upperBandRelease2 = gui.Knob({
      label: 'up2 release',
      mapto: this.upperBandEnv2.release,
      x: 80,
      y: 70,
      size: 0.5,
      min: 0.01,
      max: 1,
      curve: 2,
      value: 0.1
    });

    // Trigger button for the cymbal sound
    const triggerButton = gui.Button({
      label: 'trig',
      callback: () => this.trigger(),
      size: 2,
      border: 20,
      borderColor: [255, 0, 0],
      x: 48,
      y: 36
    });
  }

  trigger() {
    this.lowerBandEnv.triggerAttackRelease(0.01);
    this.upperBandEnv1.triggerAttackRelease(0.01);
    this.upperBandEnv2.triggerAttackRelease(0.01);
  }
}


window.DaisiesPresets = {
  "default": {
    "vco_mix": 0.4096000000000002,
    "detune": 1.9940090000000001,
    "cutoff": 120.9999999999993,
    "vcf env": 1057.9999999999998,
    "Q": 2.047999999999998,
    "key vcf": 1,
    "hpf": 46.178999999999824,
    "a": 0.005,
    "d": 0.1716759999999987,
    "s": 0.6723999999999998,
    "r": 1.6809999999999994,
    "a1": 0.005,
    "d1": 1.159696,
    "s1": 0.6888999999999997,
    "r1": 0.840999999999999,
    "lfo": 4.801999999999989,
    "vibrato": 0,
    "tremolo": 0
  },
  "ether": {
    "vco_mix": 0.6724000000000004,
    "detune": 1.9940090000000001,
    "cutoff": 168.99999999999915,
    "vcf env": 1250,
    "Q": 4.231999999999999,
    "key vcf": 1,
    "hpf": 46.178999999999824,
    "a": 0.005,
    "d": 0.1716759999999987,
    "s": 0.4224999999999996,
    "r": 3.8440000000000003,
    "a1": 0.005,
    "d1": 1.159696,
    "s1": 0.2915999999999996,
    "r1": 2.809,
    "lfo": 4.801999999999989,
    "vibrato": 0.007290000000000004,
    "tremolo": 0
  },
  "tremPad": {
    "vco_mix": 0.4355999999999999,
    "detune": 1.009409,
    "cutoff": 1023.999999999999,
    "vcf env": 1200.5,
    "Q": 4.802,
    "key vcf": 1,
    "hpf": 46.178999999999824,
    "a": 0.5,
    "d": 9.9006989999999995,
    "s": 1,
    "r": 20,
    "a1": 0.5,
    "d1": 10,
    "s1": 1,
    "r1": 20,
    "lfo": 1.7999999999999925,
    "vibrato": 0,
    "tremolo": 0.5329000000000006
  },
  "chime": {
    "vco_mix": 0.19359999999999997,
    "detune": 1.9940090000000001,
    "cutoff": 624.9999999999986,
    "vcf env": 1300.5,
    "Q": 2.047999999999998,
    "key vcf": 0.6723999999999998,
    "hpf": 46.178999999999824,
    "a": 0.005,
    "d": 0.28933062867908127,
    "s": 0.52089999999999965,
    "r": 1.457068975770812,
    "a1": 0.005,
    "d1": 0.6305912279255007,
    "s1": 0.04839999999999971,
    "r1": 0.7609756133823595,
    "lfo": 2.047999999999991,
    "vibrato": 0.0032400000000000007,
    "tremolo": 0.24010000000000026,
    "blend": 0.25,
    "shape1": 0.009999999999999943,
    "shape2": 0.3721000000000001,
    "pan": 0.19359999999999955
  }
};;

/*
Daisies
Polyphonic Subtractive Synthesizer

Daisy:
* 2 OmniOscillators(vco_1, vco_2)->shape->waveShapers->mixer->vcf->hpf->panner->vca
* frequency->frequency_scalar->(detuneSig for vco_2)->vco_1.frequency
* frequencyCV->frequency_scalar.factor
* cutoff control: cutoff, cutoff_vc, keyTracking, vcf_env_depth
* lfo->vca_lfo_depth-<output.factor, pitch_lfo_depth->
* lfo->pitch_lfo_depth->frequency_scalar.factor
* env->velocity_depth(Multiply)->vca.factor
* velocity(Signal)->velocity_depth.factor
Daisies:
* daisy->hpf->output

signal inputs:
- frequency (signal, Hz)
- frequency CV (multiplication factor)
methods:
- connect
- panic()
- setFrequency
- setDetune
-  setResonance
-  setCutoff
-  setCutoffCV
-  setHighpass 
-  setKeyTracking 
-  setFilterEnvDepth = function(val){this.voiceSettings["vcf_env_depth.factor"] =  val }
-  setPanning(val)
-  setPulseWidth (num,val)
-  setVcoGain(num,val)
-  setVcoType(num, type)
-  setLfoFrequency(val)
-  setTremoloDepth(val)
-  setVibratoDepth(val)
- setADSR
- setHighpass(val)

properties:
- 

CC control of:
- setCutoffCV
- setPulseWidth
- setADSR
- setFilterADSR
- setDecayCV
- setHighpass
- setDetune
- setLfoFrequency

Main List of Parameters & how to set them:
- detune: setDetune
- detune_cv_depth.factor: setDetuneCV
- resonance: setResonance
- resonance_cv_depth.factor: setResonanceCV
- cutoff: setCutoff
- cutoff_cv_depth.factor: setCutoffCV
- highpass_freq: setHighpass 
- key_tracking_depth: setKeyTracking 
- vcf_env_depth: setFilterEnvDepth = function(val){this.voiceSettings["vcf_env_depth.factor"] =  val }
- panning: setPanning(val)
- pulse_width[vco_1,vco_2]: setPulseWidth (num,val)
- vco_gain[vco_1,vco_2]: setVcoGain(num,val)
- vco_type[vco_1,vco_2]: setVcoType(num, type)
- lfo_frequency: setLfoFrequency(val)
- lfo_frequency_cv_depth.factor: setLfoFrequencyCV(val)
- lfo_tremolo_cv_depth.factor: setTremoloCV(val)
- lfo_tremolo_depth: setTremoloDepth(val)
- lfo_vibrato_cv_depth.factor: setVibratoCV(val)
- lfo_vibrato_depth: setVibratoDepth(val)
- env

- filter_env: same as env

*/

;
;
;
;

class Daisy extends MonophonicTemplate{
	constructor(){
		super()
		this.presets = DaisiesPresets
		this.name = 'Daisy'

		this.frequency = new Tone.Signal(100)
		this.frequencyCV = new Tone.Signal()
		this.frequency_scalar = new Tone.Multiply(1)
		this.detune_scalar = new Tone.Multiply(1)
		this.vco_1 = new Tone.Oscillator({type:"square"}).start()
		this.vco_2 = new Tone.Oscillator({type:"square"}).start()
		this.frequency.connect(this.frequency_scalar)
		this.frequencyCV.connect(this.frequency_scalar.factor)
		this.frequency_scalar.connect(this.vco_1.frequency)
		this.frequency_scalar.connect(this.detune_scalar)
		this.detune_scalar.connect(this.vco_2.frequency)

		this.crossfade = new Tone.CrossFade()
		this.crossfade_lfo_depth = new Tone.Multiply()
		this.vco_1.connect( this.crossfade.a)
		this.vco_2.connect( this.crossfade.b)

		this.vcf = new Tone.Filter({type:'lowpass', rolloff:-24, Q:0, cutoff:3000})
		this.crossfade.connect(this.vcf)
		this.crossfade_constant = new Tone.Signal(0)
		this.crossfade_lfo_depth.connect(this.crossfade.fade)
		this.crossfade_constant.connect(this.crossfade.fade)

		this.vca = new Tone.Multiply()
		this.lfo_vca = new Tone.Multiply(1)
		this.lfo_vca_constant = new Tone.Signal(1)
		this.panner = new Tone.Panner(0)
		this.output = new Tone.Multiply(.25)
		this.vcf.connect(this.lfo_vca)
		this.lfo_vca.connect(this.vca)
		this.lfo_vca_constant.connect(this.lfo_vca.factor)
		this.vca.connect(this.panner)
		this.panner.connect(this.output)

		//envelopes
		this.env = new Tone.Envelope()
		this.velocitySig = new Tone.Signal(1)
		this.velocity_depth = new Tone.Multiply(1)
		this.env.connect(this.velocity_depth)
		this.velocity_depth.connect(this.vca.factor)
		this.velocitySig.connect(this.velocity_depth.factor)

		//vcf
		this.cutoffSig = new Tone.Signal(1000)
		this.cutoffSig.connect(this.vcf.frequency)
		this.cutoffCV = new Tone.Signal()
		this.cutoffCV.connect(this.vcf.frequency)
		this.keyTracking = new Tone.Multiply(.1)
		this.frequency.connect(this.keyTracking)
		this.keyTracking.connect(this.vcf.frequency)
		this.vcf_env = new Tone.Envelope()
		this.vcf_env_depth = new Tone.Multiply()
		this.vcf_env.connect(this.vcf_env_depth)
		this.vcf_env_depth.connect(this.vcf.frequency)

		this.lfo = new Tone.Oscillator(.5).start()
		this.vca_constant = new Tone.Signal(1)
		this.amp_lfo_depth = new Tone.Multiply(0)
		this.lfo.connect(this.amp_lfo_depth)
		this.amp_lfo_depth.connect(this.lfo_vca.factor)
		this.pitch_lfo_depth = new Tone.Multiply(0)
		this.lfo.connect(this.pitch_lfo_depth)
		this.lfo.connect(this.crossfade_lfo_depth)
		this.frequency_constant = new Tone.Signal(1)
		this.pitch_lfo_depth.connect(this.frequency_scalar.factor)
		this.frequency_constant.connect(this.frequency_scalar.factor)

		//no PWM to prevent errors when vco is not set to pulse
		this.pwm_lfo_depth = new Tone.Multiply()
		this.lfo.connect(this.pwm_lfo_depth)

		//this.pwm_lfo_depth.connect(this.vco_1.width)
		//this.pwm_lfo_depth.connect(this.vco_2.width)

		//for autocomplete
		this.autocompleteList = ["test", "triggerAttack"];
  }

  //TRIGGER METHODS
  triggerAttack = function(val, vel=100, time=null){
  	let freq = Tone.Midi(val).toFrequency()
  	vel = vel/127
    if(time){
      this.frequency.setValueAtTime(freq,time)
      this.env.triggerAttack(time)
      this.vcf_env.triggerAttack(time)
      this.velocitySig.setValueAtTime(Math.pow(vel,2),time)
    } else{
      this.frequency.value = freq
      this.env.triggerAttack()
      this.vcf_env.triggerAttack()
      this.velocitySig.value =Math.pow(vel,2) 
    }
  }
  triggerRelease = function(val, time=null){
    if(time){
      this.env.triggerRelease(time)
      this.vcf_env.triggerRelease(time)
    } else{
      this.env.triggerRelease()
      this.vcf_env.triggerRelease()
    }
  }
  triggerAttackRelease = function(val, vel=100, dur=0.01, time=null){
    val = Tone.Midi(val).toFrequency()
    vel = vel/127
    if(time){
      this.frequency.setValueAtTime(val,time)
      this.env.triggerAttackRelease(dur,time)
      this.vcf_env.triggerAttackRelease(dur,time)
      this.velocitySig.setValueAtTime(Math.pow(vel,2),time)
    } else{
      this.frequency.value = val
      this.env.triggerAttackRelease(dur)
      this.vcf_env.triggerAttackRelease(dur)
      this.velocitySig.value =Math.pow(vel,2) 
    }
  }//attackRelease

  shapeVco(vcoNum, shape, amp=2, curve=1, isEven=1 ){
  	//console.log(vcoNum,shape, this.vco_1)
		let partials = []
	  for(let i=0;i<64;i++){
	    partials.push(1/Math.pow(i+1,curve)*16*(i%2<(2-isEven))*Math.abs(1-Math.sin(i*Math.PI*shape+Math.PI/2)*amp))
	  }
	  if(vcoNum === 0) {
	  	//console.log(shape, this.vco_1.partials)
	  	this.vco_1.partials = partials
	  	//console.log('post ', this.vco_1.partials)
	  }
	  else this.vco_2.partials = partials 
  }

  setHighpass(val){
  	if(this.super !== null){
  		this.super.hpf.frequency.value = val
  	}
  }

  initGui(gui, x=10,	y=10){
  	// if(this.gui_elements.length > 0){
  	// 	console.log("initGui is called when a synth is created.\n Call synth.showGui() to see it.")
  	// 	return;
  	// }
  	this.gui = gui
  	this.x = x
  	this.y = y
  	this.vco_mix = this.createKnob('vco_mix', 0, 5, 0, 1, 0.75, [200,50,0],x=>this.crossfade_constant.value= x);
  	this.detune = this.createKnob('detune', 10, 5, 1, 2, 0.5, [200,50,0],x=>this.detune_scalar.factor.value = x);
  	this.vco1_shape_knob = this.createKnob('shape1', 18, 5, 0,1, 0.5, [200,50,0],x=>this.shapeVco(0, x*2+1));
  	this.vco2_shape_knob = this.createKnob('shape2', 25, 5, 0,1, 0.5, [200,50,0],x=>this.shapeVco(1, x*2+1));
  	
  	this.cutoff = this.createKnob('cutoff', 40, 5, 0, 10000, 1, [200,50,0],x=>this.cutoffSig.value = x);
  	this.vcf_env_knob = this.createKnob('vcf env', 50, 5, 0, 5000, 0.75, [200,50,0],x=>this.vcf_env_depth.factor.value = x);
  	this.vcf_Q_knob = this.createKnob('Q', 60, 5, 0, 20, 0.5, [200,50,0],x=>this.vcf.Q.value = x);
  	this.keyTracking_knob = this.createKnob('key vcf', 70, 5, 0, 1, 0.5, [200,50,0],x=>this.keyTracking.factor.value = x);
  	this.highpass_knob = this.createKnob('hpf', 80, 5, 10, 3000, 0.5, [200,50,0],x=>this.setHighpass(x));
  	this.attack_knob = this.createKnob('a', 5, 70, 0.005, .5, 0.5, [200,50,0],x=>this.env.attack = x);
  	this.decay_knob = this.createKnob('d', 13, 70, 0.01, 10, 0.5, [200,50,0],x=>this.env.decay = x);
  	this.sustain_knob = this.createKnob('s', 21, 70, 0, 1, 0.5, [200,50,0],x=>this.env.sustain = x);
  	this.release_knob = this.createKnob('r', 29, 70, 0, 20, 0.5, [200,50,0],x=>this.env.release = x);
  	this.vcf_attack_knob = this.createKnob('a', 5, 45, 0.005, .5, 0.5, [200,50,0],x=>this.vcf_env.attack = x);
  	this.vcf_decay_knob = this.createKnob('d', 13, 45, 0.01, 10, 0.5, [200,50,0],x=>this.vcf_env.decay = x);
  	this.vcf_sustain_knob = this.createKnob('s', 21, 45, 0, 1, 0.5, [200,50,0],x=>this.vcf_env.sustain = x);
  	this.vcf_release_knob = this.createKnob('r', 29, 45 , 0, 20, 0.5, [200,50,0],x=>this.vcf_env.release = x);
  	this.lfo_freq_knob = this.createKnob('lfo', 45, 65, 0, 20, 1, [200,50,0],x=>this.lfo.frequency.value = x);
  	this.lfo_vibrato = this.createKnob('vibrato', 55, 65, 0, .1, 0.5, [200,50,0],x=>this.pitch_lfo_depth.factor.value = x);
  	this.lfo_tremolo = this.createKnob('tremolo', 63, 65, 0, 1, 0.5, [200,50,0],x=>this.amp_lfo_depth.factor.value = x);
  	this.lfo_blend_knob = this.createKnob('blend', 71, 65, 0, 1, 0.5, [200,50,0],x=>this.crossfade_lfo_depth.factor.value = x);
  	this.vcfEnvText = this.gui.Text({label:'vcf', x:10, y:55, border:0.1})
  	this.vcaEnvText = this.gui.Text({label:'vca', x:10, y:80, border: 0.1})
  	//this.pan_knob = this.createKnob('pan', 85, 65, 0, 1, 0.5, [200,50,0],x=>this.crossfade_lfo_depth.factor.value = x);
  	
  	this.pan_knob = this.createKnob('pan', 80, 65, 0, 1, 0.5, [200,50,0],x=>{this.super.pan(x)});


  	this.gui_elements = [ this.vco_mix, this.detune, this.cutoff, this.vcf_env_knob, this.vcf_Q_knob, this.keyTracking_knob, 
  		this.highpass_knob, 
  		this.attack_knob, this.decay_knob, this.sustain_knob, this.release_knob, this.vcf_attack_knob, this.vcf_decay_knob, this.vcf_sustain_knob, this.vcf_release_knob, this.lfo_freq_knob, this.lfo_vibrato, this.lfo_tremolo, this.lfo_blend_knob
  		, this.pan_knob, this.vco1_shape_knob, this.vco2_shape_knob,
  		this.vcfEnvText,this.vcaEnvText
  		];
  }

}

/********************
 * polyphony
 ********************/

class Daisies extends MonophonicTemplate{
  constructor(gui = null, num = 8){
  	console.log('Daisies is obsolete: use Polyphony(Daisy) instead')
		}
}


/****
 * In this file:
 * stepper( input:number, min:number, max:number, steps:array of [in:out] points)
 * expr( func, len=32 ): returns a custom array built using func
 * /

/*
    * Helper function for creating a custom curve for this.gui elements
    *
    * input : input of the stepper function
    * min: minimmum value of the element
    * max: maximmum value of the element
    * steps: array of arrays in format [[0,0], [a,b], .... [1,1]] where each point is a step in the curve
    * 
    * x values are how much the this.gui element is turned
    * y values are the level the elements are at internally
    */

function stepper(input, min, max, steps) {
    let range = max - min
    let rawval = (input - min) / range
    const gui_values = []
    const internal_values = []
    for (let i = 0; i < steps.length ; i++) {
        gui_values.push(steps[i][0])
        internal_values.push(steps[i][1])
    }
    let index = 0
    while(index < gui_values.length) {
        if (rawval < gui_values[index]) {
            let slope = (internal_values[index] - internal_values[index - 1])/(gui_values[index] - gui_values[index-1])
            let rawCurved = internal_values[index-1] + slope * (rawval - gui_values[index - 1]) 
            let realCurved = (rawCurved * range) + min
            //console.log('input value', input)
            //console.log('curved value', realCurved)
            return realCurved
        }
        index++
    }
    return max
}

/***
 * 
 */

function expr( func, len = 32 ){
  const arr = Array.from({ length: len }, (_, i) => func(i))
  return arr
}
 

window.DatoDuoPresets = {
  "thickDistortion": {
    "Accent": 0,
    "bitcrusher": 0,
    "Glide": 0,
    "Delay Control": 0.0001,
    "wave": 0.5,
    "freq": 700,
    "release": 0.8,
    "res": 1,
    "detune": 1,
    "gain": 0.05
  },
  "default": {
    "Accent": 0,
    "bitcrusher": 0,
    "Glide": 0,
    "Delay Control": 0.05095,
    "wave": 0.6950000000000002,
    "freq": 1791.337256248868,
    "release": 1.2970000000000006,
    "res": 3.448777886795153,
    "detune": 2,
    "gain": 0.05
  },
  "shortNoisy": {
    "Accent": 1,
    "bitcrusher": 1,
    "Glide": 0,
    "Delay Control": 0.05088999999999999,
    "wave": 0.45999999999999996,
    "freq": 776.54211607628105,
    "release": 0.604,
    "res": 8.859313268874072,
    "detune": 1.0099901,
    "gain": 0.04450314575050762
  }
};;

/*
DatoDuo
Monophonic subtractive synth
Modeled after the DatoDuo
*/

;
;


;
;

/**
 * Class representing the DatoDuo monophonic subtractive synthesizer.
 * Extends the MonophonicTemplate class.
 */
class DatoDuo extends MonophonicTemplate {
  /**
   * Create a DatoDuo synthesizer.
   * @param {object} [gui=null] - The GUI object for controlling the synthesizer.
   */
  constructor (gui = null) {
    super()
    this.gui = gui
    this.presets = DatoDuoPresets
    this.isGlide = false
    this.name = "DatoDuo"
    //console.log(this.name, " loaded, available preset: ", DatoDuoPresets)

    this.frequency = new Tone.Signal()
    this.tonePitchShift = new Tone.Multiply()
    this.sawPitchShift = new Tone.Multiply()
    this.pulseWav = new Tone.PulseOscillator().start()
    this.sawWav = new Tone.Oscillator({type:'sawtooth'}).start()
    this.toneMixer = new Tone.Multiply()
    this.sawMixer = new Tone.Multiply()
    this.cutoff = new Tone.Signal()
    this.vcf_env = new Tone.Envelope()
    this.filterDepth = new Tone.Multiply()
    this.filterMultiplier = new Tone.Multiply()
    this.filter = new Tone.Filter()
    this.velocity = new Tone.Signal(1)
    this.velocityMult = new Tone.Multiply(1)
    this.env = new Tone.Envelope()
    this.amp = new Tone.Multiply()
    this.output = new Tone.Multiply(0.05).toDestination()

    //this.scope = new Oscilloscope('Canvas3')

    //connect the initial signal to multipliers for pitch shift
    //connect those to the oscillators
    this.frequency.connect(this.tonePitchShift)
    this.tonePitchShift.connect(this.pulseWav.frequency)
    this.frequency.connect(this.sawPitchShift)
    this.sawPitchShift.connect(this.sawWav.frequency)
    this.rampTime = .004

    this.frequency.value = 500;
    this.tonePitchShift.factor.value = 1;
    this.sawPitchShift.factor.value = 1;

    //connect the oscillators to a mixer and add them together
    this.pulseWav.connect(this.toneMixer)
    this.toneMixer.connect(this.filter)
    this.sawWav.connect(this.sawMixer)
    this.sawMixer.connect(this.filter)

    this.toneMixer.factor.value = .25
    this.sawMixer.factor.value = .25

    //Connect the filter (VCF)
    this.vcf_env.connect(this.filterDepth)
    this.cutoff.connect(this.filter.frequency)
    this.filterDepth.connect(this.filter.frequency)

    this.cutoff.value = 1500
    this.filterDepth.factor.value = 5000
    this.vcf_env.attack = 0.02
    this.vcf_env.decay = 0.01
    this.vcf_env.sustain = .0
    this.vcf_env.release = 0.2
    this.filter.rolloff = -24
    this.filter.Q.value = 1

    //Connect the ASDR (VCA)
    this.filter.connect(this.amp)

    this.velocity.connect(this.velocityMult.factor)
    this.env.connect(this.velocityMult)
    this.velocityMult.connect(this.amp.factor)
    this.env.attack = 0.01
    this.env.delay = 0.1
    this.env.sustain = 0
    this.env.release = 0.9
    this.env.releaseCurve = 'cosine'

    //effects chain

    this.dist = new Tone.Distortion(0.9)
    this.crusher = new Tone.BitCrusher(2)
    this.delay = new Tone.FeedbackDelay()


    this.distgain = new Tone.Multiply(1)
    this.crushgain = new Tone.Multiply(1)
    this.delaygain = new Tone.Multiply(1)
    this.delayFilter = new Tone.Filter()
    this.lfo = new Tone.LFO("8n", 400, 2000)

    //distortion
    this.amp.connect(this.dist)
    this.dist.connect(this.distgain)
    this.distgain.connect(this.crusher)

    //bitcrusher
    //this.distout.connect(this.crushout)
    //this.distout.connect(this.crushgain)
    //this.crushgain.connect(this.crusher)
    this.crusher.connect(this.output)

    //delay
    //this.crushout.connect(this.delayout)
    this.crusher.connect(this.delaygain)
    this.delaygain.connect(this.delay)
    this.delay.connect(this.delayFilter)
    this.lfo.connect(this.delayFilter.frequency)
    this.delayFilter.connect(this.output)

    this.kick = "audio/drums-003.mp3"
    this.snare = "audio/snare.mp3"
    this.kickPlayer = new Tone.Sampler({
      urls: {
        C4: "drums-003.mp3"
      },
      baseUrl: "/m080/audio/"
    }).toDestination()
    this.snarePlayer = new Tone.Sampler({
      urls: {
        C4: "snare.mp3"
      },
      baseUrl: "/m080/audio/"
    }).toDestination()
    this.kickPlayer.volume.value = -12
    this.snarePlayer.volume.value = -18
    // this.kickPlayer.playbackRate = 1
    // this.snarePlayer.playbackRate = 1


    // if (this.gui !== null) {
    //     this.initGui()
    //     this.hideGui();
    //     setTimeout(()=>{this.loadPreset('default')}, 500);
    // }
  }

  //envelopes
  triggerAttack (freq, amp, time=null){
    amp = Math.pow(amp / 127,2);
    freq = Tone.Midi(freq).toFrequency()
    if(time){
      this.env.triggerAttack(time)
      this.vcf_env.triggerAttack(time)
      if (this.isGlide) {
        this.frequency.linearRampToValueAtTime(freq,this.rampTime+ time)
      }
      else {
        this.frequency.setValueAtTime(freq, time)
      }
      this.velocity.rampTo(amp,.03)
    } else{
      this.env.triggerAttack()
      this.vcf_env.triggerAttack()
      this.frequency.value = freq
      this.velocity.rampTo(amp,.03)
    }
  }
  triggerRelease (time=null){
    if(time) {
      this.env.triggerRelease(time)
      this.vcf_env.triggerRelease(time)
    }
    else {
      this.env.triggerRelease()
      this.vcf_env.triggerRelease()
    }
  }
  // Override triggerAttackRelease method
    triggerAttackRelease(freq, amp, dur = 0.01, time = null) {
      //console.log('ar', freq)
        amp = Math.pow(amp / 127,2);
        freq = Tone.Midi(freq).toFrequency();
        if (time) {
            this.env.triggerAttackRelease(dur, time);
            this.vcf_env.triggerAttackRelease(dur, time);
            this.velocity.setValueAtTime(amp, time)
            if (this.isGlide) {
                this.frequency.linearRampToValueAtTime(freq, this.rampTime + time);
            } else {
                this.frequency.setValueAtTime(freq, time);
            }
        } else {
            this.env.triggerAttackRelease(dur);
            this.vcf_env.triggerAttackRelease(dur);
            if (this.isGlide) {
                this.frequency.exponentialRamp(freq, this.rampTime);
            } else {
                this.frequency.value = freq;
            }
            this.velocity.rampTo(amp, 0.03);
        }
    }//attackRelease


  //parameter setters
  setADSR(a,d,s,r){
    this.env.attack = a>0.001 ? a : 0.001
    this.env.decay = d>0.01 ? d : 0.01
    this.env.sustain = Math.abs(s)<1 ? s : 1
    this.env.release = r>0.01 ? r : 0.01
  }
  setFilterADSR(a,d,s,r){
    this.vcf_env.attack = a>0.001 ? a : 0.001
    this.vcf_env.decay = d>0.01 ? d : 0.01
    this.vcf_env.sustain = Math.abs(s)<1 ? s : 1
    this.vcf_env.release = r>0.01 ? r : 0.01
  }
  /**
   * Sets the detune value for the synthesizer.
   * @param {number} detune - The detune value.
   */
  setDetune(detune){
    this.sawPitchShift.factor.value = detune
  }
  setPulsewidth(width) {
    this.pulseWav.width = width;
  }
  setOutputGain(out){
    this.output.factor.value = out
  }

  /**
   * Initializes the GUI controls for the synthesizer.
   * @param {object} [gui=this.gui] - The GUI object to use.
   */
  initGui(gui = this.gui) {
    this.gui = gui

    this.distortion_toggle =  this.gui.Knob({
      label:'Distortion',
      callback: x=>{
        this.dist.distortion = x
        this.distgain.factor.value = 1-(x*.4)
      },
      //mapto: this.dist.distortion,
      x: 85, y:20, size: 0.8,
      min:0, max:.9,
      link: 'dist'
    })
    this.distortion_toggle.accentColor = [51,145,219]
    this.dist.wet.value = 1

    this.crusher_toggle =  this.gui.Knob({
      label:'bitcrusher',
      callback: x=>{this.crusher.bits.value = Math.floor(x)},
      //mapto: this.crusher.bits,
      x: 90, y:50, size: 0.8,
      min:2, max:16,
      link: 'crusher'
    })
    this.crusher_toggle.accentColor = [46,152,99]
    this.crusher.wet.value = 1

    this.glide_toggle =  this.gui.Momentary({
      label:'Glide',
      callback: (x)=>{this.isGlide = x}, //IDK how to implemement this in class
      x: 15, y:20, size: 0.8,
      link: 'glide'
    })
    this.glide_toggle.accentColor = [51,145,219]

    this.delayControl = function(x) {
      this.delay.feedback.value = stepper(x, 0 , 1 , [[0,0], [0.02, 0], [0.8,0.6], [1,1]])
      this.delay.wet.value = stepper(x , 0, 1, [[0,0], [0.02, 0], [0.04, 1], [1,1]])
      this.delaygain.factor.value = stepper(x , 0, 1, [[0,0], [0.02, 0], [0.04, 0.3], [0.4, 0.5], [1,1]])
      this.lfo.amplitude.value = stepper(x , 0, 1, [[0,0], [0.5, 0], [0.7, 0.5], [1,1]])
    }

    this.delay_knob = this.gui.Knob({
      label:'Delay Control',
      callback: (x)=>{this.delayControl(x)},
      x: 10, y: 50, size:0.8,
      min:0.001, max: 1, curve: 1,
      showValue: false,
      link: 'delayknob'
    })
    this.delay_knob.accentColor = [49,48,55]
    this.delay_knob.set( 0.0001 )

    this.wave_fader = this.gui.Slider({
      label:'wave',
      x: 39, y: 10, size: 2,
      min:0, max: 1,
      callback: (x)=>{this.pulseWav.width.value = stepper(x, 0, 1, [[0,0], [0.4, 0.6], [1,1]])},
      orientation: 'vertical',
      showValue: false, 
      link: 'wave',
      border: 12
    })
    this.wave_fader.accentColor = [247, 5, 5]
    this.wave_fader.borderColor = [20, 20, 20]
    this.wave_fader.set(0.5)

    this.freq_fader = this.gui.Slider({
      label:'freq',
      //callback: (x)=>{this.cutoff.value = stepper(x, 200, 1200, [[0,0], [0.6, 0.8], [1,1]])},
      callback: (x)=>{
        this.filterDepth.factor.value = x
        this.cutoff.value = x
      },
      x: 49, y: 10, size: 2,
      min:50, max: 2500, curve: 2,
      orientation: 'vertical',
      showValue: false,
      link: 'freq',
      border: 12
    })
    this.freq_fader.accentColor = [247, 5, 5]
    this.freq_fader.borderColor = [20, 20, 20]
    this.freq_fader.set(700)

    this.release_fader = this.gui.Slider({
      label:'release',
      callback: (x)=>{ 
        this.env.decay = stepper(x, 0.1, 5, [[0,0], [0.8, 0.5], [1,5]])
        this.env.release = stepper(x, 0.1, 30, [[0,0], [0.8, 0.5], [1,5]])
        this.vcf_env.decay = stepper(x, 0.1, 5, [[0,0], [0.8, 0.5], [1,5]])
        this.vcf_env.release = stepper(x, 0.1, 30, [[0,0], [0.8, 0.5], [1,5]])
      },
      x: 59, y: 10, size: 2,
      min:0.1, max: 1.5,
      orientation: 'vertical',
      showValue: false,
      link: 'release',
      border: 12
    })
    this.release_fader.accentColor = [247, 5, 5]
    this.release_fader.borderColor = [20, 20, 20]
    this.release_fader.set(0.8)

    this.resonance_knob = this.gui.Knob({
      label:'res',
      callback: (x)=>{ this.filter.Q.value = x},
      x: 49.5, y: 86, size:.5,
      min:0.99999, max: 30, curve: 2,
      showValue: false,
      link: 'res'
    })
    this.resonance_knob.accentColor = [49,48,55]
    this.resonance_knob.set( 1 )

    this.detune_knob = this.gui.Knob({
      label:'detune',
      callback: x=>{
        this.sawPitchShift.factor.value = stepper(x,0.99999,2,[[0,0],[.25,.02],[.45,.49],[.55,.51],[.75,.98],[1,1]])/2
        //console.log(stepper(x,0.99999,2,[[0,0],[.25,.02],[.45,.49],[.55,.51],[.75,.98],[1,1]]))
      },
      //mapto: this.tonePitchShift.factor,
      x: 22, y: 50, size:.5,
      min:0.99999, max: 2, curve: 1,
      showValue: false,
      link: 'detune'
    })
    this.detune_knob.accentColor = [49,48,55]
    this.detune_knob.set( 1 )

    this.speaker_knob = this.gui.Knob({
      label:'gain',
      callback: x=>{this.output.factor.value = x},
      x: 78, y: 50, size:.5,
      min:0, max: 0.1, curve: 2,
      showValue: false,
      link: 'gain'
    })
    this.speaker_knob.accentColor = [49,48,55]
    this.speaker_knob.set( 0.05 )

    //trigger playback of the loaded soundfile

    this.kick_trigger = this.gui.Button({
      label:'kick',
      callback: ()=>{ this.kickPlayer.triggerAttack( 'C4')},
      size: 1, border: 20,
      x:30, y:80, size: 1,
      link: 'kick'
    })
    this.kick_trigger.accentColor = [20,20,20]

    this.snare_trigger = this.gui.Button({
      label:'snare',
      callback: ()=>{ this.snarePlayer.triggerAttack( 'C4')},
      size: 1, border: 20,
      x:70, y:80, size: 1,
      link: 'snare',
    })
    this.snare_trigger.accentColor = [20,20,20]

    this.gui_elements = [this.distortion_toggle, this.crusher_toggle, 
      this.glide_toggle, this.delay_knob, this.wave_fader, 
      this.freq_fader, this.release_fader, this.resonance_knob,
      this.detune_knob, this.speaker_knob, this.kick_trigger,
      this.snare_trigger]

  }


  initPolyGui(superClass, gui) {
    this.gui = gui
    this.super = superClass
    this.distortion_toggle =  this.gui.Toggle({
      label:'Accent',
      callback: (x)=>{this.super.set('dist.wet' , x)},
      x: 85, y:20, size: 0.8,
      link: 'dist'
    })
    this.distortion_toggle.accentColor = [51,145,219]
    this.super.set('dist.wet.value' , 0)

    this.crusher_toggle =  this.gui.Toggle({
      label:'bitcrusher',
      callback: (x)=>{this.super.set('crusher.wet' , x)},
      x: 90, y:50, size: 0.8,
      link: 'crusher'
    })
    this.crusher_toggle.accentColor = [46,152,99]
    this.super.set('crusher.wet.value',  0)

    this.glide_toggle =  this.gui.Toggle({
      label:'Glide',
      callback: (x)=>{this.super.set('isGlide' , x)},
      x: 15, y:20, size: 0.8,
      link: 'glide'
    })
    this.glide_toggle.accentColor = [51,145,219]

    this.delayControl = function(x) {
      this.super.set('delay.feedback.value' , stepper(x, 0 , 1 , [[0,0], [0.02, 0], [0.8,0.6], [1,1]]))
      this.super.set('delay.wet.value' , stepper(x , 0, 1, [[0,0], [0.02, 0], [0.04, 1], [1,1]]))
      this.super.set('delaygain.factor.value' , stepper(x , 0, 1, [[0,0], [0.02, 0], [0.04, 0.3], [0.4, 0.5], [1,1]]))
      this.super.set('lfo.amplitude.value' , stepper(x , 0, 1, [[0,0], [0.5, 0], [0.7, 0.5], [1,1]]))
    }

    this.delay_knob = this.gui.Knob({
      label:'Delay Control',
      callback: (x)=>{this.delayControl(x)},
      x: 10, y: 50, size:0.8,
      min:0.001, max: 1, curve: 1,
      showValue: false,
      link: 'delayknob'
    })
    this.delay_knob.accentColor = [49,48,55]
    this.delay_knob.set( 0.0001 )

    this.wave_fader = this.gui.Slider({
      label:'wave',
      x: 39, y: 10, size: 2,
      min:0, max: 1,
      callback: (x)=>{this.super.set('pulseWav.width.value' , stepper(x, 0, 1, [[0,0], [0.4, 0.6], [1,1]]))},
      orientation: 'vertical',
      showValue: false, 
      link: 'wave',
      border: 12
    })
    this.wave_fader.accentColor = [247, 5, 5]
    this.wave_fader.borderColor = [20, 20, 20]
    this.wave_fader.set(0.5)

    this.freq_fader = this.gui.Slider({
      label:'freq',
      //callback: (x)=>{this.cutoff.value = stepper(x, 200, 1200, [[0,0], [0.6, 0.8], [1,1]])},
      callback: (x)=>{
        this.super.set('filterDepth.factor.value' , x)
        this.super.set('cutoff.value' , x)
      },
      mapto: this.cutoff,
      x: 49, y: 10, size: 2,
      min:50, max: 2500, curve: 2,
      orientation: 'vertical',
      showValue: false,
      link: 'freq',
      border: 12
    })
    this.freq_fader.accentColor = [247, 5, 5]
    this.freq_fader.borderColor = [20, 20, 20]
    this.freq_fader.set(700)

    this.release_fader = this.gui.Slider({
      label:'release',
      callback: (x)=>{ 
        this.super.set('env.decay' ,stepper(x, 0.01, 1, [[0,0], [0.8, 0.5], [1,5]]))
        this.super.set('env.release' , stepper(x, 0.1, 25, [[0,0], [0.8, 0.5], [1,5]]))
        this.super.set('vcf_env.decay' , stepper(x, 0.01, 1, [[0,0], [0.8, 0.5], [1,5]]))
        this.super.set('vcf_env.release' , stepper(x, 0.1, 25, [[0,0], [0.8, 0.5], [1,5]]))
      },
      x: 59, y: 10, size: 2,
      min:0.1, max: 25,
      orientation: 'vertical',
      showValue: false,
      link: 'release',
      border: 12
    })
    this.release_fader.accentColor = [247, 5, 5]
    this.release_fader.borderColor = [20, 20, 20]
    this.release_fader.set(0.8)

    this.resonance_knob = this.gui.Knob({
      label:'res',
      callback: (x)=>{ this.super.set('filter.Q.value' , x)},
      x: 49.5, y: 86, size:.25,
      min:0.99999, max: 30, curve: 2,
      showValue: false,
      link: 'res'
    })
    this.resonance_knob.accentColor = [49,48,55]
    this.resonance_knob.set( 1 )

    this.detune_knob = this.gui.Knob({
      label:'detune',
      callback: x=>{
        this.super.set('tonePitchShift.factor' , stepper(x,0.99999,2,[[0,0],[.25,.02],[.45,.49],[.55,.51],[.75,.98],[1,1]]))
        console.log(stepper(x,0.99999,2,[[0,0],[.25,.02],[.45,.49],[.55,.51],[.75,.98],[1,1]]))
      },
      //callback: (x)=>{ this.super.set('tonePitchShift.factor' , x)},
      x: 22, y: 50, size:.25,
      min:0.99999, max: 2, curve: 1,
      showValue: false,
      link: 'detune'
    })
    this.detune_knob.accentColor = [49,48,55]
    this.detune_knob.set( 1 )

    this.speaker_knob = this.gui.Knob({
      label:'gain',
      callback: (x)=>{ this.super.set('output.factor' , x)},
      x: 78, y: 50, size:.25,
      min:0, max: 0.1, curve: 2,
      showValue: false,
      link: 'gain'
    })
    this.speaker_knob.accentColor = [49,48,55]
    this.speaker_knob.set( 0.05 )

    //sampler - beatpads

    this.kick_trigger = this.gui.Button({
      label:'kick',
      callback: ()=>{ this.kickPlayer.triggerAttack( 'C4')},
      size: 1, border: 20,
      x:30, y:80, size: 1,
      link: 'kick'
    })
    this.kick_trigger.accentColor = [20,20,20]

    this.snare_trigger = this.gui.Button({
      label:'snare',
      callback: ()=>{ this.snarePlayer.triggerAttack( 'C4')},
      size: 1, border: 20,
      x:70, y:80, size: 1,
      link: 'snare',
    })
    this.snare_trigger.accentColor = [20,20,20]
  }
}

/*
Diffuseur

convolution reverb
* input->eq3->convolver->output

methods:
- load(url) loads an IR
- filterIR: applies a lowpass to the IR, destructive
- highpassIR: applies a highpass to the IR, destructive
- stretchIR: stretches the IR
- ampIR: amplifies the IR into a softclipper
- setEQ(low,mid,hi) in dB
- setEQBand(low,hi)

properties:
- gain.factor.value
*/

;
;

class Diffuseur {
  constructor(gui = null) {
    this.gui = gui;
    this.input = new Tone.Multiply(1);
    this.eq = new Tone.EQ3
    this.convolver = new Tone.Convolver();
    this.output = new Tone.Multiply(1);
    // Buffer
    this.buffer = null;
    // Audio connections
    this.input.connect(this.eq);
    this.eq.connect( this.convolver);
    this.convolver.connect(this.output);

    this.sampleFiles = {
          plate: './audio/plate_reverb.mp3',
          spring: './audio/spring_reverb.mp3',
          hall:   './audio/hall_reverb.mp3',
          ampeg: './audio/ampeg_amp.mp3',
          marshall: './audio/marshall_amp.mp3',
          vox:   './audio/voxAC30_amp.mp3',
          dreadnought: './audio/dreadnought_guitar.mp3',
          taylor: './audio/taylor_guitar.mp3',
          guitar:   './audio/custom_guitar.mp3',
          bell3:  'berklee/bell_mallet_2.mp3',
          horn: 'berklee/casiohorn2.mp3',
          chotone:  'berklee/chotone_c4_!.mp3',
          voice:  'berklee/femalevoice_aa_Db4.mp3',
          kalimba:  'berklee/Kalimba_1.mp3',
          dreamyPiano:  'salamander/A5.mp3',
          softPiano:  'salamander/A4.mp3',
          piano:  'salamander/A3.mp3',
          casio: 'casio/C2.mp3'
        }
  }

  load(url = null) {
    if(url === null){
      // Create a file input element programmatically
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'audio/*'; // Accept only audio files

        // Handle file selection
        fileInput.onchange = (event) => {
            const file = event.target.files[0];
            if (!file) {
                console.log("No file selected");
                return;
            }

            // Use FileReader to read the file as a Data URL
            const fileReader = new FileReader();
            fileReader.onload = () => {
                this.buffer = new Tone.Buffer(fileReader.result)
                this.convolver.buffer = this.buffer
                console.log("Audio loaded into diffuseur");
                return
            };
            fileReader.readAsDataURL(file);
            
        };

        // Trigger the file dialog
        fileInput.click();
    }

    // If the `url` is a number, treat it as an index into the `sampleFiles` object
    if (typeof url === 'number') {
        // Convert the keys of the `sampleFiles` object to an array
        const fileKeys = Object.keys(this.sampleFiles);
        url = Math.floor(url) % fileKeys.length; // Calculate a valid index
        url = fileKeys[url]; // Reassign `url` to the corresponding filename
    }

    // Check if the `url` exists in `sampleFiles`
    if (url in this.sampleFiles) {
        console.log(`Diffuseur loading ${url}`);
        this.sample = url; // Store the selected sample
    } else {
        console.error(`The sample "${url}" is not available.`);
        return;
    }

    // Load the buffer and assign it to `this.buffer` and `this.convolver.buffer`
    return new Promise((resolve, reject) => {
        new Tone.Buffer(this.sampleFiles[url], (buffer) => {
            this.buffer = buffer;
            this.convolver.buffer = buffer;
            resolve();
        }, reject);
    });
}


  async filterIR(filterFreq) {
    if (!this.buffer) {
      console.error('Buffer not loaded.');
      return;
    }
    
    const context = Tone.getContext().rawContext;
    const duration = this.buffer.duration;
    const offlineContext = new OfflineAudioContext(2, duration * context.sampleRate, context.sampleRate);
    
    // Use the buffer directly from Tone.Buffer
    const decodedData = this.buffer.get();

    const source = offlineContext.createBufferSource();
    source.buffer = decodedData; // Use the buffer directly.
    
    // Example transformation: apply a filter (this could be more complex, including stretching)
    const filter = offlineContext.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = filterFreq;
    
    source.connect(filter);
    filter.connect(offlineContext.destination);
    
    source.start(0);
    
    return new Promise((resolve, reject) => {
      offlineContext.startRendering().then((renderedBuffer) => {
        // Use the rendered buffer as a new Tone.Buffer
        const newBuffer = new Tone.Buffer(renderedBuffer);
        this.buffer = newBuffer
        this.convolver.buffer = newBuffer; // Load it into the convolver
        resolve();
      }).catch(reject);
    });
  }//filter

  async stretchIR(stretchAmt) {
    if (!this.buffer) {
      console.error('Buffer not loaded.');
      return;
    }
    
    const context = Tone.getContext().rawContext;
    const duration = this.buffer.duration;
    const offlineContext = new OfflineAudioContext(2, duration * stretchAmt * context.sampleRate, context.sampleRate);
    
    // Use the buffer directly from Tone.Buffer
    const decodedData = this.buffer.get();

    const source = offlineContext.createBufferSource();
    source.buffer = decodedData; // Use the buffer directly.

    // Apply time-stretching by adjusting the playback rate
    source.playbackRate.value = 1/stretchAmt; // Adjust the playback rate based on the stretchVal
    source.connect(offlineContext.destination);
    source.start(0);
    
    return new Promise((resolve, reject) => {
      offlineContext.startRendering().then((renderedBuffer) => {
        // Use the rendered buffer as a new Tone.Buffer
        const newBuffer = new Tone.Buffer(renderedBuffer);
        this.buffer = newBuffer
        this.convolver.buffer = newBuffer; // Load it into the convolver
        resolve();
      }).catch(reject);
    });
  }//stretch

  async highpassIR(filterFreq) {
    if (!this.buffer) {
      console.error('Buffer not loaded.');
      return;
    }
    
    const context = Tone.getContext().rawContext;
    const duration = this.buffer.duration;
    const offlineContext = new OfflineAudioContext(2, duration * context.sampleRate, context.sampleRate);
    
    // Use the buffer directly from Tone.Buffer
    const decodedData = this.buffer.get();

    const source = offlineContext.createBufferSource();
    source.buffer = decodedData; // Use the buffer directly.
    
    // Example transformation: apply a filter (this could be more complex, including stretching)
    const filter = offlineContext.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = filterFreq;
    
    source.connect(filter);
    filter.connect(offlineContext.destination);
    
    source.start(0);
    
    return new Promise((resolve, reject) => {
      offlineContext.startRendering().then((renderedBuffer) => {
        // Use the rendered buffer as a new Tone.Buffer
        const newBuffer = new Tone.Buffer(renderedBuffer);
        this.buffer = newBuffer
        this.convolver.buffer = newBuffer; // Load it into the convolver
        resolve();
      }).catch(reject);
    });
  }//highpass

  //NOTE: changing amp and waveshaping never worked as expected
  // async ampIR(gainVal) {
  //   if (!this.buffer) {
  //     console.error('Buffer not loaded.');
  //     return;
  //   }
    
  //   const context = Tone.getContext().rawContext;
  //   const duration = this.buffer.duration;
  //   const offlineContext = new OfflineAudioContext(2, duration * context.sampleRate, context.sampleRate);
    
  //   // Use the buffer directly from Tone.Buffer
  //   const decodedData = this.buffer.get();

  //   const source = offlineContext.createBufferSource();
  //   source.buffer = decodedData; // Use the buffer directly.
    
  //   // Create a Multiply node
  //   const gain = offlineContext.createGain();
  //   gain.gain.value = gainVal
  //   console.log(gainVal, gain.gain.value)

  //   // Correct setup for WaveShaper node
  //   const waveShaper = offlineContext.createWaveShaper();
  //   waveShaper.curve = this.generateWaveShaperCurve(256); // Example length, adjust as needed
  //   waveShaper.oversample = '4x'; // Optional: Apply oversampling to reduce aliasing


  //   // Connect the nodes
  //   source.connect(gain);
  //   source.connect(waveShaper);
  //   waveShaper.connect(offlineContext.destination);
    
  //   source.start(0);
    
  //   return new Promise((resolve, reject) => {
  //     offlineContext.startRendering().then((renderedBuffer) => {
  //       // Use the rendered buffer as a new Tone.Buffer
  //       const newBuffer = new Tone.Buffer(renderedBuffer);
  //       this.buffer = newBuffer
  //       this.convolver.buffer = newBuffer; // Load it into the convolver
  //       resolve();
  //     }).catch(reject);
  //   });
  // }//amp

  // generateWaveShaperCurve(length = 256) {
  //   const curve = new Float32Array(length);
  //   for (let i = 0; i < length; i++) {
  //     let x = (i * 2) / length - 1; //convert to -1,1
  //     //curve[i] = Math.tanh(x*128); // Adjust this function as needed
  //     curve[i] = x>0 ? 1 : -0; 
  //     //curve[i] = x
  //   }
  //   console.log(curve)
  //   return curve;
  // }

  setEQ(low,mid,hi){
    this.eq.high.value = hi
    this.eq.mid.value = mid
    this.eq.low.value = low
  }
  setEQBand(low,hi){
    if(low < 10 || hi < 10){
      console.log('EQ bands are in Hz')
      return;
    }
    this.eq.highFrequency.value = hi
    this.eq.lowFrequency.value = low
  }

  listSamples(){
        const fileKeys = Object.keys(this.sampleFiles);
        console.log(fileKeys)
    }


  /**
   * Connect the output to a destination.
   * @param {Tone.Signal | AudioNode} destination - The destination to connect to.
   */
  connect(destination) {
    if (destination.input) {
      this.output.connect(destination.input);
    } else {
      this.output.connect(destination);
    }
  }

  /**
   * Disconnect the output from a destination.
   * @param {Tone.Signal | AudioNode} destination - The destination to disconnect from.
   */
  disconnect(destination) {
    if (destination.input) {
      this.output.disconnect(destination.input);
    } else {
      this.output.disconnect(destination);
    }
  }
}


window.DronePresets = {
  "default": {
    "vco_mix": 0.4096000000000002,
    "detune": 1.9940090000000001,
    "cutoff": 120.9999999999993,
    "vcf env": 1057.9999999999998,
    "Q": 2.047999999999998,
    "key vcf": 1,
    "a": 0.005,
    "d": 0.1716759999999987,
    "s": 0.6723999999999998,
    "r": 1.6809999999999994,
    "a1": 0.005,
    "d1": 1.159696,
    "s1": 0.6888999999999997,
    "r1": 0.840999999999999,
    "lfo": 4.801999999999989,
    "vibrato": 0,
    "tremolo": 0
  },
  "ether": {
    "vco_mix": 0.6724000000000004,
    "detune": 1.9940090000000001,
    "cutoff": 168.99999999999915,
    "vcf env": 1250,
    "Q": 4.231999999999999,
    "key vcf": 1,
    "a": 0.005,
    "d": 0.1716759999999987,
    "s": 0.4224999999999996,
    "r": 3.8440000000000003,
    "a1": 0.005,
    "d1": 1.159696,
    "s1": 0.2915999999999996,
    "r1": 2.809,
    "lfo": 4.801999999999989,
    "vibrato": 0.007290000000000004,
    "tremolo": 0
  },
  "tremPad": {
    "vco_mix": 0.4355999999999999,
    "detune": 1.009409,
    "cutoff": 1023.999999999999,
    "vcf env": 1200.5,
    "Q": 4.802,
    "key vcf": 1,
    "a": 0.5,
    "d": 9.9006989999999995,
    "s": 1,
    "r": 20,
    "a1": 0.5,
    "d1": 10,
    "s1": 1,
    "r1": 20,
    "lfo": 1.7999999999999925,
    "vibrato": 0,
    "tremolo": 0.5329000000000006
  }
};;

/*
Drone
3 oscillator synth with cross-modulation




*/

;
;
;
;

class Drone extends MonophonicTemplate{
	constructor(){
		super()
		this.presets = DronePresets
		this.name = 'Drone'

		this.frequency = new Tone.Signal(100)
		this.frequencyCV = new Tone.Signal()
		this.frequency_scalar = new Tone.Multiply(1)
		this.detune_scalar = new Tone.Multiply(1)
		this.vco_1 = new Tone.PulseOscillator().start()
		this.vco_2 = new Tone.PulseOscillator().start()
		this.frequency.connect(this.frequency_scalar)
		this.frequencyCV.connect(this.frequency_scalar.factor)
		this.frequency_scalar.connect(this.vco_1.frequency)
		this.frequency_scalar.connect(this.detune_scalar)
		this.detune_scalar.connect(this.vco_2.frequency)

		this.crossfade = new Tone.CrossFade()
		this.crossfade_lfo_depth = new Tone.Multiply()
		this.vco_1.connect( this.crossfade.a)
		this.vco_2.connect( this.crossfade.b)

		this.vcf = new Tone.Filter({type:'lowpass', rolloff:-24, Q:0, cutoff:3000})
		this.crossfade.connect(this.vcf)
		this.crossfade_constant = new Tone.Signal(0)
		this.crossfade_lfo_depth.connect(this.crossfade.fade)
		this.crossfade_constant.connect(this.crossfade.fade)

		this.vca = new Tone.Multiply()
		this.lfo_vca = new Tone.Multiply(1)
		this.lfo_vca_constant = new Tone.Signal(1)
		this.panner = new Tone.Panner(0)
		this.output = new Tone.Multiply(.25)
		this.vcf.connect(this.lfo_vca)
		this.lfo_vca.connect(this.vca)
		this.lfo_vca_constant.connect(this.lfo_vca.factor)
		this.vca.connect(this.panner)
		this.panner.connect(this.output)

		//envelopes
		this.env = new Tone.Envelope()
		this.velocity = new Tone.Signal(1)
		this.velocity_depth = new Tone.Multiply(1)
		this.env.connect(this.velocity_depth)
		this.velocity_depth.connect(this.vca.factor)
		this.velocity.connect(this.velocity_depth.factor)

		//vcf
		this.cutoffSig = new Tone.Signal(1000)
		this.cutoffSig.connect(this.vcf.frequency)
		this.cutoffCV = new Tone.Signal()
		this.cutoffCV.connect(this.vcf.frequency)
		this.keyTracking = new Tone.Multiply(.1)
		this.frequency.connect(this.keyTracking)
		this.keyTracking.connect(this.vcf.frequency)
		this.vcf_env = new Tone.Envelope()
		this.vcf_env_depth = new Tone.Multiply()
		this.vcf_env.connect(this.vcf_env_depth)
		this.vcf_env_depth.connect(this.vcf.frequency)

		this.lfo = new Tone.Oscillator(.5).start()
		this.vca_constant = new Tone.Signal(1)
		this.amp_lfo_depth = new Tone.Multiply(0)
		this.lfo.connect(this.amp_lfo_depth)
		this.amp_lfo_depth.connect(this.lfo_vca.factor)
		this.pitch_lfo_depth = new Tone.Multiply(0)
		this.lfo.connect(this.pitch_lfo_depth)
		this.lfo.connect(this.crossfade_lfo_depth)
		this.frequency_constant = new Tone.Signal(1)
		this.pitch_lfo_depth.connect(this.frequency_scalar.factor)
		this.frequency_constant.connect(this.frequency_scalar.factor)

		//no PWM to prevent errors when vco is not set to pulse
		this.pwm_lfo_depth = new Tone.Multiply()
		this.lfo.connect(this.pwm_lfo_depth)

		//this.pwm_lfo_depth.connect(this.vco_1.width)
		//this.pwm_lfo_depth.connect(this.vco_2.width)
  }

  //TRIGGER METHODS
  triggerAttack = function(val, vel=100, time=null){
  	let freq = Tone.Midi(val).toFrequency()
  	vel = vel/127
    if(time){
      this.frequency.setValueAtTime(freq,time)
      this.env.triggerAttack(time)
      this.vcf_env.triggerAttack(time)
      this.velocity.setValueAtTime(Math.pow(vel,2),time)
    } else{
      this.frequency.value = freq
      this.env.triggerAttack()
      this.vcf_env.triggerAttack()
      this.velocity.value =Math.pow(vel,2) 
    }
  }
  triggerRelease = function(val, time=null){
    if(time){
      this.env.triggerRelease(time)
      this.vcf_env.triggerRelease(time)
    } else{
      this.env.triggerRelease()
      this.vcf_env.triggerRelease()
    }
  }
  triggerAttackRelease = function(val, vel=100, dur=0.01, time=null){
    val = Tone.Midi(val).toFrequency()
    vel = vel/127
    if(time){
      this.frequency.setValueAtTime(val,time)
      this.env.triggerAttackRelease(dur,time)
      this.vcf_env.triggerAttackRelease(dur,time)
      this.velocity.setValueAtTime(Math.pow(vel,2),time)
    } else{
      this.frequency.value = val
      this.env.triggerAttackRelease(dur)
      this.vcf_env.triggerAttackRelease(dur)
      this.velocity.value =Math.pow(vel,2) 
    }
  }//attackRelease

  shapeVco(vcoNum, shape, amp=2, curve=1, isEven=1 ){
  	//console.log(vcoNum,shape)
		let partials = []
	  for(let i=0;i<64;i++){
	    partials.push(1/Math.pow(i+1,curve)*16*(i%2<(2-isEven))*Math.abs(1-Math.sin(i*Math.PI*shape+Math.PI/2)*amp))
	  }
	  if(vcoNum === 0) {
	  	//console.log(shape, this.vco_1.partials)
	  	this.vco_1.partials = partials
	  	//console.log('post ', this.vco_1.partials)
	  }
	  else this.vco_2.partials = partials 
  }

  setHighpass(val){
  	if(this.super !== null){
  		this.super.hpf.frequency.value = val
  	}
  }

  initGui(gui, x=10,	y=10){
  	// if(this.gui_elements.length > 0){
  	// 	console.log("initGui is called when a synth is created.\n Call synth.showGui() to see it.")
  	// 	return;
  	// }
  	this.gui = gui
  	this.x = x
  	this.y = y
  	this.vco_mix = this.createKnob('vco_mix', 5, 5, 0, 1, 0.75, [200,50,0],x=>this.crossfade_constant.value= x);
  	this.detune = this.createKnob('detune', 15, 5, 1, 2, 0.75, [200,50,0],x=>this.detune_scalar.factor.value = x);
  	this.cutoff = this.createKnob('cutoff', 25, 5, 0, 10000, 0.75, [200,50,0],x=>this.cutoffSig.value = x);
  	this.vcf_env_knob = this.createKnob('vcf env', 35, 5, 0, 5000, 0.75, [200,50,0],x=>this.vcf_env_depth.factor.value = x);
  	this.vcf_Q_knob = this.createKnob('Q', 45, 5, 0, 20, 0.75, [200,50,0],x=>this.vcf.Q.value = x);
  	this.keyTracking_knob = this.createKnob('key vcf', 55, 5, 0, 1, 0.75, [200,50,0],x=>this.keyTracking.factor.value = x);
  	this.highpass_knob = this.createKnob('hpf', 65, 5, 10, 3000, 0.75, [200,50,0],x=>this.setHighpass(x));
  	this.attack_knob = this.createKnob('a', 5, 45, 0.005, .5, 0.5, [200,50,0],x=>this.env.attack = x);
  	this.decay_knob = this.createKnob('d', 15, 45, 0.01, 10, 0.5, [200,50,0],x=>this.env.decay = x);
  	this.sustain_knob = this.createKnob('s', 25, 45, 0, 1, 0.5, [200,50,0],x=>this.env.sustain = x);
  	this.release_knob = this.createKnob('r', 35, 45, 0, 20, 0.5, [200,50,0],x=>this.env.release = x);
  	this.vcf_attack_knob = this.createKnob('a', 5, 70, 0.005, .5, 0.5, [200,50,0],x=>this.vcf_env.attack = x);
  	this.vcf_decay_knob = this.createKnob('d', 15, 70, 0.01, 10, 0.5, [200,50,0],x=>this.vcf_env.decay = x);
  	this.vcf_sustain_knob = this.createKnob('s', 25, 70, 0, 1, 0.5, [200,50,0],x=>this.vcf_env.sustain = x);
  	this.vcf_release_knob = this.createKnob('r', 35, 70 , 0, 20, 0.5, [200,50,0],x=>this.vcf_env.release = x);
  	this.lfo_freq_knob = this.createKnob('lfo', 45, 65, 0, 20, 0.5, [200,50,0],x=>this.lfo.frequency.value = x);
  	this.lfo_vibrato = this.createKnob('vibrato', 55, 65, 0, .1, 0.5, [200,50,0],x=>this.pitch_lfo_depth.factor.value = x);
  	this.lfo_tremolo = this.createKnob('tremolo', 65, 65, 0, 1, 0.5, [200,50,0],x=>this.amp_lfo_depth.factor.value = x);
  	this.lfo_blend_knob = this.createKnob('blend', 75, 65, 0, 1, 0.5, [200,50,0],x=>this.crossfade_lfo_depth.factor.value = x);

  	//this.pan_knob = this.createKnob('pan', 85, 65, 0, 1, 0.5, [200,50,0],x=>this.crossfade_lfo_depth.factor.value = x);
  	this.vco1_shape_knob = this.createKnob('shape1', 75, 25, 0,1, 0.6, [200,50,0],x=>this.shapeVco(0, x*2+1));
  	this.vco2_shape_knob = this.createKnob('shape2', 85, 25, 0,1, 0.6, [200,50,0],x=>this.shapeVco(1, x*2+1));
  	
  	this.pan_knob = this.createKnob('pan', 85, 65, 0, 1, 0.5, [200,50,0],x=>{this.super.pan(x)});


  	this.gui_elements = [ this.vco_mix, this.detune, this.cutoff, this.vcf_env_knob, this.vcf_Q_knob, this.keyTracking_knob, 
  		this.highpass_knob, 
  		this.attack_knob, this.decay_knob, this.sustain_knob, this.release_knob, this.vcf_attack_knob, this.vcf_decay_knob, this.vcf_sustain_knob, this.vcf_release_knob, this.lfo_freq_knob, this.lfo_vibrato, this.lfo_tremolo, this.lfo_blend_knob
  		, this.pan_knob, this.vco1_shape_knob, this.vco2_shape_knob
  		];
  }
}


window.DrumSamplerPresets = {
  "default": {
    "Kick": 0.5,
    "Snare": 0.5,
    "Hihat": 0.4,
    "Toms": 0.5,
    "decay": 1,
    "decay1": 1,
    "decay12": 1,
    "Output": 2,
    "Dry Kick": 0.5,
    "rate": 1,
    "rate1": 1,
    "rate12": 1,
    "1 Rate": 1,
    "2 Rate": 1,
    "3 Rate": 1,
    "Threshold": -32.5,
    "Ratio": 1,
    "Distort": 0.1,
    "Closed Decay": 0.16839999999999972,
    "Open Decay": 1.9801,
    "kit": "Acoustic"
  },
  "electro": {
    "Kick": 0.7,
    "Snare": 0.5,
    "Hihat": 0.3,
    "Toms": 0.5,
    "Output": 3,
    "Dry Kick": 0.3,
    "Kick Rate": 1,
    "Snare Rate": 1,
    "Hihat Rate": 1.4,
    "Tom1 Rate": 1,
    "Tom2 Rate": 1,
    "Tom3 Rate": 1,
    "Threshold": -32.5,
    "Ratio": 4.5,
    "Distort": 0.3,
    "Hat Decay": 0.505,
    "kit": "Techno",
    "Kick1": 1,
    "Snare1": 1,
    "Hihat1": 0.8999999999999999,
    "Toms1": 0.23000000000000007,
    "Output1": 0.9599999999999991,
    "Dry Kick1": 0.1399999999999997,
    "Kick Rate1": 0.8999999999999999,
    "Snare Rate1": 0.8799999999999999,
    "Hihat Rate1": 1.1,
    "Tom1 Rate1": 1.4000000000000004,
    "Tom2 Rate1": 1.3000000000000003,
    "Tom3 Rate1": 1.12,
    "Threshold1": -28.649999999999995,
    "Ratio1": 7.459999999999997,
    "Distort1": 0.17,
    "Hat Decay1": 0.11889999999999983,
    "kit1": "CR78"
  },
  "breakbeat": {
    "Kick": 0.5,
    "Snare": 0.5,
    "Hihat": 0.5,
    "Toms": 0.5,
    "Output": 2,
    "Dry Kick": 0,
    "Kick Rate": 1,
    "Snare Rate": 1,
    "Hihat Rate": 1,
    "Tom1 Rate": 1,
    "Tom2 Rate": 1,
    "Tom3 Rate": 1,
    "Threshold": -32.5,
    "Ratio": 10.5,
    "Distort": 0.5,
    "Hat Decay": 0.505,
    "Kick1": 1,
    "Snare1": 1,
    "Hihat1": 0.7199999999999998,
    "Toms1": 0.7900000000000005,
    "Output1": 2.3999999999999995,
    "Dry Kick1": 0,
    "Kick Rate1": 1.06,
    "Snare Rate1": 1.12,
    "Hihat Rate1": 0.8399999999999999,
    "Tom1 Rate1": 1.1600000000000001,
    "Tom2 Rate1": 1.1400000000000001,
    "Tom3 Rate1": 1.1,
    "Threshold1": -28.649999999999995,
    "Ratio1": 12.210000000000006,
    "Distort1": 0.04,
    "Hat Decay1": 0.19809999999999958,
    "kit": "breakbeat8"
  },
  "techno": {
    "Kick": 1,
    "Snare": 1,
    "Hihat": 0.6999999999999997,
    "Toms": 0.6099999999999997,
    "decay": 0.2599999999999998,
    "decay1": 0.04999999999999981,
    "decay12": 0.004,
    "Output": 0.9999999999999991,
    "Dry Kick": 0,
    "rate": 0.8599999999999999,
    "rate1": 0.819999999999999,
    "rate12": 1,
    "1 Rate": 2,
    "2 Rate": 2,
    "3 Rate": 2,
    "Threshold": -29.20000000000002,
    "Ratio": 9.36,
    "Distort": 0.1999999999999997,
    "Closed Decay": 0.07859999999999995,
    "Open Decay": 2,
    "kit": "Techno"
  },
  "snappy": {
    "Kick": 0.5,
    "Snare": 0.5,
    "Hihat": 0.5,
    "Toms": 0.5,
    "Output": 2,
    "Dry Kick": 0.5,
    "Kick Rate": 1,
    "Snare Rate": 1,
    "Hihat Rate": 1,
    "Tom1 Rate": 1,
    "Tom2 Rate": 1,
    "Tom3 Rate": 1,
    "Threshold": -32.5,
    "Ratio": 10.5,
    "Distort": 0.5,
    "Hat Decay": 0.505,
    "kit": "LINN",
    "Kick1": 1,
    "Snare1": 0.7299999999999998,
    "Hihat1": 0.5399999999999996,
    "Toms1": 0.4499999999999995,
    "Output1": 3.3199999999999994,
    "Dry Kick1": 0,
    "Kick Rate1": 1.1400000000000001,
    "Snare Rate1": 1.3800000000000003,
    "Hihat Rate1": 1.1400000000000001,
    "Tom1 Rate1": 1.6800000000000006,
    "Tom2 Rate1": 0.52,
    "Tom3 Rate1": 0.21999999999999936,
    "Threshold1": -28.649999999999995,
    "Ratio1": 1,
    "Distort1": 0.09999999999999999,
    "Hat Decay1": 0.08919999999999953,
    "kit1": "KPR77"
  },
  "linn": {
    "Kick": 1,
    "Snare": 1,
    "Hihat": 0.51,
    "Toms": 1,
    "decay": 0.2599999999999998,
    "decay1": 0.45000000000000007,
    "decay12": 0.5,
    "Output": 1.2799999999999994,
    "Dry Kick": 0,
    "rate": 0.8799999999999999,
    "rate1": 1.2000000000000002,
    "rate12": 0.7999999999999998,
    "1 Rate": 1,
    "2 Rate": 1,
    "3 Rate": 1,
    "Threshold": -29.20000000000002,
    "Ratio": 6.129999999999996,
    "Distort": 0.09999999999999969,
    "Closed Decay": 0.059,
    "Open Decay": 1.1045000000000003,
    "kit": "LINN"
  }
};;

/**
 * 
 * player -> vca -> comp -> distortion -> output
 * 
 * each voice has its own env and vca
 * 
 * hihat simulates open and closed:
 * 
 * hihat -> hatVca (for open/closed) -> hihat_vca (overall level) -> comp, etc.
 * openEnv -> openHatChoke(vca) -> hatVca.factor
 * closedEnv -> hatVca.factor
 * 
 * kick has a dry output pre-comp and distortion
 */

;
;
;



;
/**
 * DrumSampler class extends DrumTemplate to create a drum sampler with various sound manipulation features.
 * It loads and triggers different drum samples based on the selected kit.
 * 
 * extends DrumTemplate
 */
class DrumSampler extends DrumTemplate{
  constructor(kit = "default", gui=null) {
    super()
    this.gui = gui
    this.presets = DrumSamplerPresets
    this.name = "DrumSampler"
    this.kit = kit
    this.drumkitList = ["LINN", "Techno", "TheCheebacabra1", "TheCheebacabra2", "acoustic-kit", "breakbeat13", "breakbeat8", "breakbeat9", "4OP-FM", "Bongos", "CR78", "KPR77", "Kit3", "Kit8"]
    //
    this.closedEnv = new Tone.Envelope({attack:0.0,decay:.5,sustain:0,release:.4})
    this.openEnv = new Tone.Envelope({attack:0.0,decay:1,sustain:0,release:.4})
    this.hatVca = new Tone.Multiply()
    this.openHatChoke = new Tone.Multiply()
    this.comp = new Tone.Compressor(-20,4)
    this.distortion = new Tone.Distortion(.5)
    this.output = new Tone.Multiply(0.8);
    this.dry_kick = new Tone.Multiply(0.)
    //
    this.kickEnv = new Tone.Envelope(0.0, 1, 1, 10)
    this.kick_vca = new Tone.Multiply()
    this.kick_gain = new Tone.Multiply(1)
    this.kick = new Tone.Player().connect(this.kick_vca)
    this.snareEnv = new Tone.Envelope(0.0, 1, 1, 10)
    this.snare_vca = new Tone.Multiply()
    this.snare_gain = new Tone.Multiply(1)
    this.snare = new Tone.Player().connect(this.snare_vca)
    this.hihat_vca = new Tone.Multiply(.9)
    this.hihat = new Tone.Player().connect(this.hihat_vca)
    //switched Toms to arrays
    this.tom = []
    this.tomEnv = []
    this.tom_vca = []
    this.tom_gain = []
    for(let i=0;i<3;i++) {
      this.tomEnv.push(new Tone.Envelope(0.0, 1, 1, 10))
      this.tom_vca.push( new Tone.Multiply() )
      this.tom_gain.push( new Tone.Multiply(.8) )
      this.tom.push( new Tone.Player() )
    }
    for(let i=0;i<3;i++) {
      this.tom[i].connect( this.tom_vca[i] ) 
      this.tomEnv[i].connect( this.tom_gain[i] )
      this.tom_gain[i].connect( this.tom_vca[i].factor )
      this.tom_vca[i].connect(this.comp)
    }
    //
    this.kickEnv.connect( this.kick_gain)
    this.kick_gain.connect( this.kick_vca.factor)
    this.kick_vca.connect(this.comp)
    this.snareEnv.connect( this.snare_gain)
    this.snare_gain.connect( this.snare_vca.factor)
    this.snare_vca.connect(this.comp)
    this.hihat_vca.connect(this.hatVca)
    //
    this.kick_vca.connect(this.dry_kick)
    this.comp.connect(this.distortion)
    this.distortion.connect(this.output)
    this.closedEnv.connect(this.hatVca.factor)
    this.openEnv.connect(this.openHatChoke)
    this.openHatChoke.connect(this.hatVca.factor)
    this.hatVca.connect(this.comp)
    this.dry_kick.connect(this.output)
    //

    this.newKick = new DrumVoice()
    this.newKick.output.connect(this.comp)
    this.newHat = new DrumVoice()
    this.newHat.output.connect(this.comp)
    this.p1 = new DrumVoice()
    this.p1.output.connect(this.comp)

    setTimeout(()=>this.loadSamples(this.kit),100)
    this.hatDecay = .05
    this.prevTime = 0

    this.kickGhostVelocity = new Array(10).fill(.25)
    this.snareGhostVelocity = new Array(10).fill(1/4)
    this.kickVelocity = new Array(10).fill(1)
    this.snareVelocity = new Array(10).fill(1)
    this.closedVelocity = new Array(10).fill(.75)
    this.openVelocity = new Array(10).fill(1)
    this.p1Velocity = new Array(10).fill(1)
    this.p2Velocity = new Array(10).fill(1)
    this.p3Velocity = new Array(10).fill(1)

    if (this.gui !== null) {
            this.initGui()
            this.hideGui();
            setTimeout(this.loadPreset('default'),1000);
        }

        for(let i=0;i<10;i++) {
            this.subdivision[i] = '16n'
        }

  }//constructor

  //SETTERS AND GETTERS
  get kickDecay() { return this.kickEnv.release; }
  set kickDecay(value) { this.kickEnv.release = value; }
  get snareDecay() { return this.snareEnv.release; }
  set snareDecay(value) { this.snareEnv.release = value; }
  get closedDecay() { return this.closedEnv.release; }
  set closedDecay(value) { this.closedEnv.release = value; }
  get openDecay() { return this.openEnv.decay; }
  set openDecay(value) { this.openEnv.decay = value; }
  get p1Decay() { return this.tomEnv[0].release; }
  set p1Decay(value) { this.tomEnv[0].release = value; }
  get p2Decay() { return this.tomEnv[1].release; }
  set p2Decay(value) { this.tomEnv[1].release = value; }
  get p3Decay() { return this.tomEnv[2].release; }
  set p3Decay(value) { this.tomEnv[2].release = value; }

  get kickRate() { return this.kick.playbackRate; }
  set kickRate(value) { this.kick.playbackRate = value; }
  get snareRate() { return this.snare.playbackRate; }
  set snareRate(value) { this.snare.playbackRate = value; }
  get closedRate() { return this.hihat.playbackRate; }
  set closedRate(value) { this.hihat.playbackRate = value; }
  get p1Rate() { return this.tom[0].playbackRate; }
  set p1Rate(value) { this.tom[0].playbackRate = value; }
  get p2Rate() { return this.tom[1].playbackRate.playbackRate; }
  set p2Rate(value) { this.tom[1].playbackRate = value; }
  get p3Rate() { return this.tomEnv[2].playbackRate; }
  set p3Rate(value) { this.tom[2].playbackRate = value; }

  get threshold() { return this.comp.threshold.value ; }
  set threshold(value) { this.comp.threshold.value = value; }
  get ratio() { return this.comp.ratio.value ; }
  set ratio(value) { this.comp.ratio.value = value; }
  get dist() { return this.distortion.distortion ; }
  set dist(value) { this.distortion.distortion = value; }
  get volume() { return this.output.factor.value; }
  set volume(value) { this.output.factor.value = value; }

  set dryKick(value) {this.dry_kick.factor.value = value}
  get dryKick() {return this.dry_kick.factor.value}

  setVelocity(voice, num, val){
    if(val > 1) val = val/127 //account for 0-127 velocities
    if(num>=0 && num<10){
      switch( voice ){
        case 'kick': case 'O': this.kickVelocity[num]=val; break;
        case 'snare': case 'X': this.snareVelocity[num]=val; break;
        case 'closed': case '*': this.closedVelocity[num]=val; break;
        case 'open': case '^': this.openVelocity[num]=val; break;
        case 'p1': case '1': this.p1Velocity[num]=val; break;
        case 'p2': case '2': this.p1Velocity[num]=val; break;
        case 'p3': case '3': this.p1Velocity[num]=val; break;
        case 'o': this.kickGhostVelocity[num]=val; break;
        case 'x': this.snareGhostVelocity[num]=val; break;
      }
    } else{
      for(let i=0;i<10;i++){
        switch( voice ){
        case 'kick': case 'O': this.kickVelocity[i]=val; break;
        case 'snare': case 'X': this.snareVelocity[i]=val; break;
        case 'closed': case '*': this.closedVelocity[i]=val; break;
        case 'open': case '^': this.openVelocity[i]=val; break;
        case 'p1': case '1': this.p1Velocity[num]=i; break;
        case 'p2': case '2': this.p1Velocity[num]=i; break;
        case 'p3': case '3': this.p1Velocity[num]=i; break;
        case 'o': this.kickGhostVelocity[num]=val; break;
        case 'x': this.snareGhostVelocity[num]=val; break;
      }
      }

    }
  }

  /**
   * Load a specific drum kit.
   * - duplicates loadSamples()
   * @param {string} kit - The name of the drum kit to load.
   */
  loadKit(kit){ this.loadSamples(kit)}
  listKits(){console.log(this.drumkitList)}
  loadSamples(kit){
    this.kit = kit
    this.drumFolders = {
      "4OP-FM": "4OP-FM", "FM": "4OP-FM",
      "Bongos": "Bongos", "Bongo": "Bongos",
      "CR78": "CR78", 
      "KPR77": "KPR77",
      "Kit3": "Kit3","kit3": "Kit3", 
      "Kit8": "Kit8", "kit8": "Kit8", 
      "LINN": "LINN", "linn": "LINN", 
      "R8": "R8",
      "Stark": "Stark", "stark": "Stark", 
      "Techno": "Techno", "techno": "Techno", 
      "TheCheebacabra1": "TheCheebacabra1", "Cheese1": "TheCheebacabra1",
      "TheCheebacabra2": "TheCheebacabra2",  "Cheese2": "TheCheebacabra2",
      "acoustic-kit": "acoustic-kit", "acoustic": "acoustic-kit", "Acoustic": "acoustic-kit",
      "breakbeat13": "breakbeat13", 
      "breakbeat8": "breakbeat8", 
      "breakbeat9": "breakbeat9",
    }

     if (this.kit in this.drumFolders) {
      console.log(`Drumsampler loading ${this.kit}`);
      this.baseUrl = "https://tonejs.github.io/audio/drum-samples/".concat(this.drumFolders[this.kit]);
    } else if(this.kit === 'default'){
        this.baseUrl = "./audio/drumDefault";
    } else {
      console.error(`The kit "${this.kit}" is not available.`);
      return
    }

    
    this.urls = {
      "C3": "/kick.mp3",
      "D3": "/snare.mp3",
      "F#3": "/hihat.mp3",
      "F3": "/tom1.mp3",
      "G3": "/tom2.mp3",
      "A3": "/tom3.mp3"
    }
    try{
      this.kick.load( this.baseUrl.concat("/kick.mp3") )
      this.snare.load( this.baseUrl.concat("/snare.mp3") )
      this.hihat.load( this.baseUrl.concat("/hihat.mp3") )
      this.newHat.voice.load( this.baseUrl.concat("/hihat.mp3") )
      this.tom[0].load( this.baseUrl.concat("/tom1.mp3") )
      this.tom[1].load( this.baseUrl.concat("/tom2.mp3") )
      this.tom[2].load( this.baseUrl.concat("/tom3.mp3") )
      this.newKick.voice.load( this.baseUrl.concat("/kick.mp3") )
    } catch(e){
      console.log('unable to load samples - try calling loadPreset(`default`)')
    }
  }

  /**
   * Trigger a specific drum voice.
   * 
   * @param {string} voice - The name of the drum voice to trigger (e.g., "kick", "snare").
   * @param {number} vel - The velocity (amplitude) of the triggered voice.
   * @param {number} time - The time at which to trigger the voice.
   */
  trigger(voice, vel, time) {
    if (voice.loaded) {
      switch (voice) {
        case "kick": this.triggerVoice( this.kick,  vel, time ); break;
        case "snare": this.triggerVoice( this.snare, vel, time ); break;
        case "hihat": this.triggerVoice( this.hihat, vel, time ); break;
        case "tom1": this.triggerVoice( this.tom[0], vel, time ); break;
        case "tom2": this.triggerVoice( this.tom[1], vel, time ); break;
        case "tom3": this.triggerVoice( this.tom[2], vel, time ); break;
        default: console.error(`Unknown voice: ${voice}`); break;
      }
    } else {
      console.error("Sampler is not loaded yet.");
    }
  }
  
  /**
   * Set up and start a sequenced playback of drum patterns.
   * 
   * @param {string} arr - A string representing the drum pattern.
   * @param {string} subdivision - The rhythmic subdivision to use for the sequence (e.g., '8n', '16n').
   */
  // sequence(arr, subdivision = '8n', num = 0, iterations = 'Infinity') {

  //   this.seq[num] = parseStringSequence(arr)

  //   this.createLoop(subdivision, num, iterations)

  //   // Initialize arrays for each drum voice
  //   if (subdivision) this.subdivision[num] = subdivision;

  //   //note: we have changed approaches
  //   //the sequence is not split up at this point
  //   //instead, it is parsed in the loop
  // } 

  sequence(arr, subdivision = '8n', num = 0, phraseLength = 'infinite') {
        //this.start(num);
    console.log(arr)
        if (!this.seq[num]) {
            this.seq[num] = new Seq(this, '0', subdivision, phraseLength, num, this.triggerDrum.bind(this));
            this.seq[num].parent = this
            this.seq[num].vals = parseStringSequence(arr)
            this.seq[num].loopInstance.stop()
            this.seq[num].createLoop = this.newCreateLoop
            this.seq[num].createLoop()
        } else {
            //console.log('update seq')
            this.seq[num].drumSequence(arr, subdivision, phraseLength);
        }
    }


  /**
     * plays the provided sequence array initializes a Tone.Loop with the given subdivision.
     *
     * @param {string} arr - The sequence of notes as a string.
     * @param {number} iterations - The the number of times to play the sequence
     * @param {string} [subdivision] - The rhythmic subdivision for the loop (e.g., '16n', '8n').
     * @param {string} num (default 0) - the sequence number. Up to 10 sequences per instance.
     */
    setSeq(arr, subdivision = '8n', num = 0){
        this.seq[num] = parseStringSequence(arr)

        if (subdivision) this.setSubdivision(subdivision, num) 
    }

    // play(iterations = 1, arr = null, subdivision = '8n', num = 0) {

    //     if(arr) this.seq[num] = parseStringSequence(arr)

    //     this.createLoop(subdivision, num, iterations)
    //     //this.loopInstance[num].start()
    // }

  createLoop(subdivision, num, iterations='Infinity',){
        // Create a Tone.Loopdsfg
        if (this.loopInstance[num] === null) {
            this.loopInstance[num] = new Tone.Loop(time => {
              //console.log(num)
                this.index = Math.floor(Tone.Transport.ticks / Tone.Time(this.subdivision[num]).toTicks());
                if(this.enable[num] === 0) return
                
                if(num == 0) this.callback(this.index)
                let curBeat = this.seq[num][this.index%this.seq[num].length];
                curBeat = this.checkForRandomElement(num,curBeat)
                const event = parseStringBeat(curBeat, time)
                //console.log(this.index , this.seq[num],curBeat, event)

                for (const val of event) {
                  this.triggerDrum(val[0], num, time + val[1] * (Tone.Time(this.subdivision[num])));
                }
                
                if(this.phraseLength[num] === 'infinite') return
                this.phraseLength[num] -= 1
                if(this.phraseLength[num] < 1) this.stop(num)
            }, subdivision).start(0);

            // Start the Transport
            Tone.Transport.start();
            console.log("loop started")
        }
        //this.loopInstance[num].iterations = iterations * this.seq[num].length

        if (subdivision) {
         // if(subdivision !== this.subdivision[num]){
                setTimeout( this.setSubdivision(subdivision, num), 100)
             // }
        }

        this.start(num)
    }

    newCreateLoop (){
        // Create a Tone.Loop
      console.log('loop made')
            this.loopInstance = new Tone.Loop(time => {
                if(this.enable=== 0) return
                this.index = Math.floor(Tone.Transport.ticks / Tone.Time(this.subdivision).toTicks());
                let curBeat = this.vals[this.index % this.vals.length];
                //console.log("before transform", '.'+curBeat+'.')
                curBeat = this.perform_transform(curBeat);
                //console.log("after transform", '.'+curBeat+'.')

                curBeat = this.checkForRandomElement(curBeat);

                const event = parseStringBeat(curBeat, time);
                //console.log(event,curBeat, this.vals,time,this.index, this.subdivision)
                for (const val of event) {
                  this.parent.triggerDrum(val[0], 0, time + val[1] * (Tone.Time(this.subdivision)));
                }
                
            }, this.subdivision).start(0);

            this.setSubdivision(this.subdivision);
            // Start the Transport
            Tone.Transport.start();
            console.log("loop started")
        
        
        this.loopInstance.start()
        Tone.Transport.start()
    }

  triggerDrum = (val, num, time)=>{
    //console.log(val,time, this.kickVelocity[num],this)
    val = val[0]
    switch(val){
      case '.': break;
      case '0': this.newKick.trigger(1,1,time); break; //just because. . . .
      case 'O': this.newKick.trigger(1,1,time); break;
      //case 'O': this.triggerVoice(this.kick,this.kickVelocity[num],time); break;
      case 'o': this.newKick.trigger(.5,1.5,time); break;
      case 'X': this.triggerVoice(this.snare,1,time); break;
      case 'x': this.triggerVoice(this.snare,.5,time); break;
      // case '*': this.triggerVoice(this.hihat,this.closedVelocity[num],time); break;
      case '*': this.newHat.triggerChoke(.75,0.1,time); break;
      case '^': this.newHat.trigger(.75,1,time); break;
      case '1': this.triggerVoice(this.tom[0],1,time); break;
      case '2': this.triggerVoice(this.tom[1],1,time); break;
      case '3': this.triggerVoice(this.tom[2],1,time); break;
      default: console.log('triggerDrum(), no matching drum voice ', val, '\n')
    }   
  }
  triggerNew(voice, amplitude, time){
    console.log('new')
    this.newKick.voice.volume.setValueAtTime( Tone.gainToDb(amplitude), time)
    this.newKick.voice.start(time)
    this.newKick.env1.triggerAttackRelease(0.001, time)
  }

  triggerVoice(voice, amplitude, time){
    let curEnv = null
    if( voice === this.kick ) curEnv = this.kickEnv
    else if( voice === this.snare ) curEnv = this.snareEnv
    else if( voice === this.tom[0] ) curEnv = this.tomEnv[0]
    else if( voice === this.tom[1] ) curEnv = this.tomEnv[1]
    else if( voice === this.tom[2] ) curEnv = this.tomEnv[2]
    else if( voice === this.hihat) {
      this.closedEnv.triggerAttackRelease(.001,time)
      this.openHatChoke.factor.setValueAtTime(0, time)
    }
    else if( voice === "openHat") {
      voice = this.hihat
      this.openHatChoke.factor.setValueAtTime(1, time)
      this.openEnv.triggerAttackRelease(10,time)
    }
    //if( voice.state === "started" ) voice.stop(time)
    //if( this.prevTime < time){
    try{
      voice.volume.setValueAtTime( Tone.gainToDb(amplitude), time)
      voice.start( time )
      if(curEnv !== null) curEnv.triggerAttackRelease(.001, time)
    } catch(e){
      //console.log('time error')
    }
    // } else { console.log('caught time error', time, this.prevTime)}
    // this.prevTime = time
  }

  //drawBeat doesn't really work but is an attempt to draw the 
    //sequence to a canvas using html
  drawBeat (canvasId) {
        const verticalOrder = ['^', '*', '1', '2', '3', 'x', 'X', 'o', 'O'];
        const verticalSpacing = 20; // Vertical spacing between each row
        const horizontalSpacing = 40; // Horizontal spacing between each character
        const canvas = document.getElementById(canvasId);
        const beat = this.seq.original
        canvas.innerHTML = ''; // Clear any existing content

        for (let i = 0; i < beat.length; i++) {
            const element = beat[i];
            const verticalIndex = verticalOrder.indexOf(element);

            if (verticalIndex !== -1) {
                const yPos = verticalIndex * verticalSpacing; // Calculate vertical position
                const xPos = i * horizontalSpacing; // Calculate horizontal position

                const beatElement = document.createElement('div');
                beatElement.className = 'beat';
                beatElement.style.transform = `translate(${xPos}px, ${yPos}px)`;
                beatElement.textContent = element;

                canvas.appendChild(beatElement);
            }
        }
      }

  /**
     * Load a preset by name
     * @param {string} name - Name of the preset to load
     * @returns {void}
     * @example synth.loadPreset('default')
     */
    loadPreset(name) {
        setTimeout(()=>{
          this.curPreset = name;
        const presetData = this.presets[this.curPreset];

        if (presetData) {
            console.log("Loading preset ", this.curPreset, presetData);
            for (let id in presetData) {
                try {
                    for (let element of Object.values(this.gui_elements)) {
                        
                        if (element.id === id) {
                          //console.log(id, presetData[id])
                            if (element.type !== 'momentary') element.set(presetData[id]);
                        }
                    }
                } catch (e) {
                    console.log(e);
                }
            }
        } else {
            console.log("No preset of name ", name);
        }
      },1000)
    }

  /** create a visual gui on the gui element.
   * The gui element can be passed in the constructor or here
   * @param {number} [x = 10] - base X position
   * @param {number} [y = 10] - base Y position
   * @param {object} [gui=this.gui] - The GUI object to use.
   */
  initGui(gui=this.gui, x = 10, y = 10) {
      if(gui) this.gui = gui
      // Set the base positions
      this.x = x;
      this.y = y;
      
      this.enables_array = [];
      this.values_array = [];

      // Create GUI elements for VCA controls (factor controls)
      const kick_vca_knob = this.createKnob('Kick', 0, 40, 0, 1, .5, [200, 50, 0], x => this.newKick.output.factor.value = x);
      const snare_vca_knob = this.createKnob('Snare', 0, 20, 0, 1, .5, [200, 50, 0], x => this.snare_gain.factor.value = x);
      const hat_vca_knob = this.createKnob('Hihat', 0, 0, 0, 1, .5, [200, 50, 0], x => this.newHat.output.factor.value = x);
      const toms_vca_knob = this.createKnob('Toms', 0, 60, 0, 1, .5, [200, 50, 0], x => {this.tom_gain[0].factor.value = x; this.tom_gain[1].factor.value = x ;this.tom_gain[2].factor.value = x});
      const kick_decay_knob = this.createKnob('decay', 10, 40, 0, 1, .5, [200, 50, 0], x => this.newKick.decay = x*10+.01);
      const snare_decay_knob = this.createKnob('decay', 10, 20, 0, 1, .5, [200, 50, 0], x => this.snareEnv.release = x*10+.01);
      const toms_decay_knob = this.createKnob('decay', 10, 60, 0, 1, .5, [200, 50, 0], x => {this.tomEnv[0].release = x*10+.01; this.tomEnv[1].release = x*10+.01 ;this.tomEnv[2].release = x*10+.01});
      
      const output_knob = this.createKnob('Output', 80, 60, 0, 4, 1, [200, 50, 0], x => this.output.factor.value = x);
      const dry_kick_knob = this.createKnob('Dry Kick', 40, 40, 0, 1, .4, [200, 50, 0], x => this.dry_kick.factor.value = x);

      // Create GUI elements for Playback Rate controls
      const kick_rate_knob = this.createKnob('rate', 20, 40, 0., 2, .4, [200, 50, 0], x => this.newKick.rate = x);
      const snare_rate_knob = this.createKnob('rate', 20, 20, 0., 2, .4, [200, 50, 0], x => this.snare.playbackRate = x);
      const hat_rate_knob = this.createKnob('rate', 20, 0, 0., 2, .4, [200, 50, 0], x => this.newHat.rate = x);
      const tom1_rate_knob = this.createKnob('1 Rate', 20, 60, 0., 2, .4, [200, 50, 0], x => this.tom[0].playbackRate = x);
      const tom2_rate_knob = this.createKnob('2 Rate', 30, 60, 0., 2, .4, [200, 50, 0], x => this.tom[1].playbackRate = x);
      const tom3_rate_knob = this.createKnob('3 Rate', 40, 60, 0., 2, .4, [200, 50, 0], x => this.tom[2].playbackRate = x);

      // Create GUI elements for Compressor controls
      const comp_threshold_knob = this.createKnob('Threshold', 60, 20, -60, -5, .5, [200, 50, 0], x => this.comp.threshold.value = x);
      const comp_ratio_knob = this.createKnob('Ratio', 60, 40, 1, 20, .5, [200, 50, 0], x => this.comp.ratio.value = x);

      // Create GUI element for Distortion Amount control
      const distort_knob = this.createKnob('Distort', 60, 60, 0, 1, .5, [200, 50, 0], x => this.distortion.distortion = x);

      // Create GUI element for Hat Decay
      const hihat_decay_knob = this.createKnob('Closed Decay', 40, 0, 0.01, 1, .75, [200, 50, 0], x => this.newHat.choke = x);
      const open_decay_knob = this.createKnob('Open Decay', 50, 0, 0.01, 2, .75, [200, 50, 0], x => this.newHat.decay = x);
  
      const kit_dropdown = this.gui.Dropdown({
        label: 'kit', dropdownOptions: this.drumkitList,
        // (()=>{
        //   const valuesArray = Object.values(this.drumFolders)
        //   const uniqueValuesArray = [...new Set(valuesArray)];
        //   return uniqueValuesArray})(),
        x: 80, y:10, size:15,
        callback:(x)=>{this.loadSamples(x)}
      })

      // Add all elements to an array for hiding/showing gui
    this.gui_elements = [
        kick_vca_knob, 
        snare_vca_knob, 
        hat_vca_knob, 
        toms_vca_knob,
        kick_decay_knob,
        snare_decay_knob,
        toms_decay_knob, 
        output_knob, 
        dry_kick_knob,
        kick_rate_knob, 
        snare_rate_knob, 
        hat_rate_knob, 
        tom1_rate_knob, 
        tom2_rate_knob, 
        tom3_rate_knob,
        comp_threshold_knob, 
        comp_ratio_knob,
        distort_knob, 
        hihat_decay_knob,
        open_decay_knob,
        kit_dropdown
    ];
  }

  createKnob(_label, _x, _y, _min, _max, _size, _accentColor, callback) {
      //console.log(_label)
      return this.gui.Knob({
        label:_label, min:_min, max:_max, size:_size, accentColor:_accentColor,
        x: _x + this.x, y: _y + this.y,
        callback: callback,
        curve: 1, // Adjust as needed
        border: 4, // Adjust as needed
        showLabel: 1, showValue: 1
      });
    }

  // connect(destination) {
  //   if (destination.input) {
  //     this.output.connect(destination.input);
  //   } else {
  //     this.output.connect(destination);
  //   }
  // }

	// disconnect(destination) {
  //   if (destination.input) {
  //     this.output.disconnect(destination.input);
  //   } else {

  //     this.output.disconnect(destination);
  //   }
  // }
}

class DrumVoice{
  constructor(){
    this.chokeRatio = .1
    this.decayTime = 1
    this.startPoint = 0
    this.env = new Tone.Envelope(0.0, 1, 1, 10)
    this.vca = new Tone.Multiply()
    this.output = new Tone.Multiply(1)
    this.dryOut = new Tone.Multiply(0)
    this.voice = new Tone.Player().connect(this.vca)
    this.vca.connect(this.output)
    this.voice.connect(this.dryOut)
    this.env.connect(this.vca.factor)

    let paramDefinitions = [
      {name:'choke',min:0.,max:1,curve:2,callback:x=>{
        this.chokeRatio = x
      }},
      {name:'decay',min:0.0,max:5,curve:3,callback:x=>{
        this.decayTime = x
      }},
      {name:'amp',min:0,max:1,curve:2,callback:x=>this.output.factor.value = x},
      {name:'dry',min:0,max:1,curve:2,callback:x=>this.dryOut.factor.value = x},
      {name:'rate',value:1, min:-10,max:10,curve:1,callback:x=>{
        this.voice.playbackRate = Math.abs(x)
        if(x<0) this.voice.reverse = true
      }},
      // {name:'wet',min:0.0,max:1.2,curve:2,callback:value=>this.wetSig.factor.value = value},
      // {name:'gain',min:0.0,max:1,curve:0.2,callback:value=>this.ws_input.factor.value = value},
      // {name:'amp',min:0.0,max:1.2,curve:2,callback:value=>this.output.factor.value = value},
    ]

    this.param = this.generateParameters(paramDefinitions)
    this.createAccessors(this, this.param);
  }

  setDecayTime(decay, choke){
    this.decayTime = decay
    this.chokeRatio = choke
    this.env.release = decay*choke
  }
  triggerSample(amplitude, decay,time){
    //console.log(amplitude,decay,time, this.voice)
    try{
      //this.env.release = decay == 0 ? this.decayTime * this.chokeRatio : this.decayTime
      this.voice.volume.setValueAtTime( Tone.gainToDb(amplitude), time)
      this.voice.start(time, this.startPoint)
      //this.voice.start()
      this.env.triggerAttackRelease(0.001, time)
    } catch(e){
        console.log('time error', e)
    }
  }
    trigger(amplitude, decay,time){
      this.env.release =  this.decayTime
      this.env.decay =  this.decayTime 
      this.triggerSample(amplitude, decay,time)
    }
    triggerChoke(amplitude, decay,time){
      this.env.release =  this.decayTime * this.chokeRatio
      this.env.decay =  this.decayTime * this.chokeRatio
      this.triggerSample(amplitude, decay,time)
    }

  generateParameters(paramDefinitions) {
        const params = {};
        paramDefinitions.forEach((def) => {
            const param = new Parameter(def);
            params[def.name] = param;
        });
        return params;
    }

    createAccessors(parent, params) {
      console.log(params)
    Object.keys(params).forEach((key) => {
        const param = params[key];

        // Ensure the Parameter object has a `set` method
        if (typeof param.set !== 'function') {
            throw new Error(`Parameter '${key}' does not have a set method`);
        }

        // Proxy to handle array-like access
        const proxyHandler = {
            get(target, prop) {
                if (typeof prop === 'string' && !isNaN(prop)) {
                    // Access individual array element
                    return target.get(parseInt(prop));
                }
                return target.get();
            },
            set(target, prop, value) {
                console.log(target, prop, value)
                if (typeof prop === 'string' && !isNaN(prop)) {
                    // Set individual array element
                    target.set(value, parseInt(prop));
                    return true;
                }
                // Set the entire array or scalar value
                target.set(value);
                return true;
            }
        };

        // Define the accessor property on the parent
        Object.defineProperty(parent, key, {
            get: () => new Proxy(param, proxyHandler),
            set: (newValue) => param.set(newValue),
        });
    });
}//createAccessors

    setParameter(name, value, time = null) {
        const param = this.param[name];
        if (!param) throw new Error(`Parameter '${name}' does not exist.`);
        
        if (time) {
            // Handle sequenced parameter updates
            param.callback(value, time);
        } else {
            // Handle immediate parameter updates
            param.callback(value);
        }

        // Update associated GUI elements
        if (param.guiElement) {
            param.guiElement.setValue(value);
        }
    }

    get() {
        let output = 'Parameters:\n';
        for (let key in this.param) {
            const param = this.param[key];
            output += `${param.name}: ${param._value}\n`;
        }
        console.log(output);
    }
}

window.drumLayout = {
  "layout": {
    "vco": {
      "color": [150, 0, 0],
      "boundingBox": { "x": 10, "y": 20, "width": 30, "height": 50 },
      "offsets": { "x": 12, "y": 30 },
      "groupA": ["type"],
      "controlTypeA": "radioButton",
      "controlTypeB": "knob",
      "sizeA": 0.8,
      "sizeB": 0.75,
      "theme": "dark"
    },
    "vcf": {
      "color": [100, 0, 150],
      "boundingBox": { "x": 30, "y": 20, "width": 40, "height": 50 },
      "offsets": { "x": 10, "y": 30 },
      "groupA": ["cutoff"],
      "controlTypeA": "knob",
      "controlTypeB": "knob",
      "sizeA": 0.8,
      "sizeB": 0.6
    },
    "vca": {
      "color": [100, 50, 100],
      "boundingBox": { "x": 70, "y": 20, "width": 30, "height": 50 },
      "offsets": { "x": 12, "y": 30 },
      "groupA": ["level"],
      "controlTypeA": "knob",
      "controlTypeB": "knob",
      "sizeA": 0.8,
      "sizeB": 0.6
    },
    "env": {
      "color": [20, 100, 100],
      "boundingBox": { "x": 5, "y": 60, "width": 100, "height": 50 },
      "offsets": { "x": 8, "y": 30 },
      "groupA": ["decay","pDecay","nDecay"],
      "controlTypeA": "knob",
      "controlTypeB": "fader",
      "sizeA": 0.5,
      "sizeB": 1.0
    },
    "lfo": {
      "color": [20, 0, 100],
      "boundingBox": { "x": 50, "y": 70, "width": 50, "height": 50 },
      "offsets": { "x": 12, "y": 30 },
      "groupA": ["rate"],
      "controlTypeA": "knob",
      "controlTypeB": "knob",
      "sizeA": 0.8,
      "sizeB": 0.6
    }
  }
};;

;

;
;

class DrumSynth extends DrumTemplate{
    constructor(options = {}) {
        super()
        const defaults = {
            toneFrequency: 50,
            pitchEnv: 100,
            amRatio: 1.0,
            toneGain: 0.5,
            noiseShape: "bandpass",
            noiseLevel: 0.5,
            toneLevel: 0.5,
            toneDecay: 0.2,
            noiseDecay: 0.3,
            cutoff: 2000,
            resonance: 1,
            volume: 0.5,
        };
        this.params = { ...defaults, ...options };


        // Oscillator and AM stage
        this.frequency = new Tone.Signal(this.params.toneFrequency)
        this.harmonicity = new Tone.Multiply(1); // Modulation depth
        this.frequency.connect( this.harmonicity)
        this.vco = new Tone.Oscillator(this.params.toneFrequency, "sine").start();
        this.frequency.connect(this.vco.frequency)
        this.modVco = new Tone.Oscillator(this.params.toneFrequency * this.params.amRatio, "sine").start();
        this.harmonicity.connect( this. modVco.frequency)
        this.amDepth = new Tone.Gain(0.); // Modulation depth
        this.fmDepth = new Tone.Gain(0.); // Modulation depth
        this.modVco.connect(this.amDepth);
        this.modVco.connect(this.fmDepth);
        this.modIndex = new Tone.Signal()
        this.indexMult = new Tone.Multiply()
        this.modIndex.connect(this.indexMult.factor)
        this.harmonicity.connect(this.indexMult)        
        this.vcoCarrier = new Tone.Signal(1)
        this.vcoCarrier.connect(this.vco.volume)
        this.amDepth.connect(this.vco.volume); // AM stage
        this.indexMult.connect(this.fmDepth.gain)
        this.fmDepth.connect(this.vco.frequency)

        // Waveshaper and gain for tone
        this.drive = new Tone.Gain(this.params.toneGain);
        this.waveshaper = new Tone.WaveShaper(x => Math.sin(x * Math.PI));
        this.vco.connect(this.drive);
        this.drive.connect(this.waveshaper)

        // Noise generator
        this.noise = new Tone.Noise("white").start();
        this.noiseFilter = new Tone.Filter(this.params.cutoff, this.params.noiseShape);
        this.noiseFilter.type = 'bandpass'
        this.noiseGain = new Tone.Gain(this.params.noiseLevel);
        this.noise.connect(this.noiseFilter);
        this.noiseFilter.connect(this.noiseGain);
        this.noiseVcfEnvDepth = new Tone.Multiply()
        this.noiseVcfEnvDepth.connect(this.noiseFilter.frequency)

        // Envelopes
        this.env = new Tone.Envelope({
            attack: 0.0,
            decay: this.params.toneDecay,
            sustain: 0,
            release:this.params.toneDecay,
        });
        this.noiseEnv = new Tone.Envelope({
            attack: 0.0,
            decay: this.params.noiseDecay,
            sustain: 0,
            release: this.params.noiseDecay,
        });
        this.pitchEnvelope = new Tone.Envelope({
            attack: 0.0,
            decay: this.params.toneDecay,
            sustain: 0,
            release: this.params.toneDecay,
        });
        this.pitchEnvDepth = new Tone.Multiply(this.params.pitchEnv)
        this.pitchEnvelope.connect(this.pitchEnvDepth)
        this.pitchEnvDepth.connect(this.vco.frequency)
        this.pitchEnvDepth.connect(this.harmonicity)
        this.pitchEnvelope.releaseCurve = 'linear'
        this.pitchEnvelope.decayCurve = 'linear'

        this.toneVca = new Tone.Multiply()
        this.env.connect(this.toneVca.factor)
        this.waveshaper.connect(this.toneVca);
        this.noiseVca = new Tone.Multiply()
        this.noiseEnv.connect(this. noiseVca.factor)
        this.noiseGain.connect(this.noiseVca);
        this.noiseCutoff = new Tone.Signal(2000)
        this.noiseCutoff.connect( this.noiseFilter.frequency)
        this.noiseEnv.connect(this.noiseVcfEnvDepth)

        // Final filter and output
        this.finalFilter = new Tone.Filter();
        this.cutoffSig = new Tone.Signal(this.params.cutoff)
        this.cutoffSig.connect(this.finalFilter.frequency)
        this.finalFilter.type =  "lowpass"
        this.finalFilter.Q.value =  this.params.resonance
        this.output = new Tone.Multiply(this.params.volume);
        this.toneVca.connect(this.finalFilter);
        this.noiseVca.connect(this.finalFilter);
        this.finalFilter.connect(this.output);
        this.vcfEnvDepth = new Tone.Multiply();
        this.vcfEnvDepth.connect(this.finalFilter.frequency)
        this.env.connect(this.vcfEnvDepth)

        let paramDefinitions = [
            {name:'type',type:'vco',value:'square',radioOptions:['square','saw','tri','sine'],callback:(x,time=null)=>{
                  switch(x){
                  case 'square': this.vco.type = 'square'; break;
                    case 'saw': this.vco.type = 'sawtooth'; break;
                      case 'tri': this.vco.type = 'triangle'; break;
                        case 'sine': this.vco.type = 'sine'; break;
                  }
                }
              },
            {name:'drive2',type:'vco',min:0.,max:2,curve:2,callback:(x,time=null)=>this.drive.gain.value = x},
            {name:'fm',type:'vcf',min:0.,max:10,curve:2,callback:(x,time=null)=>this.modIndex.value = x},
            {name:'am',type:'vcf',min:0.,max:2,curve:2,callback:(x,time=null)=>this.amDepth.gain.value = x},
            {name:'harm',type:'vcf',min:1.,max:20,curve:1,callback:(x,time=null)=>this.harmonicity.factor.value = (x)},
            {name:'cutoff',type:'vcf',min:50.,max:10000,curve:2,callback:(x,time=null)=>this.cutoffSig.value = x},
            {name:'Q',type:'vcf',min:0.,max:20,curve:0.7,callback:(x,time=null)=>this.finalFilter.Q.value = x},
            {name:'noiseG',type:'vca',min:0.,max:1.5,curve:2,callback:(x,time=null)=>this.noiseGain.gain.value = x},
            {name:'toneG',type:'vca',min:0.,max:1.5,curve:2,callback:(x,time=null)=>this.drive.gain.value = x},
            {name:'vol',type:'vca',min:0.,max:2,curve:2,callback:(x,time=null)=>this.output.factor.value = x},
            {name:'drop',type:'vco',min:0.,max:5000,curve:2,callback:(x,time=null)=>this.pitchEnvDepth.factor.value = x},
            {name:'decay',type:'env',min:0.,max:5,curve:2,callback:(x,time=null)=>{ this.env.decay = x; this.env.release = x }},
            {name:'pDecay',type:'env',min:0.,max:1,curve:2,callback:(x,time=null)=>{ this.pitchEnvelope.decay = x; this.pitchEnvelope.release = x }},
            {name:'nDecay',type:'env',min:0.,max:5,curve:2,callback:(x,time=null)=>{ this.noiseEnv.decay = x; this.noiseEnv.release = x }},
            {name:'nFreq',type:'vcf',min:100.,max:10000,curve:2,callback:(x,time=null)=>{ this.noiseCutoff.value = x; }},
            {name:'nEnv',type:'env',min:0.,max:5000,curve:3,callback:(x,time=null)=>this.noiseVcfEnvDepth.factor.value = x},
            {name:'vcfEnv',type:'vcf',min:0.,max:5000,curve:3,callback:(x,time=null)=>this.vcfEnvDepth.factor.value = x},
            // {name:'adsr',type:'env',min:0,max:1,curve:2,value:[.01,.1,.5,.5],
            //     labels:['attack','decay','sustain','release'],
            //     callback:(x,i=null)=>{ this.setADSR('env',x, i) }
            // },
            // {name:'noise',type:'env',min:0,max:1,curve:2,value:[.01,.1,.5,.5],
            //     labels:['attack','decay','sustain','release'],
            //     callback:(x,i=null)=>{ this.setADSR('noise',x, i) }
            // },
            // {name:'pitch',type:'env',min:0,max:1,curve:2,value:[.01,.1,.5,.5],
            //     labels:['attack','decay','sustain','release'],
            //     callback:(x,i=null)=>{ this.setADSR('pitch',x, i) }
            // },
        ]

        this.param = this.generateParameters(paramDefinitions)
        this.createAccessors(this, this.param);

        //for autocomplete
        this.autocompleteList = paramDefinitions.map(def => def.name);;
        //for(let i=0;i<this.paramDefinitions.length;i++)this.autocompleteList.push(this.paramDefinitions[i].name)
        setTimeout(()=>{this.loadPreset('default')}, 500);
    }

    setADSR(voice, val, i){
        //console.log(voice,val)
        let obj = this.env
        if(voice == 'tone') obj = this.env
        else if(voice == 'noise') obj = this.noiseEnv
        else if(voice == 'pitch') obj = this.pitchEnvelope
        else if(val == null) {
            obj = this.env
            val = voice
        }
        if( Array.isArray(val) && i == null){
            if( val.length<=4)  {
                obj.attack = val[0]
                obj.decay = val[1]
                obj.sustain = val[2]
                obj.release = val[3]
            }
        } else if( i != null){
            if(i==0) obj.attack = val
            if(i==1) obj.decay = val
            if(i==2) obj.sustain = val
            if(i==3) obj.release = val
        }
    }

    // // Getters and setters
    // get toneFrequency() {
    //     return this.params.toneFrequency;
    // }
    // set toneFrequency(value) {
    //     this.params.toneFrequency = value;
    //     this.frequency.value = value;
    //     this.modVco.frequency.value = value * this.params.amRatio;
    // }

    // get amRatio() {
    //     return this.params.amRatio;
    // }
    // set amRatio(value) {
    //     this.params.amRatio = value;
    //     this.modVco.frequency.value = this.params.toneFrequency * value;
    // }

    // get toneGain2() {
    //     return this.params.toneGain;
    // }
    // set toneGain2(value) {
    //     this.params.toneGain = value;
    //     this.toneGain.gain.value = value;
    // }

    // get noiseShape() {
    //     return this.params.noiseShape;
    // }
    // set noiseShape(value) {
    //     this.params.noiseShape = value;
    //     this.noiseFilter.type = value;
    // }

    // get noiseLevel() {
    //     return this.params.noiseLevel;
    // }
    // set noiseLevel(value) {
    //     this.params.noiseLevel = value;
    //     this.noiseGain.gain.value = value;
    // }

    // get toneLevel() {
    //     return this.params.toneLevel;
    // }
    // set toneLevel(value) {
    //     this.params.toneLevel = value;
    //     this.output.factor.value = value;
    // }

    // get toneDecay() {
    //     return this.params.toneDecay;
    // }
    // set toneDecay(value) {
    //     this.params.toneDecay = value;
    //     this.env.decay = value;
    //     this.pitchEnvelope.decay = value
    // }
    // get pitchEnv() {
    //     return this.params.pitchEnv;
    // }
    // set pitchEnv(value) {
    //     this.params.pitchEnv = value;
    //     this.pitchEnvDepth.factor.value = value;
    // }

    // get noiseDecay() {
    //     return this.params.noiseDecay;
    // }
    // set noiseDecay(value) {
    //     this.params.noiseDecay = value;
    //     this.noiseEnv.decay = value;
    // }

    // get cutoff() {
    //     return this.params.cutoff;
    // }
    // set cutoff(value) {
    //     this.params.cutoff = value;
    //     this.finalFilter.frequency.value = value;
    //     this.noiseFilter.frequency.value = value;
    // }

    // get resonance() {
    //     return this.params.resonance;
    // }
    // set resonance(value) {
    //     this.params.resonance = value;
    //     this.finalFilter.Q.value = value;
    // }

    // get volume() {
    //     return this.params.volume;
    // }
    // set volume(value) {
    //     this.params.volume = value;
    //     this.output.factor.factor.value = value;
    // }

    // Trigger a drum hit
    trigger(time = Tone.now()) {
        this.env.triggerAttackRelease(.05, time);
        this.noiseEnv.triggerAttackRelease(.05, time);
        this.pitchEnvelope.triggerAttackRelease(.05, time);
    }

    triggerAttackRelease(val=48, vel = 100, dur = 0.01, time = null) {
        //console.log('AR ',val,vel,dur,time)
        vel = vel / 127;
        if (time) {
            this.frequency.setValueAtTime(Tone.Midi(val).toFrequency(), time);
            this.env.triggerAttackRelease(.01, time);
            this.noiseEnv.triggerAttackRelease(.01, time);
            this.pitchEnvelope.triggerAttackRelease(.01
                , time);
        } else {
            //this.frequency.value = Tone.Midi(val).toFrequency();
            //this.env.triggerAttackRelease(dur);
        }
    }

    //GUI
  // Initialize GUI
  initGui(gui=null) {
    //console.log('init', this.param)
    this.gui = gui
    const layout = dlayout.layout;

    // Group parameters by type
    const groupedParams = {};
    Object.values(this.param).forEach((param) => {
        if (!groupedParams[param.type]) groupedParams[param.type] = [];
        groupedParams[param.type].push(param);
    });

    // Create GUI for each group
    Object.keys(groupedParams).forEach((groupType) => {
        const groupLayout = layout[groupType];
        if (!groupLayout) return;
        if (groupType === 'hidden') return;
      


        let indexOffset = 0
        groupedParams[groupType].forEach((param, index) => {
          const isGroupA = groupLayout.groupA.includes(param.name);

          // Calculate size and control type
          const controlType = isGroupA ? groupLayout.controlTypeA : groupLayout.controlTypeB;
          const size = isGroupA ? groupLayout.sizeA : groupLayout.sizeB;
          // Calculate offsets
          let xOffset = 0//groupLayout.offsets.x * (index % Math.floor(groupLayout.boundingBox.width / groupLayout.offsets.x));
          let yOffset = 0//groupLayout.offsets.y * Math.floor(index / Math.floor(groupLayout.boundingBox.width / groupLayout.offsets.x));
          if( Array.isArray( param._value )){
            param._value.forEach((_, i) => {
              // Calculate offsets
             xOffset = groupLayout.offsets.x * ((index+indexOffset) % Math.floor(groupLayout.boundingBox.width / groupLayout.offsets.x));
             yOffset = groupLayout.offsets.y * Math.floor((index+indexOffset) / Math.floor(groupLayout.boundingBox.width / groupLayout.offsets.x));
            
              // Calculate absolute positions
              const x = groupLayout.boundingBox.x + xOffset;
              const y = groupLayout.boundingBox.y + yOffset;
              this.createGuiElement(param, { x, y, size, controlType, color: groupLayout.color, i });
              indexOffset++
            })
          } else{
            xOffset = groupLayout.offsets.x * ((index+indexOffset) % Math.floor(groupLayout.boundingBox.width / groupLayout.offsets.x));
            yOffset = groupLayout.offsets.y * Math.floor((index+indexOffset) / Math.floor(groupLayout.boundingBox.width / groupLayout.offsets.x));
          
            // Calculate absolute positions
            const x = groupLayout.boundingBox.x + xOffset;
            const y = groupLayout.boundingBox.y + yOffset;
            // Create GUI element
            this.createGuiElement(param, { x, y, size, controlType, color: groupLayout.color });    
          }

        });
    });
}

 // Create individual GUI element
    createGuiElement(param, { x, y, size, controlType, color, i=null }) {
    //console.log('createG', param, x,y,size,controlType, i)
    if (controlType === 'knob') {
        param.guiElements.push(this.gui.Knob({
            label: i ? param.labels[i] : param.name,
            min: param.min,
            max: param.max,
            value: param._value,
            size: size , // Scale size
            curve: param.curve,
            x,
            y,
            accentColor: color,
            callback: (value) => param.set(value,i,true),
        }));
    } else if (controlType === 'fader') {
        param.guiElements.push(this.gui.Fader({
            label: i ? param.labels[i] : param.name,
            min: param.min,
            max: param.max,
            curve: param.curve,
            size: param.size, // Scale size
            x,
            y,
            accentColor: color,
            callback: (value) => param.set(value,i,true),
        }));
    } else if (controlType === 'radioButton') {
        if (!Array.isArray(param.radioOptions) || param.radioOptions.length === 0) {
            console.warn(`Parameter "${param.name}" has no options defined for radioBox.`);
            return null;
        }

        return this.gui.RadioButton({
            label: i ? param.labels[i] : param.name,
            radioOptions: param.radioOptions,
            x:x,
            y:y+10,
            size:.5,
            accentColor: color,
            callback: (selectedOption) => param.set(selectedOption),
        });
    }
}
}

class SimpleSeq{
	constructor(value=0, number = 10){
		this.numSeqs = number
		this.seq = new Array(this.numSeqs).fill(value)
	}
	get(num=0,index=0){
		num = num % this.numSeqs
		if(Array.isArray( this.seq[num] )){
			return this.seq[num][index%this.seq[num].length]
		} else {
			return this.seq[num]
		}
	}
	set(num, val){ this.seq[num] = val}
	setAll(val) {this.seq = new Array(this.numSeqs).fill(val)}

	set val (x){this.setAll(x)}
	get val (){return this.seq[0]}
	set value (x){ this.setAll(x) }
}

/**
 * Drummer.js
 * 
 * Single drum voice
 * 
 * player -> vcf -> vca -> output
 * 
 * env -> gain -> vca.factor
 * accentEnv -> accentDepth -> vca.factor
 * 
 * uses the standard sequence type, with parameters for:
 * - velocity
 * - tuning: sample playback rate
 * - decay: base decay time for envelope
 * - choke: scalar for decay
 * - tone: multirange filter
 * - strike: position of sample to start playing
 * - accent: selectable volume boost
 * 
 * The sequence can either use a specified char to trigger playback
 * or use a float to set amplitude(velocity)
 * 
 * 
 */

;
;




/**
 * DrumSampler class extends DrumTemplate to create a drum sampler with various sound manipulation features.
 * It loads and triggers different drum samples based on the selected kit.
 * 
 * extends DrumTemplate
 */
class Drummer extends DrumTemplate{
  constructor(voice = "kick", kit = "acoustic") {
    super()
    this.name = "Drummer"
    this.voice = voice
    this.kit = kit
    this.drumkitList = ["LINN", "Techno", "TheCheebacabra1", "TheCheebacabra2", "acoustic-kit", "breakbeat13", "breakbeat8", "breakbeat9", "4OP-FM", "Bongos", "CR78", "KPR77", "Kit3", "Kit8"]
    //
    this.output = new Tone.Multiply(1);
    this.env = new Tone.Envelope(0.001, 1, 1, 10)
    this.vca = new Tone.Multiply()
    this.gain = new Tone.Multiply(1)
    this.drum = new Tone.Player()
    this.vcf = new Tone.Filter({type:'lowpass', rolloff:'-12',Q:0,frequency:10000})
    this.vcfEnvDepth = new Tone.Multiply()
    this.cutoffFreq = new Tone.Signal()
    this.accentEnv = new Tone.Envelope({attack:.003,decay:.1,sustain:0,release:.1})
    this.accentDepth = new Tone.Multiply()

    //connections
    this.drum.connect(this.vcf)
    this.vcf.connect(this.vca)
    this.vca.connect(this.output)

    this.cutoffFreq.connect(this.vcf.frequency)
    this.env.connect(this.vcfEnvDepth)
    this.accentEnv.connect(this.vcfEnvDepth)
    this.vcfEnvDepth.connect(this.vcf.frequency)

    this.env.connect( this.gain)
    this.gain.connect( this.vca.factor)
    this.accentEnv.connect(this.accentDepth)
    this.accentDepth.connect( this.vca.factor)

    //parameters
    this.velocity = new SimpleSeq(1)
    this.strike = new SimpleSeq(0)
    this.curStrike = 0
    this.damp = new SimpleSeq(0)
    this.chokeRatio = .5
    this.choke = new SimpleSeq(0)
    this.decay = new SimpleSeq(1)
    this.tone = new SimpleSeq(1)
    this.accent = new SimpleSeq(0)
    this.accentLevel = .2
    this.tuning = new SimpleSeq(1)
    this.subdivision = new SimpleSeq('16n')

    // let paramDefinitions = [
    //   {name:'volume',min:0.0,max:1,curve:2,callback:x=>this.output.factor.value = x},
    //   {name:'velocity',min:0.0,max:1,curve:2,callback:x=>this.velocityVal.setAll(x)},
    //   {name:'decay',min:0.0,max:1.,curve:2,callback:x=>this.decayTime.setAll(x)},
    //   {name:'damping',min:0,max:1,curve:2,callback:x=>this.dampValue.setAll(x)},
    //   {name:'choke',min:0,max:1,curve:2,callback:x=>this.chokeRatio=x},
    //   {name:'tone',min:0.0,max:1,curve:2,callback:x=>this.toneAmount.setAll(x)},
    //   {name:'accent',min:0.0,max:1,curve:2,callback:x=>this.accentLevel=x},
    //   {name:'tuning',min:0.0,max:2,curve:1,callback:x=>this.tuningAmount.setAll(x)},
    //   {name:'strike',min:0.0,max:1.,curve:2,callback:x=>this.strikePosition.setAll(x)}
    // ]

    // this.param = this.generateParameters(paramDefinitions)
    // this.createAccessors(this, this.param);

    this.sampleLength = 1
    //
    this.loadSamples(this.kit)
    this.prevTime = 0

  }//constructor


  /**
   * Load a specific drum kit.
   * - duplicates loadSamples()
   * @param {string} kit - The name of the drum kit to load.
   */
  loadKit(kit){ this.loadSamples(kit)}
  listKits(){console.log(this.drumkitList)}
  loadSamples(kit){
    this.kit = kit
    this.drumFolders = {
      "4OP-FM": "4OP-FM", "FM": "4OP-FM",
      "Bongos": "Bongos", "Bongo": "Bongos",
      "CR78": "CR78", 
      "KPR77": "KPR77",
      "Kit3": "Kit3","kit3": "Kit3", 
      "Kit8": "Kit8", "kit8": "Kit8", 
      "LINN": "LINN", "linn": "LINN", 
      "R8": "R8",
      "Stark": "Stark", "stark": "Stark", 
      "Techno": "Techno", "techno": "Techno", 
      "TheCheebacabra1": "TheCheebacabra1", "Cheese1": "TheCheebacabra1",
      "TheCheebacabra2": "TheCheebacabra2",  "Cheese2": "TheCheebacabra2",
      "acoustic-kit": "acoustic-kit", "acoustic": "acoustic-kit", "Acoustic": "acoustic-kit",
      "breakbeat13": "breakbeat13", 
      "breakbeat8": "breakbeat8", 
      "breakbeat9": "breakbeat9",
    }

     if (this.kit in this.drumFolders) {
      console.log(`Drumsampler loading ${this.kit}`);
    } else {
      console.error(`The kit "${this.kit}" is not available.`);
      return
    }

    this.baseUrl = "https://tonejs.github.io/audio/drum-samples/".concat(this.drumFolders[this.kit]);
    this.urls = {
      "C3": "/kick.mp3",
      "D3": "/snare.mp3",
      "F#3": "/hihat.mp3",
      "F3": "/tom1.mp3",
      "G3": "/tom2.mp3",
      "A3": "/tom3.mp3"
    }
    // Load the sample and store its length in ms
    this.drum = new Tone.Player({
        url: this.baseUrl.concat("/" + this.voice + ".mp3"),
        onload: () => {
            // Access the buffer duration and convert to milliseconds
            this.sampleLength = this.drum.buffer.duration; // duration in ms
            console.log("Sample length:", this.sampleLength, " seconds");
            this.drum.connect(this.vcf)
        }
    })
  }

  /**
   * Trigger a specific drum voice.
   * 
   * @param {string} voice - The name of the drum voice to trigger (e.g., "kick", "snare").
   * @param {number} vel - The velocity (amplitude) of the triggered voice.
   * @param {number} time - The time at which to trigger the voice.
   */
  trigger(vel, time){
    console.log('trig', vel)
    try{
      this.drum.volume.setValueAtTime( Tone.gainToDb(vel), time)
      this.drum.start( time, this.curStrike )
      this.env.triggerAttackRelease(.001, time)
    } catch(e){
      console.log('time error')
    }
  }
  
  parseNoteString(val, time, num, index){
    if(val[0] === ".") return

    let vel = val[0]
    let div = val[1]

    this.loopFunc(index, num, vel, time + div * (Tone.Time(this.subdivision[num])))
    return
        
        // const usesPitchNames = /^[a-ac-zA-Z]$/.test(val[0][0]);

        // let note = ''
        // //console.log(val[0], usesPitchNames)
        // //if( usesPitchNames ) note =  pitchNameToMidi(val[0])
        // if( usesPitchNames ) {
        //   console.log("drummer doesn't use pitches")
        //   return
        // }
        // //else note = intervalToMidi(val[0], this.min, this.max)
        // const div = val[1]
        // if(note < 0) return
        // //console.log(note, this.velocity[num], this.sustain[num], time)

        // //check for velocity,octave,sustain, and roll arrays
        // // let octave = this.getNoteParam(this.octave[num],index)
        // // let velocity = this.getNoteParam(this.velocity[num],index)
        // // let sustain = this.getNoteParam(this.sustain[num],index)
        // //let roll = getNoteParam(this.roll[num],this.index[num])
        // //console.log(note + octave*12, velocity, sustain)
        // try{
        //     this.trigger(velocity,time + div * (Tone.Time(this.subdivision[num])));
        // } catch(e){
        //     console.log('invalid note', note + octave*12, velocity, sustain)
        // }
    }

    getNoteParam(val,index){
        if( Array.isArray(val)) return val[index%val.length]
        else return val    
    }
    setNoteParam(val,arr){
        for(let i=0;i<arr.length;i++) arr[i] = val
        return arr
        // if( Array.isArray(val)) return val[index%val.length]
        // else Array(num).fill(val)
    }
    //convert tone value from 0-1 to Hz
    toneScalar(val,time){
      val = Math.pow(val,2)
      //console.log( val*2000,  10000-val*9900)
      this.vcfEnvDepth.factor.setValueAtTime( val*4000, time)
      this.cutoffFreq.setValueAtTime( (1-val)*10000, time)
    }
    /**
   * Trigger the drum voice.
   * @param {number} vel - The velocity (amplitude) of the triggered voice.
   * @param {number} time - The time at which to trigger the voice.
   */
    loopFunc(index, num=0, vel=127, time=Tone.now()){
      let velocity = vel * this.velocity.get(num,index)
      let curDecay = this.decay.get(num,index)
      this.env.release = this.sampleLength * curDecay
      if(this.choke.get(num,index)!= 1) curDecay*=this.chokeRatio
      this.toneScalar(this.damp.get(num,index),time)
      if(this.accent.get(num,index)) this.accentEnv.triggerAttackRelease(.05)
      this.curStrike = this.strike.get(num,index)
      //this.drum.playbackRate = this.tuning.get(num,index)
      this.trigger(velocity,time)
    }
}

/*
 *
 * Class to define a multiVCO which can produce multiple waves in series
 * Parameters are frequency, types of waves, and scalars to shift the pitch (0.5 for down an octave, 2 for up an octave)
 * 
*/

;
;

class MultiVCO{
    constructor(vcos = [], pitchshift = []){
        this.numInputs = vcos.length
        this.frequency = new Tone.Signal(1)
        this.output = this.numInputs === 0 ? new Tone.Multiply(1) : new Tone.Multiply(1/this.numInputs)

        this.freqScalars= []
        this.gainStages = []
        this.vco = []

        for(this.i=0;this.i<this.numInputs;this.i++) {
            this.freqScalars.push(new Tone.Multiply(pitchshift[this.i]))
            if (vcos[this.i] === 'noise') {
                this.vco.push(new Tone.Noise("white").start())
            }
            else {
                this.vco.push(new Tone.Oscillator({type:vcos[this.i]}).start())
            }
            this.gainStages.push(new Tone.Multiply(1))
            this.frequency.connect(this.freqScalars[this.i])
            if (vcos[this.i] !== 'noise') {
                this.freqScalars[this.i].connect(this.vco[this.i].frequency)
            }
            this.vco[this.i].connect(this.gainStages[this.i])
            this.gainStages[this.i].connect(this.output)
        }
    }

    addVoice = (vcoType)=> {
        this.freqScalars.push(new Tone.Multiply(1))
        if (vcoType === 'noise') {
            this.vco.push(new Tone.Noise("white").start())
        }
        else {
            this.vco.push(new Tone.Oscillator({type:vcoType}).start())
        }
        this.gainStages.push(new Tone.Multiply(1))
        this.frequency.connect(this.freqScalars[this.numInputs])
        if (vcoType !== 'noise') {
            this.freqScalars[this.numInputs].connect(this.vco[this.numInputs].frequency)
        }
        this.vco[this.numInputs].connect(this.gainStages[this.numInputs])
        this.gainStages[this.numInputs].connect(this.output)
        this.numInputs++
        this.output.factor.value = 1/this.numInputs
    }

    removeVoice = (index = 0)=> {
        this.vco[index].stop()
        this.frequency.disconnect(this.freqScalars[index])
        if (this.vco[index].type !== 'noise') {
            this.freqScalars[index].disconnect(this.vco[index].frequency)
        }
        this.vco[index].disconnect(this.gainStages[index])
        this.gainStages[index].disconnect(this.output)
        if (index < this.numInputs - 1) {
            for (let i = index; i < this.numInputs ; i++) {
                this.freqScalars[i] = this.freqScalars[i+1]
                this.gainStages[i] = this.gainStages[i+1]
                this.vco[i] = this.vco[i+1]
            }
        }
        this.freqScalars.pop()
        this.gainStages.pop()
        this.vco.pop()

        this.numInputs--
        this.output.factor.value = this.numInputs === 0 ? 1 : 1/this.numInputs
    }

    setPitchshift= (index, shift) =>{
        if (index >= this.numInputs || index < 0) {
            console.log("Index out of range")
        }
        else {
            this.freqScalars[index].factor.value = shift
        }
    }

    setGain = (index, level)=> {
        if (index >= this.numInputs || index < 0) {
            console.log("Index out of range")
        }
        else {
            this.gainStages[index].factor.value = level
        }
    }

    connect(destination) {
        if (destination.input) {
            this.output.connect(destination.input);
        } else {
            this.output.connect(destination);
        }
    }

    disconnect(destination) {
        if (destination.input) {
            this.output.disconnect(destination.input);
        } else {
            this.output.disconnect(destination);
        }
    }
}

window.ESPSynthPresets = {
  "default": {
    "octave": "8",
    "tri": 1,
    "saw": 1,
    "squ": 1,
    "-1": 1,
    "-2": 1,
    "noise": 1,
    "vib/wah": 0.48,
    "speed": 10,
    "frequency": 1200,
    "resonance": 1,
    "VCF Env Depth": 0.01,
    "volume": 1,
    "velo filter": 0.99,
    "velo volume": 0.99,
    "A": 0.1,
    "D": 0.1,
    "S": 1,
    "R": 1,
    "chorus": 0.0001,
    "Overdrive": 0.0001
  },
  "Big Sweep": {
    "octave": "4",
    "tri": 0.0001,
    "saw": 1.9866673333333333,
    "squ": 0.0001,
    "-1": 1.7066313333333347,
    "-2": 2,
    "noise": 1,
    "vib/wah": 0.48,
    "speed": 10,
    "frequency": 1079.0000000000005,
    "resonance": 6.142493025000001,
    "VCF Env Depth": 2047.5449932752538,
    "volume": 1,
    "velo filter": 0.49019999999999975,
    "velo volume": 0.3824,
    "A": 7.692400000000003,
    "D": 9.290800000000004,
    "S": 0.37006299999999964,
    "R": 16.721000000000007,
    "chorus": 0.7300270000000002,
    "Overdrive": 0.14008599999999996
  },
  "Fat Bass": {
    "octave": "16",
    "tri": 1.826675333333333,
    "saw": 1.960002,
    "squ": 0.0001,
    "-1": 1,
    "-2": 0.7333966666666665,
    "noise": 0.10676133333333335,
    "vib/wah": 0.48,
    "speed": 10,
    "frequency": 685.4999999999993,
    "resonance": 2.641784774360023,
    "VCF Env Depth": 1454.5302125627568,
    "volume": 1.014999,
    "velo filter": 0.99,
    "velo volume": 0.99,
    "A": 0.01,
    "D": 4.195900000000002,
    "S": 0.5900409999999995,
    "R": 4.183999999999998,
    "chorus": 0.090091,
    "Overdrive": 0.33006700000000017
  },
  "80s Bass": {
    "octave": "16",
    "tri": 0.0001,
    "saw": 0.0001,
    "squ": 1.7333466666666677,
    "-1": 1.880006,
    "-2": 1.6000200000000002,
    "noise": 0.013432666666666667,
    "vib/wah": 0.48,
    "speed": 10,
    "frequency": 685.4999999999993,
    "resonance": 1.2479293620748477,
    "VCF Env Depth": 1789.554999999998,
    "volume": 1.1550229999999997,
    "velo filter": 0.5293999999999995,
    "velo volume": 0.5293999999999995,
    "A": 0.01,
    "D": 3.596500000000001,
    "S": 0.0001,
    "R": 4.183999999999998,
    "chorus": 0.0001,
    "Overdrive": 0.1700829999999997
  },
  "Alien Distress Call": {
    "octave": "8",
    "tri": 1.4666933333333332,
    "saw": 0.0001,
    "squ": 0.8933886666666665,
    "-1": 0.0001,
    "-2": 0.0001,
    "noise": 0.44007800000000036,
    "vib/wah": 0.6460319999999997,
    "speed": 2.203899999999993,
    "frequency": 930.4999999999977,
    "resonance": 13.282497224999993,
    "VCF Env Depth": 69.11999999999912,
    "volume": 0.07509500000000001,
    "velo filter": 0.039399999999999574,
    "velo volume": 0.0884,
    "A": 2.6074000000000006,
    "D": 9.091000000000001,
    "S": 1,
    "R": 10.353,
    "chorus": 0.0001,
    "Overdrive": 0.6200379999999996
  },
  "Hazy Pad": {
    "octave": "8",
    "tri": 1.6800160000000013,
    "saw": 0.8667233333333338,
    "squ": 0.10676133333333333,
    "-1": 0.013432666666666667,
    "-2": 0.0001,
    "noise": 0.013432666666666667,
    "vib/wah": 0.7980159999999998,
    "speed": 1.2043999999999933,
    "frequency": 709.999999999997,
    "resonance": 3.082491225000001,
    "VCF Env Depth": 20.479999999999567,
    "volume": 0.8850410000000003,
    "velo filter": 0.40199999999999964,
    "velo volume": 0.4216000000000001,
    "A": 5.404600000000002,
    "D": 0.5095000000000001,
    "S": 1,
    "R": 10.154,
    "chorus": 0.0001,
    "Overdrive": 0.08009200000000001
  },
  "Poly Synth": {
    "octave": "8",
    "tri": 0.706731333333335,
    "saw": 1.3200339999999995,
    "squ": 1.7866773333333341,
    "-1": 0.0001,
    "-2": 0.0001,
    "noise": 0.0001,
    "vib/wah": 0.47504999999999953,
    "speed": 3.2033999999999927,
    "frequency": 858.5000000000002,
    "resonance": 3.4547914440000014,
    "VCF Env Depth": 787.3199999999944,
    "volume": 0.8850410000000003,
    "velo filter": 0.40199999999999964,
    "velo volume": 0.4216000000000001,
    "A": 0.01,
    "D": 9.100900000000005,
    "S": 0.0001,
    "R": 5.377999999999994,
    "chorus": 0.21007900000000007,
    "Overdrive": 0.2600739999999999
  },
  "Lead Synth": {
    "octave": "4",
    "tri": 1.7332966666666678,
    "saw": 0.6267353333333332,
    "squ": 0.6267353333333333,
    "-1": 0.0001,
    "-2": 0.0001,
    "noise": 0.0001,
    "vib/wah": 0.461002,
    "speed": 11.399300000000002,
    "frequency": 1030.0000000000005,
    "resonance": 1.4912902890000006,
    "VCF Env Depth": 238.36943484410202,
    "volume": 1,
    "velo filter": 0.99,
    "velo volume": 0.5881999999999996,
    "A": 0.01,
    "D": 0.01,
    "S": 0.8700129999999998,
    "R": 3.786,
    "chorus": 0.0001,
    "Overdrive": 0.090091
  },
  "warm keys": {
    "octave": "4",
    "tri": 1.6666333333333343,
    "saw": 0.6267353333333332,
    "squ": 2,
    "-1": 0.0001,
    "-2": 0.0001,
    "noise": 0.0001,
    "vib/wah": 0.4705010000000001,
    "speed": 6.001999999999995,
    "frequency": 662.5000000000001,
    "resonance": 1.8992905290000013,
    "VCF Env Depth": 1661.1772730937196,
    "volume": 1.164989,
    "velo filter": 0.7547999999999998,
    "velo volume": 0.8135999999999999,
    "A": 0.01,
    "D": 3.9060999999999946,
    "S": 0.4600539999999994,
    "R": 16.816,
    "chorus": 0.0001,
    "Overdrive": 0.090091
  },
  "SynthPop Lead": {
    "octave": "4",
    "tri": 1.1999900000000012,
    "saw": 1.466693333333333,
    "squ": 1.5333566666666671,
    "-1": 0.0001,
    "-2": 0.0001,
    "noise": 0.0001,
    "vib/wah": 0.461002,
    "speed": 11.399300000000002,
    "frequency": 1152.5000000000005,
    "resonance": 1.8992905290000013,
    "VCF Env Depth": 238.36943484410202,
    "volume": 1,
    "velo filter": 0.49999999999999944,
    "velo volume": 0.5881999999999996,
    "A": 0.01,
    "D": 0.01,
    "S": 0.8700129999999998,
    "R": 3.786,
    "chorus": 0.0001,
    "Overdrive": 0.17008299999999993
  },
  "SynthPop Bass": {
    "octave": "16",
    "tri": 1.4666933333333332,
    "saw": 1.5866873333333347,
    "squ": 1.5733546666666682,
    "-1": 1,
    "-2": 0.6933986666666666,
    "noise": 0.0001,
    "vib/wah": 0.48,
    "speed": 10,
    "frequency": 660.999999999999,
    "resonance": 1.386411747593559,
    "VCF Env Depth": 1454.5302125627568,
    "volume": 1.014999,
    "velo filter": 0.99,
    "velo volume": 0.01,
    "A": 0.01,
    "D": 4.195900000000002,
    "S": 0.5900409999999995,
    "R": 4.183999999999998,
    "chorus": 0.090091,
    "Overdrive": 0.33006700000000017
  },
  "Wobbly Pad": {
    "octave": "8",
    "tri": 1.6800160000000013,
    "saw": 0.8667233333333338,
    "squ": 0.10676133333333333,
    "-1": 0.013432666666666667,
    "-2": 0.0001,
    "noise": 0.013432666666666667,
    "vib/wah": 0.8265129999999999,
    "speed": 11.799099999999996,
    "frequency": 1028.4999999999973,
    "resonance": 3.082491225000001,
    "VCF Env Depth": 20.479999999999567,
    "volume": 0.9150390000000003,
    "velo filter": 0.40199999999999964,
    "velo volume": 0.4216000000000001,
    "A": 5.404600000000002,
    "D": 1.7083000000000004,
    "S": 1,
    "R": 0.1,
    "chorus": 0.0001,
    "Overdrive": 0.08009200000000001
  }
};;

/*
 * 6 voice subtractive synthesizer
 *
 * 
*/

;
;


;
;

class ESPSynth extends MonophonicTemplate {
    constructor (gui = null, waves = ['triangle', 'sawtooth', 'square', 'square', 'square', 'noise'], pitches = [1, 1, 1, 0.5, 0.25, 1]) {
        super()
        this.gui = gui
        this.presets = ESPSynthPresets
        this.name = "ESPSynth"
        //console.log(this.name, " loaded, available preset: ", ESPSynthPresets)

        this.frequency = new Tone.Signal()
        this.pitchshift = new Tone.Multiply()
        this.vco = new MultiVCO(waves, pitches)
        this.lfo = new Tone.LFO().start()
        this.vibratoSwitch = new Tone.Multiply()
        this.wahSwitch = new Tone.Multiply()
        this.vcf = new Tone.Filter()
        this.cutoff = new Tone.Signal()
        this.env = new Tone.Envelope()
        this.vcfVelocityDepth = new Tone.Signal(1)
        this.vcaVelocityDepth = new Tone.Signal(1)
        this.vcfEnvDepth = new Tone.Multiply()
        this.vcfVelocity = new Tone.Multiply(1)
        this.vcaEnvDepth = new Tone.Multiply()
        this.vcaVelocity = new Tone.Multiply(1)
        this.vca = new Tone.Multiply()
        this.output = new Tone.Multiply(1)

        //connect input signal to multiVCO
        this.frequency.connect(this.pitchshift)
        this.pitchshift.connect(this.vco.frequency)
        this.pitchshift.value = 1

        //connect vco to vcf
        this.vco.connect(this.vcf)
        this.cutoff.connect(this.vcf.frequency)
        this.vcf.rolloff = -24
        this.vcf.Q.value = 1

        //enable the lfo to impact pitch or filter
        this.lfo.connect(this.vibratoSwitch) //switch between 0 and 1
        this.vibratoSwitch.connect(this.vco.frequency)
        this.lfo.connect(this.wahSwitch)
        this.wahSwitch.connect(this.vcf.frequency)

        //Set up filter envelope

        this.env.connect(this.vcfEnvDepth)
        this.vcfEnvDepth.connect(this.vcfVelocity)
        this.vcfVelocity.connect(this.vcf.frequency)
        this.vcfVelocityDepth.connect(this.vcfVelocity.factor)

        //connect vcf to vca
        this.vcf.connect(this.vca)

        //set up amplitude envelope
        this.vcaEnvDepth.factor.value = 1
        this.env.connect(this.vcaEnvDepth)
        this.vcaEnvDepth.connect(this.vcaVelocity)
        this.vcaVelocity.connect(this.vca.factor)
        this.vcaVelocityDepth.connect(this.vcaVelocity.factor)

        //effects chain

        //distortion
        this.dist = new Tone.Distortion()
        // this.distgain = new Tone.Multiply(1)
        // this.distout = new Tone.Add()
        // this.vca.connect(this.distout)
        // this.vca.connect(this.distgain)
        // this.distgain.connect(this.dist)
        // this.dist.connect(this.distout)
        this.vca.connect(this.dist)

        //chorus
        this.chor = new Tone.Chorus(2.5, 5, 0.9)
        this.dist.connect(this.chor)
        // this.chorgain = new Tone.Multiply(1)
        // this.chorout = new Tone.Add()
        // this.distout.connect(this.chorout)
        // this.distout.connect(this.chorgain)
        // this.chorgain.connect(this.chor)
        // this.chor.connect(this.chorout)

        // this.chorout.connect(this.output)
        this.chor.connect(this.output)

        //velocity
        this.velo = 10
        this.amp = this.velo/127

        this.vcfDynamicRange = 0  //at low values, there's low dynamic range
        this.vcaDynamicRange = 0  //at high values, there's high dynamic range

        if (this.gui !== null) {
            this.initGui()
            this.hideGui();
            setTimeout(()=>{this.loadPreset('default')}, 500);
        }
    }

    octaveMapping = (x)=> {
        if (x !== undefined) {
            if (x === '4') return 2;
            else if (x === '8') return 1;
            else if (x === '16') return 0.5;
        }
        else return 1
    }

    lfoControl = (x)=> {
        if (x !== undefined) {
            let controlVal = Math.abs(x-0.5) * 2
            let lfoDepth = 50
            if (x < 0.47) {
                //this.lfo.min = -lfoDepth * stepper(controlVal, 0, 1, [[0,0],[0.6,0.2],[1,1]])
                this.lfo.min = -lfoDepth * controlVal
                // this.lfo.max = lfoDepth * stepper(controlVal, 0, 1, [[0,0],[0.6,0.2],[1,1]])
                this.lfo.max = lfoDepth * controlVal
                this.vibratoSwitch.value = 1
                this.wahSwitch.value = 0
            }
            else if (x >= 0.47 && x <= 0.49) {
                this.vibratoSwitch.value = 0
                this.wahSwitch.value = 0
            }
            else if (x > 0.49) {
                this.lfo.min =  0
                //this.lfo.max = lfoDepth * stepper(controlVal, 0, 1, [[0,0],[0.6,0.2],[1,1]])
                this.lfo.max = lfoDepth * controlVal
                this.vibratoSwitch.value = 0
                this.wahSwitch.value = 100 * controlVal
            }
        }
    }


    //envelopes
    triggerAttack (freq, amp, time=null){ 
        freq = Tone.Midi(freq).toFrequency()
        amp = amp/127
        if(time){
            this.env.triggerAttack(time)
            this.frequency.setValueAtTime(freq, time)
            this.vcfVelocityDepth.rampTo(stepper(amp, 0, 1, [[0,0],[0.001, 1 - this.vcfDynamicRange],[1,1]]),.03)
            this.vcaVelocityDepth.rampTo(stepper(amp, 0, 1, [[0,0],[0.001, 1 - this.vcaDynamicRange],[1,1]]),.03)
        } else{
            this.env.triggerAttack()
            this.frequency.value = freq
            this.vcfVelocityDepth.rampTo(stepper(amp, 0, 1, [[0,0],[0.001, 1 - this.vcfDynamicRange],[1,1]]),.03)
            this.vcaVelocityDepth.rampTo(stepper(amp, 0, 1, [[0,0],[0.001, 1 - this.vcaDynamicRange],[1,1]]),.03)
        }
    }

    triggerRelease (time=null){
        if(time) {
            this.env.triggerRelease(time)
        }
        else {
            this.env.triggerRelease()
        }
    }

    triggerAttackRelease (freq, amp, dur=0.01, time=null){
    freq = Tone.Midi(freq).toFrequency()
    amp = amp/127
    if(time){
        this.env.triggerAttackRelease(dur, time)
        this.frequency.setValueAtTime(freq, time)
        // this.vcfVelocityDepth.rampTo(stepper(amp, 0, 1, [[0,0],[0.001, 1 - this.vcfDynamicRange],[1,1]]),.01)
        // this.vcaVelocityDepth.rampTo(stepper(amp, 0, 1, [[0,0],[0.001, 1 - this.vcaDynamicRange],[1,1]]),.01)
        this.vcfVelocityDepth.setValueAtTime(stepper(amp, 0, 1, [[0,0],[0.001, 1 - this.vcfDynamicRange],[1,1]]),time)
        this.vcaVelocityDepth.setValueAtTime(stepper(amp, 0, 1, [[0,0],[0.001, 1 - this.vcaDynamicRange],[1,1]]),time)
    } else{
        this.env.triggerAttackRelease(dur)
        this.frequency.value = freq
        this.vcfVelocityDepth.rampTo(stepper(amp, 0, 1, [[0,0],[0.001, 1 - this.vcfDynamicRange],[1,1]]),.01)
        this.vcaVelocityDepth.rampTo(stepper(amp, 0, 1, [[0,0],[0.001, 1 - this.vcaDynamicRange],[1,1]]),.01)
    }
    }//attackRelease

    connect(destination) {
        if (destination.input) {
            this.output.connect(destination.input);
        } else {
            this.output.connect(destination);
        }
    }

    //parameter setters
    setADSR(a,d,s,r){
        this.env.attack = a>0.001 ? a : 0.001
        this.env.decay = d>0.01 ? d : 0.01
        this.env.sustain = Math.abs(s)<1 ? s : 1
        this.env.release = r>0.01 ? r : 0.01
    }

    setOutputGain(out){
        this.output.factor.value = out
    } 

    setVcoGain(num,val){
        this.vco.setGain(num, val)
    }

    initGui(gui = this.gui) {
        this.gui = gui
        this.octave_radio =  this.gui.RadioButton({
            label:'octave',
            radioOptions: ['4','8','16'],
            callback: x=>this.pitchshift.value = this.octaveMapping(x),
            x: 5, y:50,size:1, orientation:'vertical'
        })
        this.octave_radio.set('8');
        this.octave_radio.accentColor = [122,132,132]
        this.octave_radio.borderColor = [178,192,191]

        this.triangle_fader = this.gui.Slider({
            label:'tri',
            callback: (x)=>{this.setVcoGain(0, x)},
            x: 11, y: 50, size: 1.5,
            min:0.0001, max: 2,
            orientation: 'vertical',
            showValue: false,
        })
        this.triangle_fader.accentColor = [255,162,1]
        this.triangle_fader.borderColor = [20, 20, 20]
        this.triangle_fader.set(1)

        this.saw_fader = this.gui.Slider({
            label:'saw',
            callback: (x)=>{this.setVcoGain(1, x)},
            x: 17, y: 50, size: 1.5,
            min:0.0001, max: 2,
            orientation: 'vertical',
            showValue: false,
        })
        this.saw_fader.accentColor = [255,162,1]
        this.saw_fader.borderColor = [20, 20, 20]
        this.saw_fader.set(1)

        this.square_fader = this.gui.Slider({
            label:'squ',
            callback: (x)=>{this.setVcoGain(2, x)},
            x: 23, y: 50, size: 1.5,
            min:0.0001, max: 2,
            orientation: 'vertical',
            showValue: false,
        })
        this.square_fader.accentColor = [255,162,1]
        this.square_fader.borderColor = [20, 20, 20]
        this.square_fader.set(1)
        
        this.octave_down_fader = this.gui.Slider({
            label:'-1',
            callback: (x)=>{this.setVcoGain(3, x)},
            x: 29, y: 50, size: 1.5,
            min:0.0001, max: 2,
            orientation: 'vertical',
            showValue: false,
        })
        this.octave_down_fader.accentColor = [255,162,1]
        this.octave_down_fader.borderColor = [20, 20, 20]
        this.octave_down_fader.set(1)
        
        this.two_octave_down_fader = this.gui.Slider({
            label:'-2',
            callback: (x)=>{this.setVcoGain(4, x)},
            x: 35, y: 50, size: 1.5,
            min:0.0001, max: 2,
            orientation: 'vertical',
            showValue: false,
        })
        this.two_octave_down_fader.accentColor = [255,162,1]
        this.two_octave_down_fader.borderColor = [20, 20, 20]
        this.two_octave_down_fader.set(1)
        
        this.noise_fader = this.gui.Slider({
            label:'noise',
            callback: (x)=>{this.setVcoGain(5, x)},
            x: 41, y: 50, size: 1.5,
            min:0.0001, max: 2,
            orientation: 'vertical',
            showValue: false,
        })
        this.noise_fader.accentColor = [255,162,1]
        this.noise_fader.borderColor = [20, 20, 20]
        this.noise_fader.set(1)
        
        this.lfo_intensity_knob = this.gui.Knob({
            label:'vib/wah',
            callback: (x)=>{this.lfoControl(x)},
            x: 20, y: 23, size:1.1,
            showValue: false,
            min:0.0001, max: 0.95
        })
        this.lfo_intensity_knob.set( 0.48 )
        this.lfo_intensity_knob.borderColor = [178,192,191]
        this.lfo_intensity_knob.accentColor = [255,162,1]
        this.lfo_intensity_knob.border = 5
        this.lfoControl(0.48)
        
        this.lfo_speed_knob = this.gui.Knob({
            label:'speed',
            callback: (x)=>{this.lfo.frequency.value = x},
            x: 35, y: 23, size:1.1,
            showValue: false,
            min:0.01, max: 20,curve:2.5
        })
        this.lfo_speed_knob.set( 10 )
        this.lfo.frequency.value = 10
        this.lfo_speed_knob.borderColor = [178,192,191]
        this.lfo_speed_knob.accentColor = [255,162,1]
        this.lfo_speed_knob.border = 5
        

        this.cutoff_frequency_knob = this.gui.Knob({
            label:'frequency',
            // callback: (x)=>{this.cutoff.value = stepper(x, 50, 2500, [[0,0],[0.95,0.75], [1,1]])},
            callback: (x)=>{this.cutoff.value = x},
            x: 53, y: 25, size:1.4,
            showValue: false,
            min:50, max: 2500, curve:2
        })
        this.cutoff_frequency_knob.set( 1200 )
        this.cutoff.value = 1200
        this.cutoff_frequency_knob.borderColor = [178,192,191]
        this.cutoff_frequency_knob.accentColor = [255,162,1]
        this.cutoff_frequency_knob.border = 5
        
        
        this.resonance_knob = this.gui.Knob({
            label:'resonance',
            callback: (x)=>{ this.vcf.Q.value = x},
            x: 53, y: 72, size:1.4,
            min:0.99999, max: 18, curve: 2,
            showValue: false,
        })
        this.resonance_knob.set( 1 )
        this.vcf.Q.value = 1
        this.resonance_knob.borderColor = [178,192,191]
        this.resonance_knob.accentColor = [255,162,1]
        this.resonance_knob.border = 5
        
        this.asdr_int_knob = this.gui.Knob({
            label:'VCF Env Depth',
            callback: (x)=>{this.vcfEnvDepth.factor.value = x},
            x: 66, y: 34, size:0.85, curve: 3,
            min:0, max: 5000,
            showValue: false,
        })
        this.asdr_int_knob.set( 0.01 )
        this.asdr_int_knob.borderColor = [178,192,191]
        this.asdr_int_knob.accentColor = [255,162,1]
        this.asdr_int_knob.border = 5
        
        this.volume_knob = this.gui.Knob({
            label:'volume',
            callback: (x)=>{this.output.factor.value = x},
            x: 66, y: 68, size:0.85,
            min:0.0001, max: 1.5,
            showValue: false,
        })
        this.volume_knob.set( 1 )
        this.output.factor.value = 1
        this.volume_knob.borderColor = [178,192,191]
        this.volume_knob.accentColor = [255,162,1]
        this.volume_knob.border = 5
        
        this.velocity_filter_knob = this.gui.Knob({
            label:'velo filter',
            callback: (x)=>{this.vcfDynamicRange = x},
            x: 77, y: 15, size:0.85,
            min:0.01, max: 0.99,
            showValue: false,
        })
        this.velocity_filter_knob.set( 0.99 )
        this.velocity_filter_knob.borderColor = [178,192,191]
        this.velocity_filter_knob.accentColor = [255,162,1]
        this.velocity_filter_knob.border = 5
        
        this.velocity_volume_knob = this.gui.Knob({
            label:'velo volume',
            callback: (x)=>{this.vcaDynamicRange = x},
            x: 77, y: 83, size:0.85,
            min:0.01, max: 0.99,
            showValue: false,
        })
        this.velocity_volume_knob.set( 0.99 )
        this.velocity_volume_knob.borderColor = [178,192,191]
        this.velocity_volume_knob.accentColor = [255,162,1]
        this.velocity_volume_knob.border = 5
        
        this.attack_fader = this.gui.Slider({
            label:'A',
            //callback: (x)=>{this.env.attack = stepper(x, 0, 10, [[0,0],[0.01,0.01], [0.4, 0.03], [0.7, 0.25], [0.85, 0.5], [1,1]])},
            callback: (x)=>{this.env.attack = x},
            x: 76, y: 36, size: 1, curve: 2,
            min:0.01, max: 10,
            orientation: 'vertical',
            showValue: false,
        })
        this.attack_fader.accentColor = [255,162,1]
        this.attack_fader.borderColor = [20, 20, 20]
        this.env.attack = 0.1
        this.attack_fader.set(0.1)
        
        this.decay_fader = this.gui.Slider({
            label:'D',
            //callback: (x)=>{this.env.decay = stepper(x, 0, 10, [[0,0],[0.01,0.01], [0.4, 0.03], [0.7, 0.25], [0.85, 0.5], [1,1]])},
            callback: (x)=>{this.env.decay = x},
            x: 82, y: 36, size: 1, curve: 2,
            min:0.01, max: 10,
            orientation: 'vertical',
            showValue: false,
        })
        this.decay_fader.accentColor = [255,162,1]
        this.decay_fader.borderColor = [20, 20, 20]
        this.env.decay = 0.1
        this.decay_fader.set(0.1)
        
        this.sustain_fader = this.gui.Slider({
            label:'S',
            callback: (x)=>{this.env.sustain = x},
            x: 88, y: 36, size: 1,
            min:0.0001, max: 1,
            orientation: 'vertical',
            showValue: false,
        })
        this.sustain_fader.accentColor = [255,162,1]
        this.sustain_fader.borderColor = [20, 20, 20]
        this.sustain_fader.set(1)
        this.env.sustain = 1
        
        this.release_fader = this.gui.Slider({
            label:'R',
            //callback: (x)=>{this.env.release = stepper(x, 0, 20, [[0,0],[0.01,0.01], [0.4, 0.03], [0.7, 0.25], [0.85, 0.5], [1,1]])},
            callback: (x)=>{this.env.release = x},
            x: 94, y: 36, size: 1,
            min:0.1, max: 20, curve:2,
            orientation: 'vertical',
            showValue: false,
        })
        this.release_fader.accentColor = [255,162,1]
        this.release_fader.borderColor = [20, 20, 20]
        this.release_fader.set(1)
        this.env.release = 1
        
        this.chorus_filter_knob = this.gui.Knob({
            label:'chorus',
            callback: (x)=>{this.chor.wet.value = x},
            x: 91, y: 15, size:0.85,
            min:0.0001, max: 1,
            showValue: false,
        })
        this.chorus_filter_knob.set( 0.0001 )
        //this.chorgain.factor.value = 0.0001
        this.chorus_filter_knob.borderColor = [178,192,191]
        this.chorus_filter_knob.accentColor = [255,162,1]
        this.chorus_filter_knob.border = 5
        
        this.dist_volume_knob = this.gui.Knob({
            label:'Overdrive',
            callback: (x)=>{this.dist.distortion = x},
            x: 91, y: 83, size:0.85,
            min:0.0001, max: 1,
            showValue: false,
        })
        this.dist_volume_knob.set( 0.0001 )
        this.dist_volume_knob.borderColor = [178,192,191]
        this.dist_volume_knob.accentColor = [255,162,1]
        this.dist_volume_knob.border = 5

        this.gui_elements = [this.octave_radio, this.triangle_fader, this.saw_fader, this.square_fader,
            this.octave_down_fader, this.two_octave_down_fader, this.noise_fader, this.lfo_intensity_knob,
            this.lfo_speed_knob, this.cutoff_frequency_knob, this.resonance_knob, this.asdr_int_knob,
            this.volume_knob, this.velocity_filter_knob, this.velocity_volume_knob, this.attack_fader,
            this.decay_fader, this.sustain_fader, this.release_fader, this.chorus_filter_knob, 
            this.dist_volume_knob]
    }
}



/**
 * AnalogDelay.js
 * 
 * Simple approximation of an analog delay
 * 
 * Signal path:
 * input -> hpf -> gain -> waveShaper -> lpf -> delay -> wet -> output
 *                                         <- feedback <-
 * input -> dry -> output
 * 
 * @class
 */
;
;
//;

//import './userInterface.css';


class Feedback {
  /**
   * Uses a Tone.Delay() to allow for feedback loops.
   * @constructor
   * @param {number} [initialLevel=0.] - Initial feedback level.
   * @param {number} [initialTime=0.1] - Initial delay time in seconds.
   * @param {number} [initialFB=0] - Initial feedback amount.
   */
  constructor(initialLevel = 0, initialTime = 0.1, initialFB = 0) {
    this.input = new Tone.Multiply(initialLevel);
    this.delay = new Tone.Delay(initialTime);
    this._feedback = new Tone.Multiply(initialFB);
    this._output = new Tone.Multiply(1);

    // Connecting signal path
    this.input.connect(this.delay);
    this.delay.connect(this._feedback);
    this._feedback.connect(this.delay);
    this.delay.connect(this._output);

    let paramDefinitions = [
      {name:'inputGain',min:0.0,max:1,curve:2,callback:x=>this.input.factor.value = x},
      {name:'time',min:0.01,max:1,curve:2,callback:x=>this.delay.delayTime.value = x},
      {name:'feedback',min:0.0,max:1,curve:1,callback:x=>this._feedback.factor.value = x},
      {name:'outputGain',min:0,max:1,curve:2,callback:x=> this._output.factor.value = x},
      ]


    this.param = this.generateParameters(paramDefinitions)
    this.createAccessors(this, this.param);

    
  }

  generateParameters(paramDefinitions) {
    const params = {};
    paramDefinitions.forEach((def) => {
      const param = new Parameter(def);
      params[def.name] = param;
    });
    return params;
  }

  createAccessors(parent, params) {
    Object.keys(params).forEach((key) => {
      Object.defineProperty(parent, key, {
        get: () => params[key].value,
        set: (newValue) => {
          params[key].value = newValue;
        },
      });
    });
  }

  get() {
  let output = 'Parameters:\n';
  for (let key in this.param) {
    const param = this.param[key];
    output += `${param.name}: ${param.value}\n`;
  }
  //console.log(output);
}


  /**
   * Connect the output to a destination.
   * @param {Tone.Signal | AudioNode} destination - The destination to connect to.
   */
  connect(destination) {
    if (destination.input) {
      this._output.connect(destination.input);
    } else {
      this._output.connect(destination);
    }
  }

  /**
   * Disconnect the output from a destination.
   * @param {Tone.Signal | AudioNode} destination - The destination to disconnect from.
   */
  disconnect(destination) {
    if (destination.input) {
      this._output.disconnect(destination.input);
    } else {
      this._output.disconnect(destination);
    }
  }
}


/*
NoiseVoice

noise->gain->waveshaper->hpf->lpf->vca->output

basic noise oscillator with:
* integrated HPF and LPF
* VCA w/ env
* direct output level
* gui

methods:
- gui(x=2,y=2,ccolor=[200,200,0])
- setCutoff(freq, 'both', time) sets freq of both filters based on bandwidth
- setResonance(val, 'both', time) sets Q of both filters of 'hpf' 'lpf'
- setbandwidth(factor, 'both', time) sets a factor to scale the cutoff
- setADSR()
- triggerAttack(val, time=null) val sets cutoff
- triggerRelease (time=null)
- triggerAttackRelease (val, dur=0.01, time=null)

properties:
- env_depth.factor.value (env controls vca)
- hpf.frequency, Q
- lpf.frequency, Q
- gain.factor (into waveshaper)
- env ADSR

*/

;
;

class NoiseVoice{
	constructor(gui = null){
      this.gui = gui

      this.source = new Tone.Noise().start() 
      this.gain = new Tone.Multiply(0.5)
      this.waveshaper = new Tone.WaveShaper((input) => {
        // thresholding
        // if (input < -0.5 || input > 0.5) {
        //     // Apply some shaping outside the range -0.5 to 0.5
        //     return (input);
        // } else return 0;
        return Math.tanh(input*8)
      })  
      this.hpf =  new Tone.Filter({frequency: 200, type:'highpass', Q: 0})
      this.lpf = new Tone.Filter({frequency: 1000, type:'lowpass', Q: 0})
      this.vca= new Tone.Multiply(0)
      //control
      this.env = new Tone.Envelope({
        attack:0.01, decay:.1, sustain:0,release:.1
      })
      this.velocity = new Tone.Signal(1)
      this.velocity_depth = new Tone.Multiply(1)
      this.env_depth = new Tone.Multiply(1)
      this.direct = new Tone.Signal(1)
      this.baseCutoff = new Tone.Signal(0)
      this.cutoffSignal = new Tone.Signal(1000)
      this.hpf_band = new Tone.Multiply()
      this.lpf_band = new Tone.Multiply()
      this.hpf_env_depth = new Tone.Multiply()
      this.lpf_env_depth = new Tone.Multiply()
      //audio connections
      this.source.connect(this.gain)
      this.gain.connect(this.waveshaper)
      this.waveshaper.connect(this.hpf)
      this.hpf.connect(this.lpf)
      this.lpf.connect(this.vca)
      this.env.connect(this.velocity_depth)
      this.velocity.connect(this.velocity_depth.factor)
      this.velocity_depth.connect(this.env_depth)
      this.env_depth.connect( this.vca.factor)
      this.direct.connect(this.vca.factor)
      //filter cutoffs
      this.baseCutoff.connect(this.hpf.frequency)
      this.baseCutoff.connect(this.lpf.frequency)
      this.cutoffSignal.connect( this.hpf.frequency)
      this.cutoffSignal.connect( this.lpf.frequency)
      this.cutoffSignal.connect( this.hpf_band)
      this.cutoffSignal.connect( this.lpf_band)
      this.hpf_band.connect(this.hpf.frequency)
      this.lpf_band.connect(this.lpf.frequency)
      this.env.connect(this.hpf_env_depth)
      this.env.connect(this.lpf_env_depth)
      this.hpf_env_depth.connect( this.hpf.frequency)
      this.lpf_env_depth.connect( this.lpf.frequency)
    }
  setCutoff (val,time=null){
    if(time)this.cutoffSignal.setValueAtTime(val, time)
    else this.cutoffSignal.value = val  
  }
  setResonance (val, which = 'both', time=null){
    if(time){
      if(which === 'both' || which === 'lpf') this.lpf.Q.setValueAtTime(val, time)
      if(which === 'both' || which === 'hpf') this.hpf.Q.setValueAtTime(val, time)
    }
    else {
      if(which === 'both' || which === 'lpf') this.lpf.Q.value = val  
      if(which === 'both' || which === 'hpf') this.hpf.Q.value = val  
    }
  }
  setBandwidth (val, which = 'both', time = null){
    if(time) {
      if(which === 'both' || which === 'hpf') this.hpf_band.factor.setValueAtTime(1-Math.pow(2,1/val), time)
      if(which === 'both' || which === 'lpf') this.lpf_band.factor.setValueAtTime(1-Math.pow(2,val), time)
    }
    else {
      if(which === 'both' || which === 'hpf') this.hpf_band.factor.value = 1-Math.pow(2,1/val)
      if(which === 'both' || which === 'lpf') this.lpf_band.factor.value = 1-Math.pow(2,val)
    }
  }
  triggerAttack (val, vel=100, time=null){
    if(time){
      this.env.triggerAttack(time)
      this.setCutoff(val, time)
    } else{
      this.env.triggerAttack()
      this.setCutoff(val)
      console.log('att', val)
    }
  }
  triggerRelease (time=null){
    if(time) this.env.triggerRelease(time)
    else this.env.triggerRelease()
  }
  triggerAttackRelease (val, vel=100, dur=0.01, time=null){
    if(time){
      this.env.triggerAttackRelease(dur, time)
      this.setCutoff(val, time)
    } else{
      this.env.triggerAttackRelease(dur)
      this.setCutoff(val)
    }
  }//attackRelease
  //GUI
  initGui (x=2,y=2,ccolor=[200,200,0], gui = null){
    if(gui) this.gui = gui
    this.x = x
    this.y = y
    this.cutoff_knob = this.gui.Knob({
      label:'cutoff', mapto: this.baseCutoff,
      min:10, max:15000, curve:2,
      x:0+this.x, y:0+this.y, size:.25, accentColor: ccolor
    })
    this.resonance_knob = this.gui.Knob({
      label:'Q', callback: (x)=> this.setResonance(x),
      min:0, max:30, curve:1.5,
      x:0+this.x, y:15+this.y, size:.25, accentColor: ccolor
    })
    this.bandwidth_knob = this.gui.Knob({
      label:'width', callback: (x)=>this.setBandwidth(x),
      min:-10, max:10, curve:2,
      x:0+this.x, y:30+this.y, size:.25, accentColor: ccolor
    })
    this.hpf_env_knob = this.gui.Knob({
      label:'hpf env', mapto: this.hpf_env_depth.factor,
      min:0, max:5000, curve:2,
      x:0+this.x, y:45+this.y, size:.2, accentColor: ccolor
    })
    this.lpf_env_knob = this.gui.Knob({
      label:'lpf env', mapto: this.lpf_env_depth.factor,
      min:0, max:5000, curve:2,
      x:0+this.x, y:60+this.y, size:.2, accentColor: ccolor
    })
  }
  setADSR(a,d,s,r){
    this.env.attack = a>0.001 ? a : 0.001
    this.env.decay = d>0.01 ? d : 0.01
    this.env.sustain = Math.abs(s)<1 ? s : 1
    this.env.release = r>0.01 ? r : 0.01
  }
  position(x, y) {
    // Update the positions of GUI elements
    this.cutoff_knob.x = 0 + x;
    this.cutoff_knob.y = 0 + y;

    this.resonance_knob.x = 0 + x;
    this.resonance_knob.y = 15 + y;

    this.bandwidth_knob.x = 0 + x;
    this.bandwidth_knob.y = 30 + y;

    this.hpf_env_knob.x = 0 + x;
    this.hpf_env_knob.y = 45 + y;

    this.lpf_env_knob.x = 0 + x;
    this.lpf_env_knob.y = 60 + y;
  }
  connect(destination) {
    this.vca.connect(destination);
  }
}

/*
Resonator

Tuned delay line for Karplus-Strong style synthesis
* input->delay_1&2->hpf->lpf->vca->output
* one envelope for cutoff and vca control
* env_depth, hpf_env_depth, lpf_env_depth
* direct control of vca level (default:1)

methods:
- setFrequency(Hz): sets frequnecy of delay line in Hz
- setCutoff(freq, time) sets freq of lpf
- connect(destination)
- setADSR()

properties:
- env_depth.factor.value (env controls vca)
- direct.value - direct output level
*/

;
;

class Resonator{
	constructor(gui = null, color = [200,200,200]){
      this.gui = gui

      this.input = new Tone.Multiply(1)
      this.delay_1 = new Tone.LowpassCombFilter({resonance:.95,dampening:10000})
      this.delay_2 = new Tone.LowpassCombFilter({resonance:.95,dampening:10000})
      this.hpf = new Tone.Filter({frequency: 20, type:'highpass', Q: 0})
      this.lpf = new Tone.Filter({frequency: 10000, type:'lowpass', Q: 0})
      this.vca = new Tone.Multiply()
      this.output = new Tone.Multiply(1)
      //control
      this.env = new Tone.Envelope()
      this.hpf_cutoff = new Tone.Signal(20)
      this.lpf_cutoff = new Tone.Signal(20000)
      this.hpf_env_depth = new Tone.Multiply()
      this.lpf_env_depth = new Tone.Multiply()
      this.delayTime = new Tone.Signal(.1)
      this.delayTimeScalar = new Tone.Multiply(1)
      this.detune = new Tone.Multiply(1)
      this.env_depth = new Tone.Multiply(1)
      this.direct = new Tone.Signal(1)
      //audio connections
      this.input.connect(this.delay_1)
      this.input.connect(this.delay_2)
      this.delay_1.connect(this.hpf)
      this.delay_2.connect(this.hpf)
      this.hpf.connect(this.lpf)
      this.lpf.connect(this.vca)
      this.vca.connect(this.output)
      //delay
      this.delayTime.connect( this.delayTimeScalar)
      this.delayTimeScalar.connect( this.delay_1.delayTime)
      this.delayTimeScalar.connect( this.detune)
      this.detune.connect( this.delay_2.delayTime)
      //filter cutoffs
      this.hpf_cutoff.connect( this.hpf.frequency)
      this.lpf_cutoff.connect( this.lpf.frequency)
      this.env.connect(this.hpf_env_depth.factor)
      this.env.connect(this.hpf_env_depth.factor)
      this.hpf_env_depth.connect( this.hpf.frequency)
      this.lpf_env_depth.connect( this.lpf.frequency)
      //vca
      this.env.connect(this.env_depth)
      this.env_depth.connect(this.vca.factor)
      this.direct.connect(this.vca.factor)
	}
  setCutoff = function(val,time=null){
    if(time){
      this.lpf_cutoff.setValueAtTime(val, time)
      //this.lpf.frequency.setValueAtTime(val + (this.bandwidth*val)/2, time)
      //this.hpf.frequency.setValueAtTime(val - (this.bandwidth*val)/2, time)
    } else {
      this.lpf_cutoff.value = val
      //this.lpf.frequency.value = val + (this.bandwidth*val)/2
      //this.lpf.frequency.value = val - (this.bandwidth*val)/2
    }
  }
  setFrequency = function(val,time=null){
    if(time){
      this.delayTime.setValueAtTime(1/val, time)
    } else this.delayTime.value = 1/val
  }
  setFeedback = function(val,time=null){
    val = val<0 ? 0 : val>0.9999 ? 0.9999 : val
    if(time){
      this.delay_1.resonance.setValueAtTime(val, time)
      this.delay_2.resonance.setValueAtTime(val, time)
    } else {
      this.delay_1.resonance.value = val
      this.delay_2.resonance.value = val
    }
  }
  setADSR(a,d,s,r){
    this.env.attack = a>0.001 ? a : 0.001
    this.env.decay = d>0.01 ? d : 0.01
    this.env.sustain = Math.abs(s)<1 ? s : 1
    this.env.release = r>0.01 ? r : 0.01
  }
  connect(destination) {
    this.output.connect(destination);
  }
}

  

/*
KP

Karplus-Strong synthesis
* noise->hpf->lpf->dry->gain
* lpf->vca->wet->delay->gain
* gain->waveshaper->output

methods:
- 
setResonance
setDamping
setFilterFreq
setFilterQ 
setADSR

properties:
- gain.factor.value
*/

;
;
;
;

class Voice{
	constructor(color = [200,200,200]){
      this.impulse = new Tone.Noise().start()
      this.hpf = new Tone.Filter({frequency: 200, type:'highpass', Q: 0, rolloff:-24})
      this.lpf = new Tone.Filter({frequency: 1000, type:'lowpass', Q: 0, rolloff:-12})
      this.dry = new Tone.Signal(0.)
      this.wet = new Tone.Multiply(1)
      this.vca= new Tone.Multiply(1)
      this.delay_1 = new Tone.LowpassCombFilter({resonance:.95,dampening:10000})
      this.delay_2 = new Tone.LowpassCombFilter({resonance:.95,dampening:10000})
      //control
      this.env = new Tone.Envelope()
      this.env_depth = new Tone.Multiply(1)
      this.velocity = new Tone.Multiply(1)
      this.choke = new Tone.Signal()
      this.resonance = new Tone.Signal(.9)
      this.velocity_depth = new Tone.Multiply(1)
      this.lowpassCutoffSignal = new Tone.Signal(1000)
      this.highpassCutoffSignal = new Tone.Signal(1000)
      this.bandwidthSignal = new Tone.Signal(500)
      this.hpfBandWidthNegate = new Tone.Negate()
      this.hpf_env_depth = new Tone.Multiply()
      this.lpf_env_depth = new Tone.Multiply()
      this.delayTime = new Tone.Signal(.1)
      this.detune = new Tone.Multiply(1)
      this.output = new Tone.Multiply(1)
      //connections
      this.impulse.connect(this.hpf)
      this.hpf.connect(this.lpf)
      this.lpf.connect(this.vca)
      this.dry.connect(this.vca.factor)
      this.vca.connect(this.wet)
      this.wet.connect(this.delay_1)
      this.wet.connect(this.delay_2)
      this.delay_1.connect(this.output)
      this.delay_2.connect(this.output)
      this.resonance.connect(this.delay_1.resonance)
      this.resonance.connect(this.delay_2.resonance)
      this.choke.connect(this.delay_1.resonance)
      this.choke.connect(this.delay_2.resonance)
      this.env.connect(this.env_depth)
      this.env_depth.connect(this.velocity_depth)
      this.velocity_depth.connect(this.vca.factor)
      this.velocity.connect(this.velocity_depth)
      this.delayTime.connect( this.delay_1.delayTime)
      this.delayTime.connect( this.detune)
      this.detune.connect( this.delay_2.delayTime)
      //filter cutoffs
      this.highpassCutoffSignal.connect( this.hpf.frequency)
      this.lowpassCutoffSignal.connect( this.lpf.frequency)
      this.env.connect(this.hpf_env_depth.factor)
      this.env.connect(this.hpf_env_depth.factor)
      this.hpf_env_depth.connect( this.hpf.frequency)
      this.lpf_env_depth.connect( this.lpf.frequency)
      //this.bandwidthSignal.connect( this.lpf.frequency)
      //this.bandwidthSignal.connect(this.hpfBandWidthNegate)
      //this.hpfBandWidthNegate.connect(this.hpf.frequency)
	}
  cutoff = function(val,time=null){
    if(time)this.lowpassCutoffSignal.setValueAtTime(val, time)
    else this.lowpassCutoffSignal.value = val  
  }
  bandwidth = function(val, time){
    if(time) this.bandwidthSignal.setValueAtTime(val, time)
    else this.bandwidthSignal.value = val
  }
  frequency = function(val,time=null){
    if(time){
    	this.delayTime.setValueAtTime(1/val, time)
    }
    else {
    	this.delayTime.rampTo( 1/val, .01)
    }
  }
  triggerAttack = function(val, vel, time=null){
    if(time){
      this.env.triggerAttack(time)
      this.frequency(val, time)
      this.velocity_depth.linearRampToValueAtTime(vel,.01,time)
    } else{
      this.env.triggerAttack()
      this.frequency(val)
      this.velocity_depth.rampTo(vel,0.002)
    }
  }
  triggerRelease = function(val, time=null){
    if(time) this.env.triggerRelease(time)
    else this.env.triggerRelease()
  }
  triggerAttackRelease = function(val, vel, dur=0.01, time=null){
    if(time){
      this.env.triggerAttackRelease(dur, time)
      this.frequency(val, time)
      this.velocity_depth.linearRampToValueAtTime(vel,.01,time)
    } else{
      this.env.triggerAttackRelease(dur)
      this.frequency(val)
      this.velocity_depth.rampTo(vel,0.002)
    }
  }//attackRelease
}

class KP {
  constructor(num = 8, color = [200,200,200]){
    this.numVoices = num
    this.voice = []
    for(let i=0;i<this.numVoices;i++) this.voice.push(new Voice())
    
    //waveShaper
    this.clip = new Tone.Multiply(0.125)
    this.waveShaper = new Tone.WaveShaper((x)=>{
      return Math.sin(x*Math.PI*2)
      //return Math.tanh(x*8)
    })
    this.waveShaper.oversample = "4x"

    //lpf on output
    this.lpf = new Tone.Filter({type:'lowpass', rolloff:-12, Q:0, frequency:5000})
    this.output = new Tone.Multiply(0.15)
    this.clip.connect(this.waveShaper)

    for(let i=0;i<this.numVoices;i++) this.voice[i].output.connect( this.clip)
    this.clip.connect(this.waveShaper)
    this.waveShaper.connect(this.lpf)
    this.lpf.connect(this.output)

    this.prevNote = 0
    this.v = 0
    this.voiceCounter = 0
    this.activeNotes = [-1,-1,-1,-1, -1,-1,-1,-1]
    this.noteOrder = [7,0,1,2,3,4,5,6]
  }
  // //trigger methods
  triggerAttack = function(val, vel=100, time=null){
    this.v = this.getNewVoice(val)
    if(time){
      this.voice[this.v].triggerAttack(val,vel,time)
    } else{
      this.voice[this.v].triggerAttack(val,vel)
    }
  }
  triggerRelease = function(val,  time=null){
    this.v = this.getActiveVoice(val)
    if(this.v < 0) return
    if(time){
      this.voice[this.v].triggerRelease(time)
    } else{
      this.voice[this.v].triggerRelease()
    }
  }
  triggerAttackRelease = function(val,vel=100, dur=0.01, time=null){
    this.v = this.getNewVoice(val)
    if(time){
      this.voice[this.v].triggerAttackRelease(val, vel, dur, time)
    } else{
      this.voice[this.v].triggerAttackRelease(val, vel, dur)
    }
  }//attackRelease
  // //voice management
  getNewVoice(num) {
    if (this.voiceCounter >= this.numVoices) {
      this.voiceCounter = 0; // Reset voice counter if it exceeds the number of voices
    }
    //console.log('new voice ', num, this.voiceCounter);

    //keep track of note order
    this.prevNote = this.noteOrder.shift();
    this.noteOrder.push(num);

    // Look for free notes
    for (let i = 0; i < this.numVoices; i++) {
      //if note is already playing free it
      if(this.activeNotes[i] == num ) this.triggerRelease(num)
      
    }
    for (let i = 0; i < this.numVoices; i++) {
    //look for free voice
      const index = (i + this.voiceCounter) % this.numVoices;
      if (this.activeNotes[index] < 0) {
        this.activeNotes[index] = num;
        this.voiceCounter = (index + 1) % this.numVoices; // Prepare for the next voice
        //console.log('free voice, assigned to voice', index)
        return index;
      }
    }

      this.voiceCounter = (this.voiceCounter + 1) % this.numVoices; // Prepare for the next voice
      return this.voiceCounter
    
    // // If no inactive voice, replace the oldest note
    // if (this.prevNote !== undefined) {
    //   const oldestNoteIndex = this.activeNotes.indexOf(this.prevNote);
    //   if (oldestNoteIndex !== -1) {
    //     this.activeNotes[oldestNoteIndex] = num;
    //     this.voiceCounter = (oldestNoteIndex + 1) % this.numVoices; // Update for the next voice
    //     console.log('steal voice', this.voiceCounter)
    //     return oldestNoteIndex;
    //   }
    // }

    // Fallback if the above logic didn't return
    //console.log('fallback', this.voiceCounter)
    const returnValue = this.voiceCounter;
    this.voiceCounter = (this.voiceCounter + 1) % this.numVoices;
    return returnValue;
  }
  getActiveVoice= function(num){    
    for(let i=0;i<this.numVoices;i++){
      if(this.activeNotes[i]==num){
        this.activeNotes[i] = -1
        //console.log('voice freed ', i)
        return i
      }
    }
    return -1
  }//getActiveVoice
  panic = function(){
    for(let i=0;i<this.numVoices;i++){
      this.voice[i].env.triggerRelease()
      //this.voice[i].vcf_env.triggerRelease()
      this.activeNotes[i]  = -1
    }
  }
  // //setters
  setResonance = function(val){
    for(let i=0;i<this.numVoices;i++) {
      this.voice[i].resonance.value = val
    }
  }
  setDamping = function(val){
    for(let i=0;i<this.numVoices;i++) {
      this.voice[i].delay_1.dampening = val
      this.voice[i].delay_2.dampening = val
    }
  }
  setCutoff = function(val){
    for(let i=0;i<this.numVoices;i++) this.voice[i].lowpassCutoffSignal.value = val
    this.lpf.frequency.value = val*2
  }
  setQ = function(val){
    for(let i=0;i<this.numVoices;i++) this.voice[i].lpf.Q.value = val
  }
  setHighpass = function(val){
    for(let i=0;i<this.numVoices;i++) this.voice[i].highpassCutoffSignal.value = val
  }
  setADSR = function(a,d,s,r){
    for(let i=0;i<this.numVoices;i++) {
      this.voice[i].env.attack = a
      this.voice[i].env.decay = d
      this.voice[i].env.sustain = s
      this.voice[i].env.release = r
    }
  }
  setDecay(val){
    val = val<0 ? 0.001 : val
    for(let i=0;i<this.numVoices;i++) {
      this.voice[i].env.release = val
      this.voice[i].env.decay = val
    }
  }
  setClip(val){
    this.clip.rampTo(val,0.02)
  }
  setChoke(val){
    for(let i=0;i<this.numVoices;i++) {
    this.voice[i].choke.rampTo(-val/2,0.2)
  }
  }
  setDetune(val){
    for(let i=0;i<this.numVoices;i++) {
      this.voice[i].detune.value = val
    }
  }
  setDry(val){
    for(let i=0;i<this.numVoices;i++) {
      this.voice[i].dry.value = val
    }
  }
  setEnvDepth(val){
    for(let i=0;i<this.numVoices;i++) {
      this.voice[i].env_depth.factor.value = val
    }
  }
  connect(destination) {
    if (destination.input) {
      this.output.connect(destination.input);
    } else {
      this.output.connect(destination);
    }
  }
}

/*
Kick

vco->shaper_gain->waveShaper->vca->output
env->pitch_drop->vco.frequency

basic kick drum voice:
methods:
trigger(time)

properties:

*/

;
;

class Kick{
  constructor(freq=60,decay=.4,tone=.2) {
    this.vco = new Tone.Oscillator().start()
    this. shaper_gain = new Tone.Multiply(tone)
    this. waveShaper = new Tone.WaveShaper((x)=>{
      return Math.tanh(x*16) *.9
    })
    this.vca = new Tone.Multiply()
    this.output = new Tone.Multiply(.5)
    //
    this.pitch_env = new Tone.Envelope()
    this.pitch_env_depth = new Tone.Multiply()
    this.frequency = new Tone.Signal(freq)
    this.env = new Tone.Envelope()
    //
    this.vco.connect( this.vca)
    this.vca.connect( this.shaper_gain)
    this.shaper_gain.connect( this.waveShaper)
    this.waveShaper.connect( this.output)
    //
    this.pitch_env.connect( this.pitch_env_depth)
    this.pitch_env_depth.connect( this.vco.frequency)
    this.frequency.connect( this.vco.frequency)
    this.env.connect(this.vca.factor)
    //
    this.env.decay = decay
    this.env.release = decay
    this.env.sustain = 0
    this.env.attack = .03
    //
    this.pitch_env.attack = 0.00
    this.pitch_env.decay = 1
    this.pitch_env.sustain = 0
    this.pitch_env.release = .1
  }
  trigger = function(time){
    if(time){
      this.env.triggerAttackRelease(0.01, time)
      this.pitch_env.triggerAttackRelease(0.01,time)
    }else {
      this.env.triggerAttackRelease(0.01)
      this.pitch_env.triggerAttackRelease(0.01)
    }
  }
  connect(destination) {
    if (destination.input) {
      this.output.connect(destination.input);
    } else {
      this.output.connect(destination);
    }
  }

  disconnect(destination) {
    if (destination.input) {
      this.output.disconnect(destination.input);
    } else {

      this.output.disconnect(destination);
    }
  }
}


/*
MidiOut
 
 Overrides ParseNoteOut to send Midi messages

*/
;
;
//;
;
;


class MidiOut extends MonophonicTemplate {
  constructor (gui = null) {
    super()
    this.isGlide = false
    this.name = "MidiOut"
    console.log(this.name, " loaded")
    this.midiOutput = midiHandlerInstance
    this.channel = 1

    
  }//constructor

  triggerAttackRelease(val, vel = 100, dur = 0.01, time = null) {
    console.log('AR', val, vel, time);

    // Calculate absolute start and end times
    const startTime = time ? Tone.now() + Tone.Time(time).toSeconds() : Tone.now();
    const endTime = startTime + Tone.Time(dur).toSeconds();

    // Schedule Note On and Note Off messages for MIDI output
    if (this.midiOutput) {
        const channel = this.channel || 1; // Default to channel 1
        const midiNote = val;

        //this.midiOutput.sendNoteOn(midiNote, vel);
        Tone.Draw.schedule(() => {
            this.midiOutput.sendNoteOn( midiNote, vel);
        }, time);

        Tone.Draw.schedule(() => {
            this.midiOutput.sendNoteOff(midiNote, 0);
        }, time+dur);
    }
}

  parseNoteString(val, time, num, index){
        //console.log(val) //[value, time as a fraction of a beat]
        if(val[0] === ".") return
        
        const usesPitchNames = /^[a-ac-zA-Z]$/.test(val[0][0]);

        let note = ''
        //console.log(val[0], usesPitchNames)
        if( usesPitchNames ) note =  pitchNameToMidi(val[0])
        else note = intervalToMidi(val[0], this.min, this.max)
        const div = val[1]
        if(note < 0) return
        //console.log(note, this.velocity[num], this.sustain[num], time)

        //check for velocity,octave,sustain, and roll arrays
        let octave = this.getNoteParam(this.octave[num],index)
        let velocity = this.getNoteParam(this.velocity[num],index)
        let sustain = this.getNoteParam(this.sustain[num],index)
        //let roll = getNoteParam(this.roll[num],this.index[num])
        //console.log(note + octave*12, velocity, sustain)
        try{
            this.triggerAttackRelease(note + octave*12, velocity, sustain, time + div * (Tone.Time(this.subdivision[num])));
        } catch(e){
            console.log('invalid note', note + octave*12, velocity, sustain)
        }
    }

}


;
//;
;


class QuadPanner extends MonophonicTemplate{
    constructor() {
        super()
        this.context = window.audioContext;

        // Create the ChannelMergerNode with the specified number of channels
        this.channelMerger = this.context.createChannelMerger(4);

        // Configure the audio context destination for multi-channel output
        let maxChannelCount = window.audioContext.destination.maxChannelCount;
        window.audioContext.destination.channelCount = maxChannelCount;
        window.audioContext.destination.channelCountMode = "explicit";
        window.audioContext.destination.channelInterpretation = "discrete";
        
        // Create and connect a channel merger
        //this.channelMerger.channelCount = 1;
        this.channelMerger.channelCountMode = "explicit";
        this.channelMerger.channelInterpretation = "discrete";
        this.channelMerger.connect(window.audioContext.destination);
   
        this.input = new Tone.Multiply(1)

        this.channel = []
        for(let i=0;i<4;i++){
            this.channel.push(new Tone.Multiply(.5))
            this.input.connect(this.channel[i])
            this.channel[i].connect(this.channelMerger, 0,i);
        }
        // Make the channelMerger available for external connections
        this._x = 0
        this._y = 0
        this.output = this.channelMerger;
    }

    // Set x-axis (left-right) panning using the LR panner
    x(value=.5) {
        this._x = value
        this.pan(this._x,this._y)
    }

    // Set y-axis (front-back) panning using the FB panner
    y(value=.5) {
        this._y = value
        this.pan(this._x,this._y)
    }

    pan(x = 0.5, y = 0.5) {
    x = Math.max(-1, Math.min(1, x));
    y = Math.max(-1, Math.min(1, y));
    let curve = 0.7;
    let base_amp = -70;

    // Calculate gain values
    const gainFL = Math.pow((1 - x) * (1 - y), curve); // Front-Left
    const gainFR = Math.pow((1 + x) * (1 - y), curve); // Front-Right
    const gainBL = Math.pow((1 - x) * (1 + y), curve); // Back-Left
    const gainBR = Math.pow((1 + x) * (1 + y), curve); // Back-Right

    // Smooth transition over 10 ms
    const rampTime = 0.01; // 10 ms in seconds
    this.channel[0].factor.rampTo(gainFL, rampTime);
    this.channel[1].factor.rampTo(gainFR, rampTime);
    this.channel[2].factor.rampTo(gainBR, rampTime);
    this.channel[3].factor.rampTo(gainBL, rampTime);

    // Optionally log values for debugging
    // console.log(x, y, gainFL, gainFR, gainBL, gainBR);
}

    circle(angle, depth = 1) {
        // Convert angle from degrees to radians
        const radians = (angle * Math.PI) / 180;

        // Calculate x and y positions based on the angle and depth
        const x = Math.cos(radians) * depth;
        const y = Math.sin(radians) * depth;

        // Set x and y positions
        this._x = x;
        this._y = y;

        // Call the pan function with the calculated positions
        this.pan(this._x, this._y);
    }

    // Dispose of all nodes
    dispose() {
        this.lrPanner.dispose();
        this.fbPanner.dispose();
        this.splitter.disconnect();
        this.channelMerger.disconnect();
        console.log("SimpleQuadPanner disposed.");
    }

}

/*
Percussion Voice

*/

;
;

class Percussion{
    constructor(type) {
        console.log(type)
    }

    trigger = function(time){
        if(time){
            this.env.triggerAttackRelease(0.01, time)
            this.pitch_env.triggerAttackRelease(0.01,time)
        }else {
            this.env.triggerAttackRelease(0.01)
            this.pitch_env.triggerAttackRelease(0.01)
        }
    }

    connect(destination) {
        if (destination.input) {
            this.output.connect(destination.input);
        } else {
            this.output.connect(destination);
        }
    }

    disconnect(destination) {
        if (destination.input) {
            this.output.disconnect(destination.input);
        } else {
            this.output.disconnect(destination);
        }
    }
}


/*
 * Simple Sampler
 *
 * 
*/
;
;
//;
;



class CustomPlayer extends Tone.Player {
    set playbackRate(rate) {
        this._playbackRate = rate;
        const now = this.now();

        // Custom logic or modifications
        //console.log("Custom playback rate set:", rate);

        // Original logic
        // const stopEvent = this._state.getNextState("stopped", now);
        // if (stopEvent && stopEvent.implicitEnd) {
        //     this._state.cancel(stopEvent.time);
        //     this._activeSources.forEach((source) => source.cancelStop());
        // }
        this._activeSources.forEach((source) => {
            source.playbackRate.setValueAtTime(rate, now);
        });
    }
}


class Player extends MonophonicTemplate {
    constructor (file) {
        super()
        // this.gui = gui
        //this.presets = SimplerPresets
        this.name = "Player"
        
        //audio objects
        this.player = new CustomPlayer()
        this.vcf = new Tone.Filter()
        this.vca = new Tone.Multiply(1)
        this.output = new Tone.Multiply(1)
        this.cutoffSig = new Tone.Signal(10000)

        //vcf setup
        this.cutoffSig.connect(this.vcf.frequency)
        this.vcf.frequency.value = 10000
        this.vcf.rolloff = -12
        this.vcf.Q.value = 1

        //Set up filter envelope
        this.filterEnv = new Tone.Envelope()
        this.vcfEnvDepth = new Tone.Multiply()
        this.filterEnv.connect(this.vcfEnvDepth)
        this.vcfEnvDepth.connect(this.vcf.frequency)

        //connect vcf to vca
        this.player.connect(this.vcf)
        this.vcf.connect(this.vca)
        this.vca.connect(this.output)

        this.sample = ''
        this.sampleDuration = 0
        this._baseUnit = 16
        this.seqControlsPitch = false
        this._start = 0
        this._end = 100
        this._playbackRate = 1
        this._baseNote = 60

        let paramDefinitions = [
          {name:'volume',value: -6,min:-36,max:0,curve:1,callback:x=>this.player.volume.value = x},
          {name:'cutoff',value:20000,min:100,max:10000,curve:2,callback:value=>this.cutoffSig.value = value},
          {name:'Q',min:0.0,value:0,max:20,curve:2,callback:value=>this.vcf.Q.value = value},
          {name:'filterType',value:'lowpass',min:0.0,max:20,curve:2,callback:value=>this.vcf.type = value},
          {name:'filterEnvDepth',value:0,min:0.0,max:5000,curve:2,callback:value=>this.vcfEnvDepth.factor.value = value},
            {name:'loopStart',value:0,min:0,max:10000,curve:1,callback:x=>this.player.loopStart =x},
            {name:'loopEnd',value:1,min:0,max:10000,curve:1,callback:x=>this.player.loopEnd =x},
            {name:'loop',value:false, min:0,max:1,curve:1,callback:x=>this.player.loop = x>0},
            {name:'fadeIn',value:0.005, min:0,max:10,curve:3,callback:x=>this.player.fadeIn =x},
            {name:'fadeOut',value: 0.1,min:0,max:10,curve:3,callback:x=>this.player.fadeOut =x},
            {name:'baseUnit',value:16, min:0,max:60000,curve:1,callback:x=>this._baseUnit =x},
            {name:'playbackRate',value:1,min:0,max:1000,curve:1,callback:x=>{
                if(x<0)this.player.reverse = 1
                this._playbackRate=Math.abs(x); 
                this.player.playbackRate = Math.abs(x)
            }},
            {name:'sequenceTime',value:true,min:0,max:1,curve:1,callback:x=>this.seqControlsPitch = !x},
            {name:'startTime',value:0, min:0,max:10000,curve:1,callback:x=>this._start = x},
            {name:'endTime',value:1, min:0,max:10000,curve:1,callback:x=>this._end = x},
            {name:'baseNote',min:0,max:127,curve:1,callback:x=>this._baseNote = x},
            {name:'reverse',value:false, min:0,max:1,curve:1,callback:x=> {
                if(x>0) this.player.reverse = 1
                else this.player.reverse = 0
            }},
       
        ]

        let paramGui = [
          {name:'volume',x:10,y:10,color:'red'},
          {name:'attack',min:0.01,max:1,curve:2,callback:x=>{this.player.attack=x}},
          {name:'release',min:.01,max:10,curve:2,callback:x=>{ this.player.release=x }},
          {name:'cutoff',min:100,max:10000,curve:2,callback:value=>this.cutoffSig.value = value},
          {name:'Q',min:0.0,max:20,curve:2,callback:value=>this.vcf.Q.value = value},
          {name:'filterEnvDepth',min:0.0,max:5000,curve:2,callback:value=>this.vcfEnvDepth.factor.value = value},
          ]

        this.param = this.generateParameters(paramDefinitions)
        this.createAccessors(this, this.param);
        //this.attachGuiToParams()

        this.sampleFiles = {
          bell: ['C4', 'berklee/bell_1.mp3'],
          bell1:   ['C4', 'berklee/bell_1a.mp3'],
          bell2:   ['C4', 'berklee/bell_2a.mp3'],
          bell3:   ['C4', 'berklee/bell_mallet_2.mp3'],
          horn:['C4', 'berklee/casiohorn2.mp3'],
          chotone:  ['C4', 'berklee/chotone_c4_!.mp3'],
          voice: ['C4', 'berklee/femalevoice_aa_Db4.mp3'],
          kalimba: ['C4', 'berklee/Kalimba_1.mp3'],
          dreamyPiano: ['A5', 'salamander/A5.mp3'],
          softPiano: ['A4', 'salamander/A4.mp3'],
          piano: [45, 'salamander/A3.mp3'],
          casio:['C4', 'casio/C2.mp3']
        }

        if(file) this.loadSample(file)
    }

    /**
   * Load a specific sample.
   * @param {string} file - The name of the sample to load.
   */
    load(file = null){this.loadSample(file)}
    loadSample(file = null){
        if(file === null) {
            this.loadAudioBuffer()
            return
        }

        // If the file is a number, treat it as an index into the sampleFiles object
        if (typeof file === 'number') {
            // Convert the keys of the sampleFiles object to an array
            const fileKeys = Object.keys(this.sampleFiles);
            file = Math.floor(file)%fileKeys.length
            file = fileKeys[file];
        }

        if (file in this.sampleFiles) {
          console.log(`Player loading ${file}`);
          this.sample = file
        } else {
            try{
                this.player.load(file)
                console.log('file loaded from ', file)
                this.getSampleDuration()
                return
            }catch{}
          console.error(`The sample "${file}" is not available.`);
          return
        }

        this.baseUrl = "https://tonejs.github.io/audio/"
        const url = this.sampleFiles[this.sample][1]
        const note = this.sampleFiles[this.sample][0]
        console.log(note, url)
        this.player.load(this.baseUrl.concat(url), () => {
            const duration = this.player.buffer.length / Tone.context.sampleRate;
            console.log(`Sample duration: ${duration.toFixed(2)} seconds`);
        });
    }

    listSamples(){
        const fileKeys = Object.keys(this.sampleFiles);
        console.log(fileKeys)
    }

    //envelopes
    trigger(freq=0, amp=127, dur=0.1, time=null){
        this.triggerAttackRelease (freq, amp, dur, time)
    }

    triggerAttack (freq, amp=100, time=null){ 
        const dur = 100
        amp = amp/127
        if(time){
            if(!this.seqControlsPitch) {
                if(this._playbackRate!= this.player.playbackRate) this.player.playbackRate = this._playbackRate
                this.player.start(time,freq, dur)
            }
            else {
                this.player.playbackRate = this.midiToRate(freq)
                this.player.start(time, this._start, dur)
            }
            this.filterEnv.triggerAttack(time+.0)
            this.vca.factor.setValueAtTime(amp, time+.0)
        } else{
            if(!this.seqControlsPitch) {
                if(this._playbackRate!= this.player.playbackRate) this.player.playbackRate = this._playbackRate
                this.player.start(Tone.now(),freq, dur)
            }
            else {
                //console.log('pitch',freq,amp,dur,time)
                this.player.playbackRate = this.midiToRate(freq)
                this.player.start(Tone.now(), this._start, dur)
            }
            this.filterEnv.triggerAttack()
            this.vca.factor.setValueAtTime(amp)
        }
    }
    
    triggerRelease (freq, time=null){
        if(time){
            this.player.stop(time)
            this.filterEnv.triggerRelease(time+.0)
        } else{
            this.player.stop()
            this.filterEnv.triggerRelease()
        }
    }

    triggerAttackRelease (freq, amp, dur=0.01, time=null){ 
        //console.log(freq,amp,dur,time)
        amp = amp/127
        dur+=.2
        if(time){
            if(!this.seqControlsPitch) {
                //console.log('noy', freq,dur)
                if(this._playbackRate!= this.player.playbackRate) this.player.playbackRate = this._playbackRate
                this.player.start(time,freq)
            }
            else {
                //console.log('pitch',dur.toFixed(2), this._start,time)
                this.player.playbackRate = this.midiToRate(freq)
                this.player.start(time, this._start)
            }
            this.filterEnv.triggerAttackRelease(dur,time)
            this.vca.factor.setValueAtTime(amp, time)
         } 
        //else{
        //     if(!this.seqControlsPitch) {
        //         if(this._playbackRate!= this.player.playbackRate) this.player.playbackRate = this._playbackRate
        //         this.player.start(Tone.now(),freq, dur)
        //     }
        //     else {
        //         //console.log('pitch',freq,amp,dur,time)
        //         this.player.playbackRate = this.midiToRate(freq)
        //         this.player.start(Tone.now(), this._start, dur)
        //     }
        //     this.filterEnv.triggerAttackRelease(dur)
        //     this.vca.factor.setValueAtTime(amp)
        // }
    }//attackRelease

    midiToRate(note){
        //console.log(Math.pow(2, (note - this._baseNote) / 12));
        return Math.pow(2, (note - this._baseNote) / 12);
    }

    connect(destination) {
        if (destination.input) {
            this.output.connect(destination.input);
        } else {
            this.output.connect(destination);
        }
    }
    // Function to open a file dialog and load the selected audio file
    loadAudioBuffer() {
        // Create a file input element programmatically
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'audio/*'; // Accept only audio files

        // Handle file selection
        fileInput.onchange = (event) => {
            const file = event.target.files[0];
            if (!file) {
                console.log("No file selected");
                return;
            }

            // Use FileReader to read the file as a Data URL
            const fileReader = new FileReader();
            fileReader.onload = () => {
                // Create a Tone.Player and load the Data URL
                this.player = new CustomPlayer(fileReader.result).connect(this.vcf);
                this.player.autostart = false; // Automatically start playback
                console.log("Audio loaded into player");
                this.getSampleDuration()
            };
            fileReader.readAsDataURL(file);
        };

        // Trigger the file dialog
        fileInput.click();
    }
    getSampleDuration(){
        setTimeout(()=>{
            const duration = this.player._buffer.length / Tone.context.sampleRate;
            if(duration>0){
                console.log(`Sample duration: ${duration.toFixed(2)} seconds`)
                this.sampleDuration = duration
            } else{
                this.getSampleDuration()
            }
        },100);
    }

    /**
     * Sequences the provided array of notes and initializes a Tone.Loop with the given subdivision.
     *
     * @param {string} arr - The sequence of notes as a string.
     * @param {string} [subdivision] - The rhythmic subdivision for the loop (e.g., '16n', '8n').
     * @param {string} num (default 0) - the sequence number. Up to 10 sequences per instance.
     */
    sequence(arr, subdivision = '8n', num = 0, phraseLength = 'infinite') {
        if (!this.seq[num]) {
            this.seq[num] = new Seq(this, arr, subdivision, phraseLength, num, this.parseNoteString.bind(this));
        } else {
            this.seq[num].sequence(arr, subdivision, phraseLength);
        }
        this.start(num);
    }

    /*
    For Player the sequencer controls the sample start time by default.
    - sample start times are normalized where 0-1 is the length of the sample
    this.seqControlsPitch allows controlling sample pitch instead
    */
    parseNoteString(val, time, index, num){
        if(this.sampleDuration==0){
                console.log(`Sample duration: 0 seconds`)
                this.getSampleDuration()
                return;
            } 
        //console.log(val,val[0]*this.sampleDuration,time,num)
        
        //uses val for time location rather than pitch
        if(val[0] === ".") {
            if(this.player.state === 'started') this.player.stop(time)
            return
        }

        const usesPitchNames = /^[a-ac-zA-Z]$/.test(val[0][0]);

        let note = ''
        //console.log()
        //console.log(val[0], usesPitchNames)
        if(!this.seqControlsPitch){
            if( usesPitchNames ) {
                console.log('player seq values are time positions in the sample')//note =  pitchNameToMidi(val[0])
                return
            } 
            //note = val[0]*this._baseUnit + this._start//intervalToMidi(val[0], this.min, this.max)
            note = val[0]*this.sampleDuration
        } else{
            if( usesPitchNames ) note =  pitchNameToMidi(val[0])
            else note = intervalToMidi(val[0], this.min, this.max)
        }
        const div = val[1]
        if(note < 0) return

        let octave = this.getSeqParam(this.seq[num].octave, index);
        let velocity = this.getSeqParam(this.seq[num].velocity, index);
        let sustain = this.getSeqParam(this.seq[num].sustain, index);
        let subdivision = this.getSeqParam(this.seq[num].subdivision, index);
        if(!this.seqControlsPitch) note = note / this._baseUnit
        note = note+octave
        //console.log(note, velocity, sustain, time)
      // this.player.start(time + div * (Tone.Time(this.subdivision[num])), note, this.sustain[num]);
   //return
       try{
            this.triggerAttackRelease(note, velocity, sustain, time + div * Tone.Time(subdivision));
        } catch(e){
            console.log('invalid note', note , velocity, sustain)
        }
    }
}


/********************
 * polyphony
 ********************/

;
;
;


class Polyphony extends MonophonicTemplate{
	constructor(voice,num=8, gui= null){
		super()
    this.gui = gui
    this.name = voice.name
		this.numVoices = num
		this.slop = .05

		//audio
		this.voice = []
		for(let i=0;i<this.numVoices;i++) this.voice.push(new voice)
		this.output = new Tone.Multiply(1/this.numVoices)
		this.hpf = new Tone.Filter({type:'highpass', rolloff:-12, Q:0, cutoff:50})
		for(let i=0;i<this.numVoices;i++) this.voice[i].output.connect( this.hpf)
		this.hpf.connect(this.output)

	    //voice tracking
		this.prevNote = 0
		this.v = 0
		this.voiceCounter = 0
		this.activeNotes = []
		this.noteOrder = []
		this.noteOrderIndex = 0
		this.voiceOrder = []
		for (let i = 0; i < this.numVoices; i++) {
			this.activeNotes.push(-1)
			this.noteOrder.push(i)
		}
	}

	/**************** 
	 * trigger methods
	***************/
	triggerAttack = function(val, vel=100, time=null){
		//console.log('ta ', val)
		this.v = this.getNewVoice(val)
		//val = val + Math.random()*this.slop - this.slop/2
		if(time) this.voice[this.v].triggerAttack(val,vel,time) //midinote,velocity,time
		else this.voice[this.v].triggerAttack(val,vel) 
		//console.log("att ", val)
	}

	triggerRelease = function(val, time=null){
		this.v = this.getActiveNote(val)
		if (this.v >= 0 && this.v != undefined){
			//console.log('tr ', val, time, this.activeNotes[val], this.v, this.voice[this.v])
			if(time) this.voice[this.v].triggerRelease(time) //midinote,velocity,time
			else this.voice[this.v].triggerRelease() 
			this.freeActiveNote(val)
		//console.log("rel ", val)
		} else{
			console.log('tr null', val, time, this.activeNotes[val], this.v, this.voice[this.v])
		}
	}

	triggerAttackRelease = function(val, vel=100, dur=0.01, time=null){
		this.v = this.getNewVoice(val)
		//val = val + Math.random()*this.slop - this.slop/2
		if(time){
			this.voice[this.v].triggerAttackRelease(val, vel, dur, time)
		} else{
			this.voice[this.v].triggerAttackRelease(val, vel, dur)
		}
		//console.log("AR ", val,dur)
	}

    /** VOICE MANAGEMENT **/

    // Get a free voice or steal an old voice
	getNewVoice(noteNum) {
		// Increment and wrap voice counter for round-robin assignment
		this.voiceCounter = (this.voiceCounter + 1) % this.numVoices;

		// Free any voice currently playing the requested note
		const curIndex = this.getActiveNote(noteNum);
		if (curIndex >= 0 ) {
			this.freeActiveNote(curIndex);
		}

		// Try to find a free voice
		let weakestEnvValue = Infinity;
		let leastRecent = this.getLeastRecentNotes()
		let weakestVoice = leastRecent[0];

		for (let i = 0; i < this.numVoices/2; i++) {
			const curElement = this.noteOrder[i];
			const curEnv = this.voice[curElement].env.value;
			if (curEnv < weakestEnvValue && leastRecent.includes(curElement)) {
			  weakestEnvValue = curEnv;
			  weakestVoice = curElement;
			}
			
			// Check if the envelope indicates a free voice
			if (curEnv <= 0.01) { // Allow small floating-point tolerances
			  this.setActiveNote(curElement, noteNum);
			  return curElement;
			}
		}
		// No free voices: Implement voice stealing
		// Steal the weakest voice
		this.voice[weakestVoice].env.cancel();
		this.setActiveNote(weakestVoice, noteNum);
		return weakestVoice;
	}

  // Get the index of a specific active note, or -1 if the note is not active
    getActiveNote(midiNote) {
    	if(this.activeNotes.includes(midiNote)) return this.activeNotes.indexOf(midiNote);
    	else return -1
    }

    // Set a new active note (add it to the array)
    setActiveNote(index, midiNote) {
		//console.log('set active', index, midiNote, this.noteOrder);

		// Add the note only if it isn't already active
		if (!this.activeNotes.includes(midiNote))  this.activeNotes[index] = midiNote;

		// Update the noteOrder array
		// Remove the index if it already exists in the array
		const existingIndex = this.noteOrder.indexOf(index);
		if (existingIndex !== -1) this.noteOrder.splice(existingIndex, 1);

		this.noteOrder.push(index); // Add the index to the
		}
    getLeastRecentNotes() {
    	return this.noteOrder.slice(0,this.numVoices/2)
	}

    // Free a specific active note (remove it from the array)
    freeActiveNote(index) {
        if (this.voice[index] !== undefined && index >= 0) {
        	this.voice[index].triggerRelease()
            this.activeNotes[index] = -1;  // Remove the note if found
        }
    }


	/**
     * Set the ADSR values for the envelope
     * @param {number} a - Attack time
     * @param {number} d - Decay time
     * @param {number} s - Sustain level
     * @param {number} r - Release time
     * @returns {void}
     * @example synth.setADSR(0.01, 0.1, 0.5, 0.1)
     */
    setADSR(a, d, s, r) {
    	for(let i=0;i<this.numVoices;i++){
    		if (this.voice[i].env) {
	            this.voice[i].env.attack = a>0.001 ? a : 0.001
	            this.voice[i].env.decay = d>0.01 ? d : 0.01
	            this.voice[i].env.sustain = Math.abs(s)<1 ? s : 1
	            this.voice[i].env.release = r>0.01 ? r : 0.01
        	}
    	}
    }

    /**
     * Set the ADSR values for the filter envelope
     * @param {number} a - Attack time
     * @param {number} d - Decay time
     * @param {number} s - Sustain level
     * @param {number} r - Release time
     * @returns {void}
     * @example synth.setFilterADSR(0.01, 0.1, 0.5, 0.1)
     */ 
    setFilterADSR(a, d, s, r) {
    	for(let i=0;i<this.numVoices;i++){
	        if (this.voice[i].vcf_env) {
	            this.voice[i].vcf_env.attack = a>0.001 ? a : 0.001
	            this.voice[i].vcf_env.decay = d>0.01 ? d : 0.01
	            this.voice[i].vcf_env.sustain = Math.abs(s)<1 ? s : 1
	            this.voice[i].vcf_env.release = r>0.01 ? r : 0.01
	        }
	    }
    }


initGui(selfRef, gui) {
  this.voice[0].super = selfRef;
  this.voice[0].initGui(gui);
  const elements = this.voice[0].gui_elements;

  // Function to modify the value expression by replacing 'x' with 'e'
  const modifyValueExpression = (val) => val ? val.replace(/\bx\b/g, 'e') : null;
  //const modifyValueExpression = (val) => val// ? val.replace(/\bx\b/g, 'e') : null;

	function stringIsFunction(variableName, context = window) {
		return /\(.*\)/.test(variableName)
  	}

	function getFunctionDetails(funcString) {
	  // Remove any extra spaces and the "x => " part
	  funcString = funcString.trim().replace(/^.*=>\s*/, '');

	  // Check if the function is a block (has curly braces)
	  if (funcString.startsWith('{') && funcString.endsWith('}')) {
	    // Extract the code inside the curly braces
	    funcString = funcString.slice(1, -1).trim();
	  }

	  // Now try to match the function call and capture the function name and arguments
	  const match = funcString.match(/([a-zA-Z_$][0-9a-zA-Z_$]*)\s*\((.*)\)/);
	  if (match) {
	    const functionName = match[1];
	    const argsString = match[2];
	    return { functionName, argsString };
	  }

	  return null;
	}

  // Function to generate a new callback based on the parameter and value expression
  /* Three cases
  		- x => param.value = x
  		- x => param.value = function(x)
  		- function(x)
  */
  const createCallback = (param, val, element) => {
  	
  	const modifiedVal = modifyValueExpression(val);
  	let voiceTarget = this.voice[0];

  	let keys = param.split('.');
     const lastKey = keys[keys.length - 1];

     //console.log('cb', param, val, keys)

	if (!val) {
		const modifiedParam = modifyValueExpression(param);
	     const funcDetails = getFunctionDetails(modifiedParam);
	    // console.log('details', funcDetails, modifiedParam)
		if (!funcDetails) {
		console.error("Invalid function string");
		return null;
		}

		const { functionName, argsString } = funcDetails;

		// console.log('cb is function', param, val, functionName, argsString)
		if (!functionName) {
		console.error("Invalid function string");
		return null;
		}

		// Return a new function that updates the target for each voice
		return (e) => {
		  for (let j = 0; j < this.numVoices; j++) {
		    const func = this.voice[j][functionName];

		    let voiceTarget = this.voice[j];
		    for (let k = 0; k < keys.length - 1; k++) {
		      voiceTarget = voiceTarget[keys[k]];
		    }

		    const evaluatedArgs = argsString.replace(/\bx\b/g, e);
		    //console.log('args', evaluatedArgs, argsString)
		    let argsArray;
		    try {argsArray = new Function('e', `return [${evaluatedArgs}]`)(e);} 
		    catch (error) {}
		    //console.log(j,'func1', this.voice[j][functionName], argsArray)
		    try { this.voice[j][functionName](...argsArray);} catch (error) {}
		  }
		};
 	}//done

    else {
      for (let k = 0; k < keys.length - 1; k++) {

        if (voiceTarget[keys[k]] === undefined) {
          console.log('Voice target undefined');
          return;
        }
        voiceTarget = voiceTarget[keys[k]];
      }
      //console.log(param, modifiedVal, lastKey, stringIsFunction(modifiedVal, this))
      
      //if a function is used to get the value of x
      //e.g. x=> this.param.value = function(x)
      if( stringIsFunction(modifiedVal, this) ){
      	const modifiedVal2 = modifiedVal.replace(/^this\./, '').replace(/\(.*\)$/, '');
      	let func = this.voice[0][modifiedVal2]
      	console.log('value is function', func, param, modifiedVal2)
      	return (e) => {
      		for (let j = 0; j < this.numVoices; j++) {
      			let func = this.voice[j][modifiedVal2]
      			voiceTarget = this.voice[j]
      			for (let k = 0; k < keys.length - 1; k++) voiceTarget = voiceTarget[keys[k]];
	      		voiceTarget[lastKey] = func(e);
	      		//console.log(j,'func2', voiceTarget, modifiedVal)
	    	}
      	}
      }//done

		//if the value being set uses .value
      return (e) =>{
      	//console.log(param, e)
      	this.set(param, eval(e))
      }
    }
  };//createCalback

  // Main loop to iterate over GUI elements and set their callbacks
  elements.forEach((element) => {
  	//console.log(element, element.callback)
    try {
      if (!element.callback) return;

      const funcString = element.callback.toString();
      if (funcString.includes('this.super')) return;

      let param = this.generateParamString(element.callback);
      const val = this.retrieveValueExpression(element.callback);

      if (!param) {
        param = this.applyFunctionToAllVoices(element.callback);
      }

      const callback = createCallback(param, val, element);
      //console.log(element, callback)
      element.callback = callback;
    } catch (error) {
      console.log('Invalid GUI element:', element, error);
    }
  });
}

	/**
     * Hide the GUI
     * @returns {void}
     */
    hideGui() {
        for (let i = 0; i < this.voice[0].gui_elements.length; i++) {
            //console.log(this.gui_elements[i])
            this.voice[0].gui_elements[i].hide = true;
        }
    }

    /**
     * Show the GUI
     * @returns {void}
     */
    showGui() {
        for (let i = 0; i < this.voice[0].gui_elements.length; i++) this.voice[0].gui_elements[i].hide = false;
    }

	applyFunctionToAllVoices(f) {
	    let fnString = f.toString();
	    // Perform the replacement and assign the result back
	    fnString = fnString.replace(/\bthis\./g, '');
	    //console.log("Modified function string:", fnString);

	    return fnString
	}

	stringToFunction(funcString) {
	   // Split by '=>' to get parameters and body for functions without 'this.super'
	    const parts = funcString.split('=>');
	    const params = parts[0].replace(/\(|\)/g, '').trim();  // Extract the parameter
	    let body = parts[1].trim();  // The function body

	    // Replace occurrences of 'this.' for the voice context
	    body = body.replace(/\bthis\./g, 'this.voice[i].');

	    // Prefix standalone function calls with 'this.'
	    body = body.replace(/(?<!this\.|this\.super\.)\b(\w+)\(/g, 'this.$1(');

	    // // Log the modified function for debugging purposes
	    // console.log('params:', params);
	    // console.log('modified body:', body);

	    return new Function('i', params, body);  // Create a function that accepts 'i' (voice index) and params
	}


	// Function to generate the parameter string from an assignment
	 generateParamString(assignment) {
    const fnString = assignment.toString();
    //console.log('param:', fnString);  // Log the function as a string to inspect its structure

    // Regex to match "this.[something] = [something];"
    const regex = /this\.([\w\d_\.]+)\s*=\s*([\w\d_\.]+)\s*;?/;
    const match = fnString.match(regex);

    //console.log('match:', match);  // Log the match result to debug
    if (match) {
        //console.log('Captured:', match[1]);  // Output: 'cutoff.value' or similar
        return match[1];  // Returns 'cutoff.value'
    } else {
        //console.log('No match found');
    }

    return null;
}


	 retrieveValueExpression(assignment) {
    const fnString = assignment.toString();

    // Adjusted regex to capture everything after the = sign, including optional semicolon
    const regex = /this\.([\w\d_\.]+)\s*=\s*(.+);?/;
    const match = fnString.match(regex);

    if (match) {
        // Return the value expression part (everything after '=')
        return match[2].trim();  // Trimming to remove extra spaces if needed
    }

    return null;
}

	//SET PARAMETERS

	set(param, value, time = Tone.now()) {
    //console.log('set', param, value);

    // Split the parameter into keys (to access nested properties)
    let keys = param.split('.');

    for (let i = 0; i < this.numVoices; i++) {
        let target = this.voice[i];

        // Traverse through the nested objects based on the keys
        for (let j = 0; j < keys.length - 1; j++) {
            if (target[keys[j]] === undefined) {
                console.error(`Parameter ${keys[j]} does not exist on voice ${i}`);
                return;
            }
            target = target[keys[j]];
        }

        const lastKey = keys[keys.length - 1];

        // Ensure `value` is always treated as a function
        const finalValue = typeof value === 'function' ? value() : value;

        //console.log(target, finalValue)

        if (target[lastKey] !== undefined) {
            if (target[lastKey]?.value !== undefined) {
                console.log(`Current value: ${target[lastKey].value}, Setting new value: ${finalValue}`);

                if (time === null) {
                    target[lastKey].value = finalValue;  // Set value immediately
                } else {
                    target[lastKey].linearRampToValueAtTime(finalValue, time + 0.1);  // Ramp to value
                }
            } else {
                // If it's not an object with `value`, set directly
                target[lastKey] = finalValue;
            }
        } else {
            console.error(`Parameter ${lastKey} does not exist on voice ${i}`);
        }
    }
}

/**** PRESETS ***/

	loadPreset(name) {
		//for(let i=0;i<this.numVoices;i++) this.voice[i].loadPreset(name)
		this.voice[0].loadPreset(name)
	}

	listPresets() {
        this.voice[0].listPresets();
    }

	savePreset(name) {
		this.voice[0].savePreset(name)
	};

    // Function to download the updated presets data
	downloadPresets() {
		this.voice[0].downloadPresets()
	};

	panic = function(){
		for(let i=0;i<this.numVoices;i++){
			this.voice[i].triggerRelease()
			this.activeNotes[i]  = -1
		}
	}

	pan = function(depth){
		for(let i=0;i<this.numVoices;i++){
			this.voice[i].panner.pan.value = Math.sin(i/8*Math.PI*2)*depth
		}
	}

}

;

class Quadrophonic {
    constructor(numChannels = 4) {
        this.context = window.audioContext;
        this.numChannels = numChannels;


        // Create the ChannelMergerNode with the specified number of channels
        this.channelMerger = this.context.createChannelMerger(this.numChannels);

        // Configure the audio context destination for multi-channel output
        let maxChannelCount = window.audioContext.destination.maxChannelCount;
        window.audioContext.destination.channelCount = maxChannelCount;
        window.audioContext.destination.channelCountMode = "explicit";
        window.audioContext.destination.channelInterpretation = "discrete";
        
        // Create and connect a channel merger
        this.channelMerger = window.audioContext.createChannelMerger(maxChannelCount);
        this.channelMerger.channelCount = 1;
        this.channelMerger.channelCountMode = "explicit";
        this.channelMerger.channelInterpretation = "discrete";
        this.channelMerger.connect(window.audioContext.destination);

        this.input = []
        for(let i=0;i<this.numChannels;i++){
            this.input.push(new Tone.Multiply(1))
            this.input[i].connect(this.channelMerger,0,0)
        }
    }

    // Connect a source node to a specific channel on the ChannelMerger
    connectSource(source, inputChannel = 0, outputChannel = 0) {
        source.connect(this.channelMerger, inputChannel, outputChannel);
    }

    // Disconnect a source from a specific channel on the ChannelMerger
    disconnectSource(source, inputChannel = 0) {
        source.disconnect(this.channelMerger, 0, inputChannel);
    }

    // Get the underlying ChannelMerger node for further routing
    getNode() {
        return this.channelMerger;
    }

    // Dispose of the ChannelMerger and disconnect any sources
    dispose() {
        this.channelMerger.disconnect();
        console.log("ChannelMerger disposed.");
    }
}

window.RumblePresets = {
  "default": {
    "vco1": 0.5,
    "vco2": 0.5,
    "vco3": 0.5,
    "octave": 0.6399999999999997,
    "detune": -0.0050000000000004485,
    "gain": 0.49,
    "octave1": 0.3763000000000001,
    "detune1": 0.004100000000000548,
    "gain1": 0.2471151519016499,
    "octave12": -0.48769999999999936,
    "detune12": -0.006785841498486267,
    "gain12": 0.4489000000000002,
    "cutoff": 145.9711999999991,
    "keyTracking": 1,
    "vcf env": 1800.0000000000005,
    "Q": 2.5919999999999983,
    "a": 0.003,
    "d": 1.4579999999999995,
    "s": 0,
    "r": 4.049999999999999,
    "vcf a": 0.007199999999999998,
    "vcf d": 1.25,
    "vcf s": 0.02249999999999999,
    "vcf r": 3.8719999999999994,
    "lfo": 0.5,
    "pwm": 0.0225,
    "distortion": 1.6478738086663287e-32,
    "mix": 1
  },
  "mono": {
    "vco1": 0.5,
    "vco2": 0.5,
    "vco3": 0.5,
    "octave": -0.2600000000000011,
    "detune": -4.440892098500626e-16,
    "gain": 0.99,
    "octave1": -1.0253000000000012,
    "detune1": -0.03759999999999947,
    "gain1": 0,
    "octave12": -0.5299999999999998,
    "detune12": -0.006785841498486267,
    "gain12": 0,
    "cutoff": 257.94879999999887,
    "keyTracking": 0,
    "vcf env": 220.49999999999946,
    "Q": 9.800000000000006,
    "a": 0.003,
    "d": 5,
    "s": 0.3249000000000002,
    "r": 0.12799999999999884,
    "vcf a": 0.0012500000000000002,
    "vcf d": 0.6124999999999979,
    "vcf s": 0,
    "vcf r": 0.3919999999999978,
    "distortion": 0,
    "mix": 1,
    "lfo": 0.5,
    "pwm": 0.0225
  },
  "ringingSub": {
    "vco1": 0.5,
    "vco2": 0.5,
    "vco3": 0.5,
    "octave": 0.4599999999999995,
    "detune": -4.440892098500626e-16,
    "gain": 0.99,
    "octave1": -0.8468000000000013,
    "detune1": -0.03759999999999947,
    "gain1": 0.6399999999999997,
    "octave12": -0.5299999999999998,
    "detune12": -0.006785841498486267,
    "gain12": 0,
    "cutoff": 10.998199999999782,
    "keyTracking": 1,
    "vcf env": 199.99999999999923,
    "Q": 2.737999999999998,
    "a": 0.003,
    "d": 1.9844999999999988,
    "s": 1,
    "r": 1.7999999999999972,
    "vcf a": 0.005,
    "vcf d": 1.1044999999999978,
    "vcf s": 0.3480999999999996,
    "vcf r": 1.0579999999999958,
    "lfo": 0.5,
    "pwm": 0.0225,
    "distortion": 0,
    "mix": 1
  },
  "fat": {
    "vco1": 0.5,
    "vco2": 0.5,
    "vco3": 0.5,
    "octave": 0.15999999999999925,
    "detune": -4.440892098500626e-16,
    "gain": 1,
    "octave1": -0.5717000000000012,
    "detune1": 0.09289999999999965,
    "gain1": 0.8463999999999998,
    "octave12": -0.7324999999999999,
    "detune12": -0.08746089048940536,
    "gain12": 0.8463999999999998,
    "cutoff": 226.95499999999856,
    "keyTracking": 0.17639999999999956,
    "vcf env": 647.9999999999991,
    "Q": 0.2419999999999986,
    "a": 0.003,
    "d": 1.9844999999999988,
    "s": 1,
    "r": 1.5679999999999972,
    "vcf a": 0.005,
    "vcf d": 0.9140958877053913,
    "vcf s": 0.3480999999999996,
    "vcf r": 0.031999999999999244,
    "lfo": 0.5,
    "pwm": 0.0225,
    "distortion": 0.14440000000000014,
    "mix": 0.3969000000000003
  },
  "blip": {
    "vco1": 0.5,
    "vco2": 0.5,
    "vco3": 0.5,
    "octave": 1,
    "detune": -4.440892098500626e-16,
    "gain": 0.7499999999999998,
    "octave1": 0.3231999999999995,
    "detune1": 0.032899999999999596,
    "gain1": 1,
    "octave12": 0.27070000000000105,
    "detune12": -0.006785841498486267,
    "gain12": 0.8463999999999998,
    "cutoff": 170.96619999999902,
    "keyTracking": 0.6399999999999997,
    "vcf env": 647.9999999999991,
    "Q": 0.7219999999999969,
    "a": 0.003,
    "d": 1.1519999999999984,
    "s": 0.1295999999999996,
    "r": 0.24199999999999997,
    "vcf a": 0.005,
    "vcf d": 0.24199999999999763,
    "vcf s": 0.06249999999999967,
    "vcf r": 0.049999999999999066,
    "lfo": 0.5,
    "pwm": 0.1225,
    "distortion": 0.10890000000000019,
    "mix": 0.4356000000000005
  },
  "sub": {
    "vco1": 0.5,
    "vco2": 0.5,
    "vco3": 0.5,
    "octave": -0.20000000000000107,
    "detune": -4.440892098500626e-16,
    "gain": 0.99,
    "octave1": 1,
    "detune1": 0.001264000000000598,
    "gain1": 0.3480999999999996,
    "octave12": -0.5299999999999998,
    "detune12": -0.006785841498486267,
    "gain12": 0,
    "cutoff": 37.992799999999605,
    "keyTracking": 0.9409000000000014,
    "vcf env": 40.49999999999962,
    "Q": 0,
    "a": 0.003,
    "d": 1.9844999999999988,
    "s": 1,
    "r": 0.5119999999999978,
    "vcf a": 0.005,
    "vcf d": 1.1044999999999978,
    "vcf s": 0.3480999999999996,
    "vcf r": 0.5119999999999968,
    "lfo": 0.5,
    "pwm": 0.225,
    "distortion": 0,
    "mix": 1
  }
};;

/*
Rumble

Three oscillator monosynth
* 3 vcos->mixer->gain->waveShaper->vcf->vca->output
* main pitch input is .frequency.value

methods:
- connect
setADSR(a,d,s,r)
setFilterADSR(a,d,s,r)
setDetune(a,b,c)
setPwmDepth(a,b,c)
setGain(a,b,c)

properties set directly:
frequency.value
velocitySig.value
cutoff_cv.value
clip.factor (into waveShaper)
vca_lvl.value
cutoffSig.value
vcf_env_depth.factor
keyTracking.factor
lfo.frequency

properties set using methods:
vco_freq_1, vco_freq_2, vco_freq_3
vco_gain_1, vco_gain_2, vco_gain_3
env and vcf_env ADSR
lfo_pwm_1, lfo_pwm_2, lfo_pwm_3
gain (into waveShaper)

 
*/
;
;
;
;


class Rumble extends MonophonicTemplate {
  constructor (gui = null) {
    super()
    this.gui = gui
    this.presets = RumblePresets
    this.isGlide = false
    this.name = "Rumble"
    console.log(this.name, " loaded, available preset: ", RumblePresets)

    // Initialize the main frequency control
    this.frequency = new Tone.Signal();

    // Frequency ratios for VCOs
    this.vco_freq_1 = new Tone.Multiply(1);
    this.vco_freq_2 = new Tone.Multiply(1);
    this.vco_freq_3 = new Tone.Multiply(1);
    this.vco_octave_1 = new Tone.Multiply(1);
    this.vco_octave_2 = new Tone.Multiply(1);
    this.vco_octave_3 = new Tone.Multiply(1);
    this.frequency.connect(this.vco_freq_1);
    this.frequency.connect(this.vco_freq_2);
    this.frequency.connect(this.vco_freq_3);

    // VCOs
    this.vco_1 = new Tone.OmniOscillator({type:'pulse'}).start();
    this.vco_2 = new Tone.OmniOscillator({type:'pulse'}).start();
    this.vco_3 = new Tone.OmniOscillator({type:'pulse'}).start();
    this.vco_freq_1.connect(this.vco_octave_1);
    this.vco_freq_2.connect(this.vco_octave_2);
    this.vco_freq_3.connect(this.vco_octave_3);
    this.vco_octave_1.connect(this.vco_1.frequency);
    this.vco_octave_2.connect(this.vco_2.frequency);
    this.vco_octave_3.connect(this.vco_3.frequency);

    // Mixer
    this.vco_gain_1 = new Tone.Multiply(.25);
    this.vco_gain_2 = new Tone.Multiply(.25);
    this.vco_gain_3 = new Tone.Multiply(.25);
    this.vco_1.connect(this.vco_gain_1);
    this.vco_2.connect(this.vco_gain_2);
    this.vco_3.connect(this.vco_gain_3);

    this.vcf = new Tone.Filter({type:"lowpass", rolloff:-24});
    this.vco_gain_1.connect(this.vcf);
    this.vco_gain_2.connect(this.vcf);
    this.vco_gain_3.connect(this.vcf);

    //waveShaper
    this.clip = new Tone.Multiply(0.125)
    this.direct_level = new Tone.Multiply(.5)
    this.waveShaper = new Tone.WaveShaper((x)=>{
      return Math.sin(x*Math.PI*2)
    	//return Math.tanh(x*8)
    })
    this.waveShaper.oversample = "4x"
    this.vcf.connect(this.clip)
    this.vcf.connect(this.direct_level)
    this.clip.connect(this.waveShaper)

    // VCF, VCA, output
    this.vca = new Tone.Multiply()
    this.direct_level.connect(this.vca)
    this.output = new Tone.Multiply(.5)
    this.waveShaper.connect(this.vca)
    this.vca.connect(this.output)

    // VCA control
    this.vca_lvl = new Tone.Signal();
    this.vca_lvl.connect(this.vca.factor)
    this.env = new Tone.Envelope();
    this.env_depth = new Tone.Multiply()
    this.env.connect(this.env_depth)
    this.env_depth.connect(this.vca.factor)
    this.velocitySig = new Tone.Signal(1)
    this.velocitySig.connect(this.env_depth.factor)

    //vcf control
    this.vcf_env = new Tone.Envelope();
    this.cutoffSig = new Tone.Signal(1000);
    this.cutoff_cv = new Tone.Signal(0);
    this.vcf_env_depth = new Tone.Multiply(500);
    this.keyTracking = new Tone.Multiply(.1)
    this.vcf_env.connect(this.vcf_env_depth)
    this.vcf_env_depth.connect(this.vcf.frequency)
    this.cutoffSig.connect(this.vcf.frequency)
    this.cutoff_cv.connect(this.vcf.frequency)
    this.frequency.connect(this.keyTracking)
    this.keyTracking.connect(this.vcf.frequency)

    //LFO
    this.lfo = new Tone.Oscillator(1).start()
    this.lfo_pwm_1 = new Tone.Multiply()
    this.lfo_pwm_2 = new Tone.Multiply()
    this.lfo_pwm_3 = new Tone.Multiply()
    this.lfo.connect(this.lfo_pwm_1)
    this.lfo_pwm_1.connect(this.vco_1.width)
    this.lfo.connect(this.lfo_pwm_2)
    this.lfo_pwm_2.connect(this.vco_2.width)
    this.lfo.connect(this.lfo_pwm_3)
    this.lfo_pwm_3.connect(this.vco_3.width)

    let paramDefinitions = [
      {name:'detune',min:0.,max:1,curve:2,value:[1,1,1],callback:(x,i=null)=>{
        if(i==0)this.vco_freq_1.factor.value = x;
        else if(i==1)this.vco_freq_2.factor.value = x;
        else if(i==2)this.vco_freq_3.factor.value = x;
      }},
      {name:'octave',min:-3,max:4,curve:1,value:[1,1,1],callback:(x,i=null)=>{
        if(i==0)this.vco_octave_1.factor.value = Math.pow(2,x);
        else if(i==1)this.vco_octave_2.factor.value = Math.pow(2,x);
        else if(i==2)this.vco_octave_3.factor.value = Math.pow(2,x);
      }},
      {name:'gain',min:0,max:1,curve:2,value:[.75,.75,.75],callback:(x,i=null)=>{
        if(i==0)this.vco_gain_1.factor.value = x
        else if(i==1)this.vco_gain_2.factor.value = x
        else if(i==2)this.vco_gain_3.factor.value = x
      }},
      {name:'cutoff',min:20.,max:20000,curve:2,callback:(x)=>this.cutoffSig.value = x},
      {name:'Q',min:0.,max:30,curve:2,callback:(x)=>this.vcf.Q.value = x},
      {name:'keyTrack',min:0.,max:2,curve:1,callback:(x)=>this.keyTracking.factor.value = x},
      {name:'vcfEnvDepth',min:0.,max:1000,curve:2,callback:(x)=>this.vcf_env_depth.factor.value = x},
      {name:'adsr',min:0,max:100,curve:1,value:[.01,.1,.5,.5],callback:(x,i=null)=>{
        if(i==0)this.env.attack = x
        else if(i==1)this.env.decay = x
        else if(i==2)this.env.sustain = x
        else if(i==3)this.env.release = x
      }},
      {name:'filterAdsr',min:0,max:100,curve:1,value:[.01,.1,.5,.5],callback:(x,i=null)=>{
        if(i==0)this.vcf_env.attack = x
        else if(i==1)this.vcf_env.decay = x
        else if(i==2)this.vcf_env.sustain = x
        else if(i==3)this.vcf_env.release = x
      }},
      {name:'pwm',min:0,max:1,curve:1,value:[0,0,0],callback:(x,i=null)=>{
          if(i==0)this.lfo_pwm_1.factor.value = x
          else if(i==1)this.lfo_pwm_2.factor.value = x
          else if(i==2)this.lfo_pwm_3.factor.value = x
        }},
      {name:'lfoRate',min:0,max:1000,curve:1,value:1,callback:(x,i=null)=>this.lfo.frequency.value=x},
      {name:'distortion',min:0,max:1,curve:.35,value:1,callback:x=>{this.clip.factor.value = x}},
      {name:'mix',min:0,max:1,curve:1,value:.35,callback:x=>{this.direct_level.factor.value = x}},
    ]

    this.param = this.generateParameters(paramDefinitions)
    this.createAccessors(this, this.param);

    //for autocomplete
    this.autocompleteList = paramDefinitions.map(def => def.name);;
    //for(let i=0;i<this.paramDefinitions.length;i++)this.autocompleteList.push(this.paramDefinitions[i].name)
  }//constructor

  //envelopes
  triggerAttack (freq, amp, time=null){
    freq = Tone.Midi(freq).toFrequency()
    amp = amp/127
    if(time){
      this.env.triggerAttack(time)
      this.vcf_env.triggerAttack(time)
      this.frequency.setValueAtTime(freq, time)
      this.velocitySig.setValueAtTime(amp,time)
    } else {
      this.env.triggerAttack()
      this.vcf_env.triggerAttack()
      this.frequency.value = freq
      this.velocitySig.rampTo(amp,.03)
    }
  }
  triggerRelease (time=null){
    if(time) {
    	this.env.triggerRelease(time)
    	this.vcf_env.triggerRelease(time)
    }
    else {
      this.env.triggerRelease()
    	this.vcf_env.triggerRelease()
    }
  }
  triggerAttackRelease (freq, amp, dur=0.01, time=null){
    //console.log('AR ',freq,amp,dur,time)
    freq = Tone.Midi(freq).toFrequency()
    amp = amp/127
    if(time){
      this.env.triggerAttackRelease(dur, time)
      this.vcf_env.triggerAttackRelease(dur, time)
      this.frequency.setValueAtTime(freq, time)
      this.velocitySig.setValueAtTime(amp,time)
    } else{
      this.env.triggerAttackRelease(dur)
      this.vcf_env.triggerAttackRelease(dur)
      this.frequency.value = freq
      this.velocitySig.rampTo(amp,.03)
    }
  }//attackRelease

  setDetune(a,b,c){
  	this.vco_freq_1.factor.value = a
  	this.vco_freq_2.factor.value = b
  	this.vco_freq_3.factor.value = c
  }
  setPwmDepth(a,b,c){
  	this.lfo_pwm_1.factor.value = a
  	this.lfo_pwm_2.factor.value = b
  	this.lfo_pwm_3.factor.value = c
  }
  setGain(a,b,c){
  	this.vco_gain_1.factor.value = a
  	this.vco_gain_2.factor.value = b
  	this.vco_gain_3.factor.value = c
  }

  //GUI
  initGui(gui = this.gui) {
    this.gui = gui
    let ccolor = [200,200,0]
    this.x = 0
    this.y = 0

     // VCO Labels
    const vco_knob_x = [5, 15, 25];
    this.vco1_label = this.createLabel('vco1', vco_knob_x[0], 5);
    this.vco2_label = this.createLabel('vco2', vco_knob_x[1], 5);
    this.vco3_label = this.createLabel('vco3', vco_knob_x[2], 5);

    // Additional Labels
    // this.oct_label = this.createLabel('octave', 6, 20, 1.5);
    // this.detune_label = this.createLabel('detune', 6, 50, 1.5);
    // this.gain_label = this.createLabel('gain', 6, 80, 1.5);

    // VCO Knobs
    // Note: You'll need to adjust callback functions to fit your class methods for setting values
    this.vco1_oct_knob = this.gui.Knob({label:'octave', 
      x:vco_knob_x[0], y:20, min:-2, max:1, size:0.75, accentColor:[200,50,0], border:2,
      callback:(x)=> {this.vco_freq_1.value = calcFreq(x,this.vco1_detune_knob.value)}})
    this.vco1_detune_knob = this.gui.Knob({label:'detune', 
      x:vco_knob_x[0], y:50, min:-.5, max:.5, size:0.75, accentColor:[200,50,0], border:2,
      callback:(x)=>this.vco_freq_1.value = calcFreq(this.vco1_oct_knob.value,x)});
    this.vco1_gain_knob = this.gui.Knob({label:'gain', 
      x:vco_knob_x[0], y:80, min:0, max:1, size:0.75, accentColor:[200,50,0], border:2,
      mapto: this.vco_gain_1.factor });

    const calcFreq = function(oct,detune){
      return Math.pow(2,Math.floor(oct)) + Math.pow(detune,2)*Math.sign(detune)
    }
    

    this.vco2_oct_knob = this.createKnob('octave', vco_knob_x[1], 20, -2, 1, 0.75, [200,50,0], (x)=>{this.vco_freq_2.value = calcFreq(x,this.vco2_detune_knob.value)});
    this.vco2_detune_knob = this.createKnob('detune', vco_knob_x[1], 50, -.5, .5, 0.75, [50,150,100],(x)=>this.vco_freq_2.value = calcFreq(this.vco2_oct_knob.value,x));
    this.vco2_gain_knob = this.createKnob('gain', vco_knob_x[1], 80, 0, 1, 0.75, [200,50,0], (x)=>this.vco_gain_2.factor.value = x );

    this.vco3_oct_knob = this.createKnob('octave', vco_knob_x[2], 20, -2, 1, 0.75, [200,50,0], (x)=>this.vco_freq_3.value = calcFreq(x,this.vco3_detune_knob.value));
    this.vco3_detune_knob = this.createKnob('detune', vco_knob_x[2], 50, -.5, .5, 0.75, [50,150,100],(x)=>this.vco_freq_3.value = calcFreq(this.vco3_oct_knob.value,x));
    this.vco3_gain_knob = this.createKnob('gain', vco_knob_x[2], 80, 0, 1, 0.75, [200,50,0], (x)=>this.vco_gain_3.factor.value = x );


    // VCF and VCA Knobs
    this.vcf_cutoff_knob = this.createKnob('cutoff', 45, 28, 2, 10000, 1.75, [200,0,200], (x)=>this.cutoffSig.value = x);
    this.keytracking_knob = this.createKnob('keyTracking', 45, 75, 0, 1, .75, [200,0,200], (x)=>this.keyTracking.factor.value = x);
    this.vcf_env_depth_knob = this.createKnob('vcf env', 55, 75, 0, 5000, .75, [200,0,200], (x)=>this.vcf_env_depth.factor.value = x);
    this.vcf_res_knob = this.createKnob('Q', 35, 75, 0, 20, 0.75, [200,0,200], (x)=>this.vcf.Q.value = x);
    
    this.attack_knob = this.createKnob('a', 68, 55, 0.000001, .5, .35, [0,0,200], x=>this.env.attack = x);
    this.decay_knob = this.createKnob('d', 76, 55, 0, 10, .35, [0,0,200], x=>this.env.decay = x);
    this.sustain_knob = this.createKnob('s', 84, 55, 0, 1, .35, [0,0,200], x=>this.env.sustain = x);
    this.release_knob = this.createKnob('r', 92, 55, 0, 20, .35, [0,0,200], x=>this.env.release = x);

    this.vcf_attack_knob = this.createKnob('vcf a', 68, 80, 0.001, .5, .35, [0,0,200], x=>this.vcf_env.attack = x);
    this.vcf_decay_knob = this.createKnob('vcf d', 76, 80, 0, 10, .35, [0,0,200], x=>this.vcf_env.decay = x);
    this.vcf_sustain_knob = this.createKnob('vcf s', 84, 80, 0, 1, .35, [0,0,200], x=>this.vcf_env.sustain = x);
    this.vcf_release_knob = this.createKnob('vcf r', 92, 80, 0, 20, .35, [0,0,200], x=>this.vcf_env.release = x);
    
    this.lfo_knob = this.createKnob('lfo', 60, 25, 0, 20, .35, [0,0,200], x=>this.lfo.frequency.value = x);
    this.pwm_knob = this.createKnob('pwm', 68, 25, 0, .9, .35, [0,0,200], x=>{this.setPwmDepth(x, x*.8,x*.6)});
    this.clip_knob = this.createKnob('distortion', 82, 25, 0, 1, .35, [0,0,200], x=>{this.clip.factor.value = x});
    this.clip_mix = this.createKnob('mix', 90, 25, 0, 1, .35, [0,0,200], x=>{this.direct_level.factor.value = x});
    // Repeat for other knobs...
    this.gui_elements = [this.vco1_label, this.vco2_label, this.vco3_label, 
       //this.oct_label, this.detune_label, this.gain_label, 
      this.vco1_oct_knob, this.vco1_detune_knob, this.vco1_gain_knob,
      this.vco2_oct_knob, this.vco2_detune_knob, this.vco2_gain_knob,
      this.vco3_oct_knob, this.vco3_detune_knob, this.vco3_gain_knob, 
      this.vcf_cutoff_knob, this.vcf_res_knob, this.keytracking_knob, this.vcf_env_depth_knob ,
      this.attack_knob,this.decay_knob,this.sustain_knob,this.release_knob,
      this.vcf_attack_knob,this.vcf_decay_knob,this.vcf_sustain_knob,this.vcf_release_knob,
      this.lfo_knob, this.pwm_knob, this.clip_knob, this.clip_mix
      ]
	}//gui

	createLabel(label, x, y, size = 1, border = 1, borderRadius = 0.01) {
    return this.gui.Text({
      label, x: x + this.x, y: y + this.y,
      size, border, borderRadius
    });
  }

  createKnob(label, x, y, min, max, size, accentColor, callback) {
    return this.gui.Knob({
      label, min, max, size, accentColor,
      x: x + this.x, y: y + this.y,
      callback: callback,
      showLabel: 1, showValue: 0, // Assuming these are common settings
      curve: 2, // Adjust as needed
      border: 2 // Adjust as needed
    });
  }

  connect(destination) {
    if (destination.input) {
      this.output.connect(destination.input);
    } else {
      this.output.connect(destination);
    }
  }
}


//
const baseUrl = 'https://specy.github.io/genshinMusic/assets/audio/';
const type = '/0.mp3';
const files = [
  'Aurora', 'Bells', 'Contrabass', 'Drum', 'DunDun',
  'Flute', 'Guitar', 'HandPan', 'Harp', 'Horn', 'Kalimba', 
  'LightGuitar', 'Lyre', 'MantaOcarina', 'Ocarina',
  'Old-Zither', 'Panflute', 'Piano', 'Pipa', 'SFX_TR-909',
  'ToyUkulele', 'Trumpet', 'Vintage-Lyre', 'WinterPiano', 'Xylophone', 'Zither'
];

// Create a dictionary to map file names to URLs and pitches
const soundDict = {};

files.forEach((fileName, index) => {
    const url = baseUrl + fileName + type;
    soundDict[fileName] = { url: url, basePitch: 60 }; // Assume MIDI 60 as base pitch for simplicity
});

console.log(soundDict);


// Function to create and load a sampler for a specific file
function loadSampler(index) {
    const num = index % files.length;  // Wrap around if index exceeds files array length
    const fileName = files[num];
    const fileUrl = baseUrl + fileName + type; // Construct the full URL
   
    // Print to check values
    console.log(`Loading ${fileName} with URL: ${fileUrl}`);
    
    // Create a sampler and load the sample into the specified note (MIDI 60)
    const sampler = new Tone.Sampler({
        urls: {
            [60]: fileUrl  // Map middle C to the sample URL
        }
    }).toDestination();

    return sampler;
}


window.SimplerPresets = {
  "default": {
    "Kick": 0.5,
    "Snare": 0.5,
    "Hihat": 0.5,
    "Toms": 0.5,
    "Output": 2,
    "Dry Kick": 0.5,
    "Kick Rate": 1,
    "Snare Rate": 1,
    "Hihat Rate": 1,
    "Tom1 Rate": 1,
    "Tom2 Rate": 1,
    "Tom3 Rate": 1,
    "Threshold": -32.5,
    "Ratio": 10.5,
    "Distort": 0.5,
    "Hat Decay": 0.505,
    "kit": "LINN",
    "Kick1": 1,
    "Snare1": 1,
    "Hihat1": 1,
    "Toms1": 1,
    "Output1": 3.4800000000000013,
    "Dry Kick1": 0.09999999999999971,
    "Kick Rate1": 1,
    "Snare Rate1": 1,
    "Hihat Rate1": 1,
    "Tom1 Rate1": 1,
    "Tom2 Rate1": 1,
    "Tom3 Rate1": 1,
    "Threshold1": -13.249999999999986,
    "Ratio1": 2.709999999999994,
    "Distort1": 0,
    "Hat Decay1": 0.2970999999999998,
    "kit1": "LINN"
  },
  "electro": {
    "Kick": 0.5,
    "Snare": 0.5,
    "Hihat": 0.5,
    "Toms": 0.5,
    "Output": 2,
    "Dry Kick": 0.5,
    "Kick Rate": 1,
    "Snare Rate": 1,
    "Hihat Rate": 1,
    "Tom1 Rate": 1,
    "Tom2 Rate": 1,
    "Tom3 Rate": 1,
    "Threshold": -32.5,
    "Ratio": 10.5,
    "Distort": 0.5,
    "Hat Decay": 0.505,
    "kit": "LINN",
    "Kick1": 1,
    "Snare1": 1,
    "Hihat1": 0.8999999999999999,
    "Toms1": 0.23000000000000007,
    "Output1": 0.9599999999999991,
    "Dry Kick1": 0.1399999999999997,
    "Kick Rate1": 0.8999999999999999,
    "Snare Rate1": 0.8799999999999999,
    "Hihat Rate1": 1.1,
    "Tom1 Rate1": 1.4000000000000004,
    "Tom2 Rate1": 1.3000000000000003,
    "Tom3 Rate1": 1.12,
    "Threshold1": -28.649999999999995,
    "Ratio1": 7.459999999999997,
    "Distort1": 0.17,
    "Hat Decay1": 0.11889999999999983,
    "kit1": "CR78"
  },
  "breakbeat": {
    "Kick": 0.5,
    "Snare": 0.5,
    "Hihat": 0.5,
    "Toms": 0.5,
    "Output": 2,
    "Dry Kick": 0.5,
    "Kick Rate": 1,
    "Snare Rate": 1,
    "Hihat Rate": 1,
    "Tom1 Rate": 1,
    "Tom2 Rate": 1,
    "Tom3 Rate": 1,
    "Threshold": -32.5,
    "Ratio": 10.5,
    "Distort": 0.5,
    "Hat Decay": 0.505,
    "kit": "LINN",
    "Kick1": 1,
    "Snare1": 1,
    "Hihat1": 0.7199999999999998,
    "Toms1": 0.7900000000000005,
    "Output1": 2.3999999999999995,
    "Dry Kick1": 0,
    "Kick Rate1": 1.06,
    "Snare Rate1": 1.12,
    "Hihat Rate1": 0.8399999999999999,
    "Tom1 Rate1": 1.1600000000000001,
    "Tom2 Rate1": 1.1400000000000001,
    "Tom3 Rate1": 1.1,
    "Threshold1": -28.649999999999995,
    "Ratio1": 12.210000000000006,
    "Distort1": 0.04,
    "Hat Decay1": 0.19809999999999958,
    "kit1": "breakbeat8"
  },
  "techno": {
    "Kick": 0.5,
    "Snare": 0.5,
    "Hihat": 0.5,
    "Toms": 0.5,
    "Output": 2,
    "Dry Kick": 0.5,
    "Kick Rate": 1,
    "Snare Rate": 1,
    "Hihat Rate": 1,
    "Tom1 Rate": 1,
    "Tom2 Rate": 1,
    "Tom3 Rate": 1,
    "Threshold": -32.5,
    "Ratio": 10.5,
    "Distort": 0.5,
    "Hat Decay": 0.505,
    "kit": "LINN",
    "Kick1": 1,
    "Snare1": 0.7299999999999998,
    "Hihat1": 0.5399999999999996,
    "Toms1": 0.6200000000000003,
    "Output1": 3.3199999999999994,
    "Dry Kick1": 0,
    "Kick Rate1": 0.8399999999999999,
    "Snare Rate1": 1.12,
    "Hihat Rate1": 1.1400000000000001,
    "Tom1 Rate1": 1.1600000000000001,
    "Tom2 Rate1": 1.1400000000000001,
    "Tom3 Rate1": 1.1,
    "Threshold1": -28.649999999999995,
    "Ratio1": 12.020000000000005,
    "Distort1": 0.03,
    "Hat Decay1": 0.2376999999999996,
    "kit1": "Techno"
  },
  "snappy": {
    "Kick": 0.5,
    "Snare": 0.5,
    "Hihat": 0.5,
    "Toms": 0.5,
    "Output": 2,
    "Dry Kick": 0.5,
    "Kick Rate": 1,
    "Snare Rate": 1,
    "Hihat Rate": 1,
    "Tom1 Rate": 1,
    "Tom2 Rate": 1,
    "Tom3 Rate": 1,
    "Threshold": -32.5,
    "Ratio": 10.5,
    "Distort": 0.5,
    "Hat Decay": 0.505,
    "kit": "LINN",
    "Kick1": 1,
    "Snare1": 0.7299999999999998,
    "Hihat1": 0.5399999999999996,
    "Toms1": 0.4499999999999995,
    "Output1": 3.3199999999999994,
    "Dry Kick1": 0,
    "Kick Rate1": 1.1400000000000001,
    "Snare Rate1": 1.3800000000000003,
    "Hihat Rate1": 1.1400000000000001,
    "Tom1 Rate1": 1.6800000000000006,
    "Tom2 Rate1": 0.52,
    "Tom3 Rate1": 0.21999999999999936,
    "Threshold1": -28.649999999999995,
    "Ratio1": 1,
    "Distort1": 0.09999999999999999,
    "Hat Decay1": 0.08919999999999953,
    "kit1": "KPR77"
  }
};;

/*
 * Simple Sampler
 *
 * 
*/

;
;
;
;

class Simpler extends MonophonicTemplate {
    constructor (file) {
        super()
        // this.gui = gui
        this.presets = SimplerPresets
        this.name = "Simpler"
        
        //audio objects
        this.sampler = new Tone.Sampler()
        this.vcf = new Tone.Filter()
        this.vca = new Tone.Multiply(1)
        this.output = new Tone.Multiply(1)
        this.cutoffSig = new Tone.Signal(10000)

        //vcf setup
        this.cutoffSig.connect(this.vcf.frequency)
        this.vcf.frequency.value = 10000
        this.vcf.rolloff = -12
        this.vcf.Q.value = 1

        //Set up filter envelope
        this.filterEnv = new Tone.Envelope()
        this.vcfEnvDepth = new Tone.Multiply()
        this.filterEnv.connect(this.vcfEnvDepth)
        this.vcfEnvDepth.connect(this.vcf.frequency)

        //connect vcf to vca
        this.vcf.connect(this.vca)
        this.vca.connect(this.output)

        this.sample = ''

        let paramDefinitions = [
          {name:'volume',min:-36,max:0,curve:1,callback:x=>{this.sampler.volume.value = Math.pow(10,x/20)}},
          {name:'attack',min:0.01,max:1,curve:2,callback:x=>{this.sampler.attack=x}},
          {name:'release',min:.01,max:10,curve:2,callback:x=>{ this.sampler.release=x }},
          {name:'cutoff',min:100,max:10000,curve:2,callback:value=>this.cutoffSig.value = value},
          {name:'Q',min:0.0,max:20,curve:2,callback:value=>this.vcf.Q.value = value},
          {name:'filterEnvDepth',min:0.0,max:5000,curve:2,callback:value=>this.vcfEnvDepth.factor.value = value},
          ]

        let paramGui = [
          {name:'volume',x:10,y:10,color:'red'},
          {name:'attack',min:0.01,max:1,curve:2,callback:x=>{this.sampler.attack=x}},
          {name:'release',min:.01,max:10,curve:2,callback:x=>{ this.sampler.release=x }},
          {name:'cutoff',min:100,max:10000,curve:2,callback:value=>this.cutoffSig.value = value},
          {name:'Q',min:0.0,max:20,curve:2,callback:value=>this.vcf.Q.value = value},
          {name:'filterEnvDepth',min:0.0,max:5000,curve:2,callback:value=>this.vcfEnvDepth.factor.value = value},
          ]


        this.param = this.generateParameters(paramDefinitions)
        this.createAccessors(this, this.param);
        //this.attachGuiToParams()

        this.sampleFiles = {
          bell: ['C4', 'berklee/bell_1.mp3'],
          bell1:   ['C4', 'berklee/bell_1a.mp3'],
          bell2:   ['C4', 'berklee/bell_2a.mp3'],
          bell3:   ['C4', 'berklee/bell_mallet_2.mp3'],
          horn:['C4', 'berklee/casiohorn2.mp3'],
          chotone:  ['C4', 'berklee/chotone_c4_!.mp3'],
          voice: ['C4', 'berklee/femalevoice_aa_Db4.mp3'],
          kalimba: ['C4', 'berklee/Kalimba_1.mp3'],
          dreamyPiano: ['A5', 'salamander/A5.mp3'],
          softPiano: ['A4', 'salamander/A4.mp3'],
          piano: [45, 'salamander/A3.mp3'],
          casio:['C4', 'casio/C2.mp3']
        }

        if(file) this.loadSample(file)
    }

    /**
   * Load a specific sample.
   * @param {string} file - The name of the sample to load.
   */
    load(file = null){this.loadSample(file)}
    loadSample(file = null){
        //clear all previously playing notes
        if(this.sampler) {
            this.sampler.dispose()
            this.sampler.releaseAll()
        }

        if(file === null){
            this.loadSampleToSampler()
            return
        }

        // If the file is a number, treat it as an index into the sampleFiles object
        if (typeof file === 'number') {
            // Convert the keys of the sampleFiles object to an array
            const fileKeys = Object.keys(this.sampleFiles);
            file = Math.floor(file)%fileKeys.length
            file = fileKeys[file];
        }

        if (file in this.sampleFiles) {
          console.log(`Simpler loading ${file}`);
          this.sample = file
        } else {
          console.error(`The sample "${file}" is not available.`);
          return
        }

        this.baseUrl = "https://tonejs.github.io/audio/"
        const url = this.sampleFiles[this.sample][1]
        const note = this.sampleFiles[this.sample][0]
        console.log(note, url)
        this.sampler = new Tone.Sampler({
            urls:{
                [60]: this.baseUrl.concat(url)
            }
        }).connect(this.vcf)
    }

    listSamples(){
        const fileKeys = Object.keys(this.sampleFiles);
        console.log(fileKeys)
    }

    //envelopes
    triggerAttack (freq, amp=100, time=null){ 
        this.sampler.release = this.release
        freq = Tone.Midi(freq).toFrequency()
        amp = amp/127
        if(time){
            this.sampler.triggerAttack(freq, time, amp)
            this.filterEnv.triggerAttack(time)
            this.vca.factor.setValueAtTime(amp, time)
        } else{
            this.sampler.triggerAttack(freq)
            this.filterEnv.triggerAttack()
            this.vca.factor.value = amp
        }
    }

    triggerRelease (freq, time=null){
        freq = Tone.Midi(freq).toFrequency()
        if(time) {
            this.sampler.triggerRelease(freq, time)
            this.filterEnv.triggerRelease(time)
        }
        else {
            this.sampler.triggerRelease(freq)
            this.filterEnv.triggerRelease()
        }
    }

    triggerAttackRelease (freq, amp, dur=0.01, time=null){ 
        this.param.release = this.release 
        freq = Tone.Midi(freq).toFrequency()
        amp = amp/127
        console.log(freq,amp,dur)
        if(time){
            this.sampler.triggerAttackRelease(freq, dur, time, amp)
            this.filterEnv.triggerAttackRelease(dur,time)
            this.vca.factor.setValueAtTime(amp, time)
        } else{
            //this.sampler.triggerAttackRelease(freq, dur)
            //this.filterEnv.triggerAttackRelease(dur)
        }
    }//attackRelease

    connect(destination) {
        if (destination.input) {
            this.output.connect(destination.input);
        } else {
            this.output.connect(destination);
        }
    }

    //parameter setters
    setADSR(a,d,s,r){
        this.sampler.attack = a>0.001 ? a : 0.001
        //this.filterEnv.decay = d>0.01 ? d : 0.01
        //this.filterEnv.sustain = Math.abs(s)<1 ? s : 1
        this.sampler.release = r>0.01 ? r : 0.01
    }

    loadSampleToSampler(note = "C4") {
        // Create a file input element programmatically
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'audio/*'; // Accept only audio files

        // Handle file selection
        fileInput.onchange = (event) => {
            const file = event.target.files[0];
            if (!file) {
                console.log("No file selected");
                return;
            }

            // Use FileReader to read the file as a Data URL
            const fileReader = new FileReader();
            fileReader.onload = () => {
                this.sampler = new Tone.Sampler({
                    urls:{
                        [60]: fileReader.result
                    }
                }).connect(this.vcf)
                console.log("Audio loaded into sampler");
            };
            fileReader.readAsDataURL(file);
        };

        // Trigger the file dialog
        fileInput.click();
    }
}

;
;

/*
Synthesized Snare:

STRUCTURE:
    *
    H  vco1 \
    E        > --------> vca1 ---
    A  vco2 /             |       \
    D               headsEnvelope  \
    S                              out
    *                              /
    S              snareEnvelope  /
    N                     |      /
    A  rattle -> filter -> vca2 -
    R
    E
    *
    
    This snare uses the research done by the webpage/s:
        - https://www.soundonsound.com/techniques/practical-snare-drum-synthesis
        -
*/

class Snare {
    constructor(frequency, gui = null) {
        this.name = 'Snare'
        this.gui = gui
        this.output = new Tone.Multiply(1)
        //
        // Heads
        this.vco1 = new Tone.Oscillator(frequency).start()
        this.vco2 = new Tone.Oscillator(frequency + 150).start()
        this.vca1 = new Tone.Multiply(.5)
        this.headsEnvelope = new Tone.Envelope({
                        attack: 0.001,
                        decay: 0.1,
                        sustain: 0,
                        release: 0.1
                    })
        this.vco1.connect(this.vca1)
        this.vco2.connect(this.vca1)
        this.headsEnvelope.connect(this.vca1.factor)
        this.vca1.connect(this.output)
        //
        // Snare
        this.rattle = new Tone.Noise('white').start()
        this.ratFilter = new Tone.Filter({
                        type: "bandpass",
                        frequency: 1500, 
                        Q: 1
                    })
        this.vca2 = new Tone.Multiply(0.5)
        this.ratEnvelope = new Tone.Envelope({
                                attack: 0.001,
                                decay: 0.2,
                                sustain: 0,
                                release: 0.1
                                })
        this.rattle.connect(this.ratFilter)
        this.ratFilter.connect(this.vca2)
        this.ratEnvelope.connect(this.vca2.factor)
        this.vca2.connect(this.output)
    }

    trigger(time = null) {
        if (time) {
            this.ratEnvelope.triggerAttackRelease(0.01, time)
            this.headsEnvelope.triggerAttackRelease(0.01,time)
        } else {
            this.ratEnvelope.triggerAttackRelease(0.01)
            this.headsEnvelope.triggerAttackRelease(0.01)
        }
    }


        // this.ratEnvelope.triggerAttackRelease(0.01), this.headsEnvelope.triggerAttackRelease(0.01)
    }
    

/*
Stripe.js

output channel strip
input=>eq->gain->output, gain->send

methods:
- setEQ(low,mid,hi): note gain in dB
- seqEQBands(low,hi) set hi and low crossover
- setSendLevel()
- setGain()
- connect()
*/

;
;

class Stripe{
	constructor(){
		this.input = new Tone.Multiply(1)
		this.eq = new Tone.EQ3()
		this.gain = new Tone.Multiply(1)
		this.send = new Tone.Multiply(0)
		this.output = new Tone.Multiply(1)

		this.input.connect(this.eq)
		this.eq.connect(this.gain)
		this.gain.connect(this.send)
		this.gain.connect(this.output)
	}
	setEQ(low,mid,hi){
		this.eq.high.value = hi
		this.eq.mid.value = mid
		this.eq.low.value = low
	}
	setEQBands(low,hi){
		if(low < 10 || hi < 10){
			console.log('EQ bands are in Hz')
			return;
		}
		this.eq.highFrequency.value = hi
		this.eq.lowFrequency.value = low
	}
	setSendLevel(val){
		this.send.factor.value = val
	}
	setGain(val){
		this.gain.factor.value = val
	}
	connect(destination) {
		if (destination.input) {
		  this.output.connect(destination.input);
		} else {
		  this.output.connect(destination);
    }
  }
}

/*
Sympathy

Tuned delay lines for Karplus-Strong style sympathetic strings
* Individual string:
  * input->delay->vca->output
* Mixer:
  * input->hpf->EQ->vca->output
* Parameters:
  * numStrings (constructor)
  * frequencies: array
  * gains: array

methods:
- setFrequency(Hz): sets frequencies of delay lines in Hz
- setHighpass(freq, time) sets freq of hpf
- setEQ(low,mid,hi): note gain in dB
- seqEQBands(low,hi) set hi and low crossover
- connect(destination)

properties:
*/

;

class SympathyString{
	constructor(frequency = 100, amplitude = 1){
      this.input = new Tone.Multiply(1)
      this.delay = new Tone.LowpassCombFilter({resonance:.95,dampening:10000})
    
      this.vca = new Tone.Multiply(amplitude)
      this.output = new Tone.Multiply(1)
      //control
      this.delayTime = new Tone.Signal(.1)
      this.delayTimeScalar = new Tone.Multiply(1)
      //audio connections
      this.input.connect(this.delay)
      this.delay.connect(this.vca)
      this.vca.connect(this.output)
      //delay
      this.delayTime.connect( this.delayTimeScalar)
      this.delayTimeScalar.connect( this.delay.delayTime)
	}
  setFrequency = function(val,time=null){
    if(time){
      this.delayTime.setValueAtTime(1/val, time)
    } else this.delayTime.value = 1/val
  }
  setFeedback = function(val,time=null){
    val = val<0 ? 0 : val>0.9999 ? 0.9999 : val
    if(time){
      this.delay.resonance.setValueAtTime(val, time)
    } else {
      this.delay.resonance.value = val
    }
  }
  connect(destination) {
    this.output.connect(destination);
  }
}

class Sympathy{
  constructor(numStrings = 6, frequencies = [100,200,300,400,500,600]){
      this.numStrings = numStrings
      this.frequencies = frequencies
      this.input = new Tone.Multiply(1)
      this.hpf = new Tone.Filter({frequency: 20, type:'highpass', Q: 0})
      this.eq = new Tone.EQ3()
      this.vca = new Tone.Multiply(1)
      this.output = new Tone.Multiply(1)
      //control
      this.hpf_cutoff = new Tone.Signal(20)
      //audio connections
      //this.input.connect(this.hpf)
      this.hpf.connect(this.eq)
      this.eq.connect(this.vca)
      this.vca.connect(this.output)
      //strings
      this.strings = []
      this.detune = 0

      //make sure frequencies is long enough
      while(this.frequencies.length<this.numStrings) this.frequencies.push(this.frequencies[0])
      
      for(let i=0;i<this.numStrings;i++) {
        this.strings.push(new SympathyString(frequencies[i],1-(frequencies[i]/5000)))
        this.input.connect(this.strings[i].input)
        this.strings[i].output.connect(this.hpf)
      }
  }
  setFrequencies = function(vals,time=null){
    if(vals.length != this.numStrings){
      console.log("incorrect freq array size, should be ", this.numStrings)
      return
    }
    if(time){
      for(let i=0;i<this.numStrings;i++) {
        this.frequencies[i] = vals[i] * (1 - (Math.random()-.5)*this.detune)
        this.strings[i].setFrequency(this.frequencies[i], time)
      }
    } else {
      for(let i=0;i<this.numStrings;i++) {
        this.frequencies[i] = vals[i] * (1 - (Math.random()-.5)*this.detune)
        this.strings[i].setFrequency(this.frequencies[i])
      }
    }
  }
  setDetune = function(val){
    this.detune = val
    this.setFrequencies(this.frequencies)
  }
  setFeedback = function(val,time=null){
    val = val<0 ? 0 : val>0.9999 ? 0.9999 : val
    if(time){
      for(let i=0;i<this.numStrings;i++) this.strings[i].setFeedback(val, time)
    } else {
      for(let i=0;i<this.numStrings;i++) this.strings[i].setFeedback(val)
    }
  }
  setGains = function(vals,time=null){
    if(vals.length != this.numStrings){
      console.log("incorrect gains array size, should be ", this.numStrings)
      return
    }
    if(time){
      for(let i=0;i<this.numStrings;i++) this.strings[i].vca.factor.exponentialRampToValueAtTime(vals[i],.1)
    } else {
      for(let i=0;i<this.numStrings;i++) this.strings[i].vca.factor.value = vals[i]
    }
  }
  setHighpass = function(val){this.hpf.frequency.value = val }
  setEQ(low,mid,hi){
    this.eq.high.value = hi
    this.eq.mid.value = mid
    this.eq.low.value = low
  }
  setEQBands(low,hi){
    if(low < 10 || hi < 10){
      console.log('EQ bands are in Hz')
      return;
    }
    this.eq.highFrequency.value = hi
    this.eq.lowFrequency.value = low
  }
  connect(destination) {
    this.output.connect(destination);
  }
}

/*
ToneWood

convolution engine
* input->gain->convolver->waveShaper->output

methods:
- load(url) loads an IR
- filterIR: applies a lowpass to the IR, destructive
- highpassIR: applies a highpass to the IR, destructive
- stretchIR: stretches the IR
- ampIR: amplifies the IR into a softclipper

properties:
- gain.factor.value
*/

;
;

class ToneWood {
  constructor(gui = null) {
    this.gui = gui;
    this.input = new Tone.Multiply(1);
    this.gain = new Tone.Multiply(1)
    this.waveShaper = new Tone.WaveShaper((x)=>{
      return Math.tanh(x)
    })
    this.convolver = new Tone.Convolver();
    this.output = new Tone.Multiply(1);
    // Buffer
    this.buffer = null;
    // Audio connections
    this.input.connect(this.gain);
    this.gain.connect( this.convolver);
    this.waveShaper.connect( this.output);
    this.convolver.connect(this.waveShaper);
    this.convolver.normalize = true
  }

  load(url) {
    return new Promise((resolve, reject) => {
      new Tone.Buffer(url, (buffer) => {
        this.buffer = buffer;
        this.convolver.buffer = buffer
        resolve();
      }, reject);
    });
  }

  async filterIR(filterFreq) {
    if (!this.buffer) {
      console.error('Buffer not loaded.');
      return;
    }
    
    const context = Tone.getContext().rawContext;
    const duration = this.buffer.duration;
    const offlineContext = new OfflineAudioContext(2, duration * context.sampleRate, context.sampleRate);
    
    // Use the buffer directly from Tone.Buffer
    const decodedData = this.buffer.get();

    const source = offlineContext.createBufferSource();
    source.buffer = decodedData; // Use the buffer directly.
    
    // Example transformation: apply a filter (this could be more complex, including stretching)
    const filter = offlineContext.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = filterFreq;
    
    source.connect(filter);
    filter.connect(offlineContext.destination);
    
    source.start(0);
    
    return new Promise((resolve, reject) => {
      offlineContext.startRendering().then((renderedBuffer) => {
        // Use the rendered buffer as a new Tone.Buffer
        const newBuffer = new Tone.Buffer(renderedBuffer);
        this.buffer = newBuffer
        this.convolver.buffer = newBuffer; // Load it into the convolver
        resolve();
      }).catch(reject);
    });
  }//filter

  async stretchIR(stretchAmt) {
    if (!this.buffer) {
      console.error('Buffer not loaded.');
      return;
    }
    
    const context = Tone.getContext().rawContext;
    const duration = this.buffer.duration;
    const offlineContext = new OfflineAudioContext(2, duration * stretchAmt * context.sampleRate, context.sampleRate);
    
    // Use the buffer directly from Tone.Buffer
    const decodedData = this.buffer.get();

    const source = offlineContext.createBufferSource();
    source.buffer = decodedData; // Use the buffer directly.

    // Apply time-stretching by adjusting the playback rate
    source.playbackRate.value = 1/stretchAmt; // Adjust the playback rate based on the stretchVal
    source.connect(offlineContext.destination);
    source.start(0);
    
    return new Promise((resolve, reject) => {
      offlineContext.startRendering().then((renderedBuffer) => {
        // Use the rendered buffer as a new Tone.Buffer
        const newBuffer = new Tone.Buffer(renderedBuffer);
        this.buffer = newBuffer
        this.convolver.buffer = newBuffer; // Load it into the convolver
        resolve();
      }).catch(reject);
    });
  }//stretch

  async highpassIR(filterFreq) {
    if (!this.buffer) {
      console.error('Buffer not loaded.');
      return;
    }
    
    const context = Tone.getContext().rawContext;
    const duration = this.buffer.duration;
    const offlineContext = new OfflineAudioContext(2, duration * context.sampleRate, context.sampleRate);
    
    // Use the buffer directly from Tone.Buffer
    const decodedData = this.buffer.get();

    const source = offlineContext.createBufferSource();
    source.buffer = decodedData; // Use the buffer directly.
    
    // Example transformation: apply a filter (this could be more complex, including stretching)
    const filter = offlineContext.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = filterFreq;
    
    source.connect(filter);
    filter.connect(offlineContext.destination);
    
    source.start(0);
    
    return new Promise((resolve, reject) => {
      offlineContext.startRendering().then((renderedBuffer) => {
        // Use the rendered buffer as a new Tone.Buffer
        const newBuffer = new Tone.Buffer(renderedBuffer);
        this.buffer = newBuffer
        this.convolver.buffer = newBuffer; // Load it into the convolver
        resolve();
      }).catch(reject);
    });
  }//highpass

  //NOTE: changing amp and waveshaping never worked as expected
  // async ampIR(gainVal) {
  //   if (!this.buffer) {
  //     console.error('Buffer not loaded.');
  //     return;
  //   }
    
  //   const context = Tone.getContext().rawContext;
  //   const duration = this.buffer.duration;
  //   const offlineContext = new OfflineAudioContext(2, duration * context.sampleRate, context.sampleRate);
    
  //   // Use the buffer directly from Tone.Buffer
  //   const decodedData = this.buffer.get();

  //   const source = offlineContext.createBufferSource();
  //   source.buffer = decodedData; // Use the buffer directly.
    
  //   // Create a Multiply node
  //   const gain = offlineContext.createGain();
  //   gain.gain.value = gainVal
  //   console.log(gainVal, gain.gain.value)

  //   // Correct setup for WaveShaper node
  //   const waveShaper = offlineContext.createWaveShaper();
  //   waveShaper.curve = this.generateWaveShaperCurve(256); // Example length, adjust as needed
  //   waveShaper.oversample = '4x'; // Optional: Apply oversampling to reduce aliasing


  //   // Connect the nodes
  //   source.connect(gain);
  //   source.connect(waveShaper);
  //   waveShaper.connect(offlineContext.destination);
    
  //   source.start(0);
    
  //   return new Promise((resolve, reject) => {
  //     offlineContext.startRendering().then((renderedBuffer) => {
  //       // Use the rendered buffer as a new Tone.Buffer
  //       const newBuffer = new Tone.Buffer(renderedBuffer);
  //       this.buffer = newBuffer
  //       this.convolver.buffer = newBuffer; // Load it into the convolver
  //       resolve();
  //     }).catch(reject);
  //   });
  // }//amp

  // generateWaveShaperCurve(length = 256) {
  //   const curve = new Float32Array(length);
  //   for (let i = 0; i < length; i++) {
  //     let x = (i * 2) / length - 1; //convert to -1,1
  //     //curve[i] = Math.tanh(x*128); // Adjust this function as needed
  //     curve[i] = x>0 ? 1 : -0; 
  //     //curve[i] = x
  //   }
  //   console.log(curve)
  //   return curve;
  // }

  connect(destination) {
    this.output.connect(destination);
  }
}


window.TwinklePresets = {
  "default": {
    "type": "square",
    "cutoff": 275.48799999999994,
    "Q": 0,
    "keyTrack": 0,
    "envDepth": 1457.5999999999976,
    "level": 0,
    "adsr": [
      0.02506944444444445,
      0.39062500000000155,
      0.08027777777777759,
      0.2669444444444446
    ]
  },
  "chirp": {
    "type": "saw",
    "cutoff": 380.278,
    "Q": 10.44300000000001,
    "keyTrack": 0,
    "envDepth": 2557.399999999998,
    "level": 0,
    "adsr": [
      0.01000000000000004,
      0.3500694444444451,
      0.08999999999999969,
      0.21777777777777863
    ]
  },
  "pluck": {
    "type": "square",
    "cutoff": 343.35200000000003,
    "Q": 11.532000000000012,
    "keyTrack": 0,
    "envDepth": 1306.3999999999974,
    "level": 0,
    "adsr": [
      0.01,
      0.4,
      0.5,
      0.8
    ]
  },
  "flute": {
    "type": "tri",
    "cutoff": 20,
    "Q": 0,
    "keyTrack": 0,
    "envDepth": 2197.4000000000037,
    "level": 0,
    "adsr": [
      0.8402777777777787,
      1,
      1,
      1
    ]
  },
  "drone": {
    "type": "saw",
    "cutoff": 435.3276799999999,
    "Q": 14.700000000000012,
    "keyTrack": 0,
    "envDepth": 8.600000000001046,
    "level": 0.5041000000000002,
    "adsr": [
      0.8402777777777787,
      1,
      1,
      1
    ]
  }
};;

/*
Twinkle

Single vco monosynth
* vco->vcf->vca->output

methods:
- connect
- setADSR(a,d,s,r)


properties set directly:
frequency.value
velocitySig.value
cutoff_cv.value
vca_lvl.value
cutoffSig.value
vcf_env_depth.factor
keyTracking.factor
lfo.frequency

*/
;
;
;
;

;

class Twinkle extends MonophonicTemplate {
  constructor (gui = null) {
    super()
    this.gui = gui
    this.presets = TwinklePresets
    this.isGlide = false
    this.name = "Twinkle"
    console.log(this.name, " loaded, available preset: ", this.presets)

    // Initialize the main frequency control
    this.frequency = new Tone.Signal(200);

    // VCOs
    this.vco = new Tone.OmniOscillator({ type:'pulse'}).start();
    this.frequency.connect(this.vco.frequency)

    // VCF
    this.vcf = new Tone.Filter({type:"lowpass", rolloff:-24});
    this.vco.connect(this.vcf);

    // VCF, VCA, output
    this.vca = new Tone.Multiply()
    this.vcf.connect(this.vca)
    this.output = new Tone.Multiply(1)
    this.vcf.connect(this.vca)
    this.vca.connect(this.output)

    // VCA control
    this.vca_lvl = new Tone.Signal();
    this.vca_lvl.connect(this.vca.factor)
    this.env = new Tone.Envelope();
    this.env.releaseCurve = 'linear'
    this.env.decayCurve = 'exponential'
    this.env_depth = new Tone.Multiply()
    this.env.connect(this.env_depth)
    this.env_depth.connect(this.vca.factor)
    this.velocitySig = new Tone.Signal(1)
    this.velocitySig.connect(this.env_depth.factor)

    //vcf control
    this.cutoffSig = new Tone.Signal(1000);
    this.cutoff_cv = new Tone.Signal(0);
    this.vcf_env_depth = new Tone.Multiply(500);
    this.keyTracker = new Tone.Multiply(.1)
    this.env.connect(this.vcf_env_depth)
    this.vcf_env_depth.connect(this.vcf.frequency)
    this.cutoffSig.connect(this.vcf.frequency)
    this.cutoff_cv.connect(this.vcf.frequency)
    this.frequency.connect(this.keyTracker)
    this.keyTracker.connect(this.vcf.frequency)

    let paramDefinitions = [
      {name:'type',type:'vco',value:'square',radioOptions:['square','saw','tri','sine'],callback:(x,time=null)=>{
          switch(x){
          case 'square': this.vco.type = 'pulse'; break;
            case 'saw': this.vco.type = 'sawtooth'; break;
              case 'tri': this.vco.type = 'triangle'; break;
                case 'sine': this.vco.type = 'sine'; break;
          }
        }
      },
      {name:'cutoff',type:'vcf',min:20.,max:10000,curve:2,callback:(x,time=null)=>this.cutoffSig.value = x},
      {name:'Q',type:'vcf',min:0.,max:30,curve:2,callback:(x,time=null)=>this.vcf.Q.value = x},
      {name:'keyTrack',type:'hidden',min:0.,max:2,curve:1,callback:(x,time=null)=>this.keyTracker.factor.value = x},
      {name:'envDepth',type:'vcf',min:-1000,max:5000,curve:2,callback:(x,time=null)=>this.vcf_env_depth.factor.value = x},
      {name:'level',value:0,type:'vca',min:0.,max:1,curve:2,callback:(x,time=null)=>this.vca_lvl.value = x},
      {name:'adsr',type:'env',min:0,max:1,curve:2,value:[.01,.1,.5,.5],
        labels:['attack','decay','sustain','release'],
        callback:(x,i=null)=>{
          if( Array.isArray(x)){
            if( x.length<=4) this.setADSR(x[0],x[1],x[2],x[3])
          }
          else if(i==0)this.env.attack = x
          else if(i==1)this.env.decay = x
          else if(i==2)this.env.sustain = x
          else if(i==3)this.env.release = x
        }
    }
    ]

    this.param = this.generateParameters(paramDefinitions)
    this.createAccessors(this, this.param);

    //for autocomplete
    this.autocompleteList = paramDefinitions.map(def => def.name);;
    //for(let i=0;i<this.paramDefinitions.length;i++)this.autocompleteList.push(this.paramDefinitions[i].name)
    setTimeout(()=>{this.loadPreset('default')}, 500);
  }//constructor

  //envelopes
  triggerAttack (freq, amp, time=null){
    freq = Tone.Midi(freq).toFrequency()
    amp = amp/127
    if(time){
      this.env.triggerAttack(time)
      this.frequency.setValueAtTime(freq, time)
      this.velocitySig.setValueAtTime(amp,time)
    } else {
      this.env.triggerAttack()
      this.frequency.value = freq
      this.velocitySig.rampTo(amp,.03)
    }
  }
  triggerRelease (time=null){
    if(time) {
    	this.env.triggerRelease(time)
    }
    else {
      this.env.triggerRelease()
    }
  }
  triggerAttackRelease (freq, amp, dur=0.01, time=null){
    //console.log('AR ',freq,amp,dur,time)
    freq = Tone.Midi(freq).toFrequency()
    amp = amp/127
    if(time){
      this.env.triggerAttackRelease(dur, time)
      this.frequency.setValueAtTime(freq, time)
      this.velocitySig.setValueAtTime(amp,time)
    } else{
      this.env.triggerAttackRelease(dur)
      this.frequency.value = freq
      this.velocitySig.rampTo(amp,.03)
    }
  }//attackRelease


  //GUI
  // Initialize GUI
  initGui(gui=null) {
    //console.log('init', this.param)
    this.gui = gui
    const layout = basicLayout.basicLayout;

    // Group parameters by type
    const groupedParams = {};
    Object.values(this.param).forEach((param) => {
        if (!groupedParams[param.type]) groupedParams[param.type] = [];
        groupedParams[param.type].push(param);
    });

    // Create GUI for each group
    Object.keys(groupedParams).forEach((groupType) => {
        const groupLayout = layout[groupType];
        if (!groupLayout) return;
        if (groupType === 'hidden') return;
      


        let indexOffset = 0
        groupedParams[groupType].forEach((param, index) => {
          const isGroupA = groupLayout.groupA.includes(param.name);

          // Calculate size and control type
          const controlType = isGroupA ? groupLayout.controlTypeA : groupLayout.controlTypeB;
          const size = isGroupA ? groupLayout.sizeA : groupLayout.sizeB;
          // Calculate offsets
          let xOffset = 0//groupLayout.offsets.x * (index % Math.floor(groupLayout.boundingBox.width / groupLayout.offsets.x));
          let yOffset = 0//groupLayout.offsets.y * Math.floor(index / Math.floor(groupLayout.boundingBox.width / groupLayout.offsets.x));
          if( Array.isArray( param._value )){
            param._value.forEach((_, i) => {
              // Calculate offsets
             xOffset = groupLayout.offsets.x * ((index+indexOffset) % Math.floor(groupLayout.boundingBox.width / groupLayout.offsets.x));
             yOffset = groupLayout.offsets.y * Math.floor((index+indexOffset) / Math.floor(groupLayout.boundingBox.width / groupLayout.offsets.x));
            
              // Calculate absolute positions
              const x = groupLayout.boundingBox.x + xOffset;
              const y = groupLayout.boundingBox.y + yOffset;
              this.createGuiElement(param, { x, y, size, controlType, color: groupLayout.color, i });
              indexOffset++
            })
          } else{
            xOffset = groupLayout.offsets.x * ((index+indexOffset) % Math.floor(groupLayout.boundingBox.width / groupLayout.offsets.x));
            yOffset = groupLayout.offsets.y * Math.floor((index+indexOffset) / Math.floor(groupLayout.boundingBox.width / groupLayout.offsets.x));
          
            // Calculate absolute positions
            const x = groupLayout.boundingBox.x + xOffset;
            const y = groupLayout.boundingBox.y + yOffset;
            // Create GUI element
            this.createGuiElement(param, { x, y, size, controlType, color: groupLayout.color });    
          }

        });
    });
}

    // Create individual GUI element
    createGuiElement(param, { x, y, size, controlType, color, i=null }) {
    //console.log('createG', param, x,y,size,controlType, i)
    if (controlType === 'knob') {
        param.guiElements.push(this.gui.Knob({
            label: i ? param.labels[i] : param.name,
            min: param.min,
            max: param.max,
            value: param._value,
            size: size , // Scale size
            curve: param.curve,
            x,
            y,
            accentColor: color,
            callback: (value) => param.set(value,i,true),
        }));
    } else if (controlType === 'fader') {
        param.guiElements.push(this.gui.Fader({
            label: i ? param.labels[i] : param.name,
            min: param.min,
            max: param.max,
            curve: param.curve,
            size: size , // Scale size
            x,
            y,
            accentColor: color,
            callback: (value) => param.set(value,i,true),
        }));
    } else if (controlType === 'radioButton') {
        if (!Array.isArray(param.radioOptions) || param.radioOptions.length === 0) {
            console.warn(`Parameter "${param.name}" has no options defined for radioBox.`);
            return null;
        }

        return this.gui.RadioButton({
            label: i ? param.labels[i] : param.name,
            radioOptions: param.radioOptions,
            x:x,
            y:y+10,
            accentColor: color,
            callback: (selectedOption) => param.set(selectedOption),
        });
    }
}

  createKnob(label, x, y, min, max, size, accentColor, callback) {
    return this.gui.Knob({
      label, min, max, size, accentColor,
      x: x + this.x, y: y + this.y,
      callback: callback,
      showLabel: 1, showValue: 0, // Assuming these are common settings
      curve: 2, // Adjust as needed
      border: 2 // Adjust as needed
    });
  }

  /**
     * Save a preset by name
     * @param {string} name - Name of the preset to save
     * @returns {void}
     * @example synth.savePreset('default')
     */
    savePreset (name) {
        const _preset = {};
        for (let element of Object.values(this.param)) {
            _preset[element.name] = element._value;
        }
        console.log(this.presets)
        // Update the presetsData in memory
        //console.log(this.presets);
        if (!this.presets[name]) {
            this.presets[name] = {};
        }
        this.presets[name] = _preset;

        console.log(`Preset saved under ${this.name}/${name}`);
    };

    /**
     * Download the presets data as a JSON file
     * @returns {void}
     * @example synth.downloadPresets()
     */
    downloadPresets ()  {
        this.presetsData = this.presets;
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.presetsData, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", `${this.name}Presets.json`);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    };

    /**
     * Load a preset by name
     * @param {string} name - Name of the preset to load
     * @returns {void}
     * @example synth.loadPreset('default')
     */
    loadPreset(name) {
        this.curPreset = name;
        const presetData = this.presets[this.curPreset];

        if (presetData) {
            console.log("Loading preset ", this.curPreset);
            for (let name in presetData) {
                try {
                    for (let element of Object.values(this.param)) {
                        this.param[name].set(presetData[name])
                    }
                } catch (e) {
                    console.log(e);
                }
            }
        } else {
            console.log("No preset of name ", name);
        }
    }

    logPreset() {
        const presetData = this.presets[this.curPreset];

        if (presetData) {

          let output = 'Parameters:\n';
          for (let key in presetData) {
              const param = presetData[key];
              if (Array.isArray(param)) {
                  const formattedArray = param.map((value) => {
                      if (typeof value === "number") {
                          return Number(value.toFixed(2)); // Limit to 2 decimals
                      }
                      return value; // Keep non-numbers unchanged
                  });

                  output += `${key}: [${formattedArray.join(", ")}]\n`; // Add the array to output
              }
              else if(typeof param === 'number') output += `${key}: ${param.toFixed(2)}\n`;
              else output += `${key}: ${param}\n`;
          }
          console.log(output);
        }
        /*

        if (presetData) {
            console.log("Preset " + this.curPreset);
            for (let id in presetData) {
                try {
                    for (let element of Object.values(this.gui.elements)) {
                        if (element.id === id) {
                            if (element.type !== 'momentary') console.log(id, presetData[id]);
                        }
                    }
                } catch (e) {
                    console.log(e);
                }
            }
        } 
  */
        else {
            console.log("No preset of name ", this.curPreset);
        }
    }

    /**
     * Console log all available presets
     * @returns {void}
     * @example synth.listPresets()
     */
    listPresets() {
        console.log("Synth presets", this.presets);
    }

}



;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
//* from './waveshapers.js';
;
;
;
;
;
;
;
// ;
// ;
// ;
// ;

;

;
// ;
// ;
// ;
// ;






function hardClip(value){
  return Math.max(Math.min(value*4,1),-1)
}
function softClip(value){
  return Math.tanh(value*4) 
}
function hardSync(value){
  value *= 8
  if(value > 0) return value%1 
  else if (value <0) return Math.abs(value)%1*-1 
  else return 0
}
function pwm(x){
  //return x
  //x = Math.pow(Math.abs(x/2+.5),.5)
 // x=Math.abs(x)<.3 ? .25*Math.sign(x): x
  //console.log(x)
  return x > .05 ? 1 : -1;
}
function sawToTri(value){
  value *= 2.3
  if(Math.abs(value) <= 1) return value
  if(value > 1) return 2-value
  if (value < -1) return -2-value 
}
function triangleFolder(value){
  value = Math.abs(value*8 + 0.5)
  if( Math.floor(value%2) == 0 ) {
    return (value%1) * 2 - 1
  } else{
    return (1 - (value%1)) * 2 - 1
  }
}
function sineFolder(value){
  return Math.sin(value * Math.PI * 8);
}
function pseudorandom(value){
  let seed = (Math.abs(value)-.0)*7
  const pseudoRandom = ((seed * 9187543225 + 12345) % 4294967296) / 4294967296;
  return pseudoRandom * 2 - 1
}

/** Oscilloscope class
 * * uses svg drawing on a canvas
 * 
 * Based on: https://github.com/Sambego/oscilloscope.js
 */
/****************************************



OSCILLOSCOPE


****************************************/
;

/**
 * Represents an Oscilloscope that visualizes audio waveforms.
 * 
 * @param {string} _target - The ID of the HTML element where the oscilloscope will be displayed.
 * 
 * @class
 */
const Oscilloscope = function( _target, ratio = 4 / 10) {
    // Get the target DOM element and set dimensions based on the provided ratio
    this.target = document.getElementById(_target);
    this.width = this.target.offsetWidth;
    this.height = this.width * ratio;

    // Create the SVG path for the oscilloscope wave
    this.wave = document.createElementNS("http://www.w3.org/2000/svg", 'path');
    this.wave.setAttribute('class', 'oscilloscope__wave');

    // Create the SVG element to contain the wave
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute('width', this.width);
    this.svg.setAttribute('height', this.height);
    this.svg.setAttribute('class', 'oscilloscope__svg');
    this.svg.appendChild(this.wave);

    // Append the SVG to the target container
    this.target.appendChild(this.svg);

    // Use Tone.js's audio context or create a new one
    //this.audioContext = Tone.context;
    this.audioContext = window.audioContext;
    
    // State variables
    this.running = true; // Indicates if oscilloscope is running
    this.hasAudio = false; // If the oscilloscope is connected to the audio context destination

    // Set up the input and gain for the oscilloscope
    this.input = new Tone.Multiply();
    this.gain = new Tone.Signal(1);
    this.analyserNode = this.audioContext.createAnalyser(); // Create an analyser node for audio data
    this.input.connect(this.analyserNode); // Connect input to analyser
    this.gain.connect(this.input.factor); // Connect gain to input

    // Configuration for the analyser node
    this.analyserNode.fftSize = 2048;
    this.bufferLength = this.analyserNode.frequencyBinCount;
    this.dataArray = new Uint8Array(this.bufferLength);

    // Display settings
    this.yScaling = 1; // Scaling factor for Y axis
    this.xScaling = 2; // Scaling factor for X axis
    this.zoom = 1.25; // Zoom level
    this.enableTrigger = 1; // Trigger for zero-crossing detection
    this.threshold = 128; // Threshold for signal triggering

    /**
     * Automatically start the oscilloscope when the constructor is called.
     */
    this.constructor = function() {
        this.start();
        console.log('Oscilloscope started');
    };

    /**
     * Set the FFT size for the analyser node.
     * Ensures the value is a power of two, as required by the Web Audio API.
     * @memberof Oscilloscope
     * @param {number} val - The FFT size to set.
     */
    this.setFftSize = function(val) {
        if (Math.log2(val) % 1 !== 0) {
            val = Math.pow(2, Math.floor(Math.log2(val))); // Adjust to nearest power of two
            console.log("FFT size must be a power of two.");
        }
        console.log("Setting FFT size to", val);
        this.analyserNode.fftSize = val;
        this.bufferLength = this.analyserNode.frequencyBinCount;
        this.dataArray = new Uint8Array(this.bufferLength);
    }.bind(this);

    /**
     * Draw the waveform data in the oscilloscope SVG.
     * @memberof Oscilloscope
     */
    this.drawWave = function() {
        var path = 'M';
        this.analyserNode.getByteTimeDomainData(this.dataArray); // Get waveform data

        // Find the first point that crosses the threshold for triggering
        var firstOverThreshold = 0;
        let threshold = this.threshold <= 1 ? this.threshold * 128 + 127 : this.threshold;

        for (var i = 1; i < this.bufferLength; i++) {
            if (this.dataArray[i] > threshold && this.dataArray[i - 1] <= threshold) {
                firstOverThreshold = i;
                break;
            }
        }
        if (this.enableTrigger === 0) firstOverThreshold = 0;

        // Start drawing the path
        let x = 0;
        let y = this.height / 2;
        path += `${x} ${y}, `;

        // Scaling the X axis based on zoom level
        this.xScaling = this.zoom < 0.1 ? 0.2 : this.zoom * 2;

        // Draw the waveform as a series of points
        for (var i = 0; i < this.bufferLength - firstOverThreshold; i++) {
            let val = (255 - this.dataArray[i + firstOverThreshold]) * (1 / this.yScaling);
            x = (this.width / this.bufferLength) * i * this.xScaling;
            y = (this.height / 2) * (val / 128.0);

            // Stop drawing if the X value exceeds the scope's width
            if (x > this.width - 10) break;

            path += `${x} ${y}, `;
        }

        // Update the SVG path with the new waveform
        this.wave.setAttribute('d', path);
        this.wave.setAttribute('stroke', 'black');
        this.wave.setAttribute('stroke-width', '2');
        this.wave.setAttribute('fill', 'none');

        // Continue drawing if running
        if (this.running) {
            window.requestAnimationFrame(this.drawWave);
        }
    }.bind(this);

    /**
     * Start the oscilloscope animation.
     * @memberof Oscilloscope
     */
    this.start = function() {
        this.running = true;
        window.requestAnimationFrame(this.drawWave);
    }.bind(this);

    /**
     * Stop the oscilloscope animation.
     * @memberof Oscilloscope
     */
    this.stop = function() {
        this.running = false;
    }.bind(this);

    /**
     * Disconnect the oscilloscope from its target.
     * @memberof Oscilloscope
     */
    this.disconnect = function() {
        this.target.removeChild(this.svg);
    }.bind(this);

    /**
     * Reconnect the oscilloscope to a target.
     * @memberof Oscilloscope
     * @param {string} _target - The ID of the new target DOM element.
     */
    this.connect = function(_target) {
        this.target = document.getElementById(_target);
        this.target.appendChild(this.svg);
    }.bind(this);

    /**
     * Clean up and delete the oscilloscope object.
     * Stops the animation, removes DOM elements, and nullifies references.
     * @memberof Oscilloscope
     */
    this.destroy = function() {
        // Stop the oscilloscope animation if running
        this.stop();

        setTimeout(()=>{
            // Remove the SVG element from the DOM
            if (this.target.contains(this.svg)) {
                this.target.removeChild(this.svg);
            }

            // Disconnect the analyser node and nullify object references to free memory
            this.analyserNode.disconnect();
            this.input.disconnect();
            this.gain.dispose();

            // Nullify all references to help with garbage collection
            this.target = null;
            this.wave = null;
            this.svg = null;
            this.audioContext = null;
            this.input = null;
            this.gain = null;
            this.analyserNode = null;
            this.dataArray = null;

            console.log("Oscilloscope destroyed.");
        }, 100)
        
    }.bind(this);

    // Automatically start the oscilloscope upon creation
    this.start();
};










/****************************************

plotTransferFunction

****************************************/

/**
 * Plots a transfer function on a specified SVG element with axis labels.
 * @module TransferFunctionPlotter
 * @param {function} myFunction - The transfer function to plot. Takes a number input and returns a number.
 * @param {string} _target - The ID of the HTML element where the transfer function will be plotted.
 */
const PlotTransferFunction = function(myFunction, _target = 'Canvas1', ratio= 4/10) {
    const target = document.getElementById(_target);

    // Check if an existing SVG is present and remove it if it is
    const existingSVG = target.querySelector('svg.transfer-function-svg');
    if (existingSVG) {
        target.removeChild(existingSVG);
    }

    if(myFunction === 'stop'){
        
        return
    }
    // Set the dimensions based on the target container
    const width = target.offsetWidth; 
    const height = target.offsetWidth*ratio;
    const graph_size = height - 10

    

    // Create the SVG element for the transfer function
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('class', 'transfer-function-svg');

    // Draw border around the graph
    const border = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
    border.setAttribute('x', '1');
    border.setAttribute('y', '1');
    border.setAttribute('width', graph_size - 1);
    border.setAttribute('height', graph_size - 1);
    border.setAttribute('stroke', 'black');
    border.setAttribute('fill', 'none');
    svg.appendChild(border);

    // Create the path element for the transfer function
    const path = document.createElementNS("http://www.w3.org/2000/svg", 'path');
    path.setAttribute('class', 'transfer-function-path');
    svg.appendChild(path);

    // Append the SVG element to the target container
    target.appendChild(svg);

    // Function to draw the transfer function
    var _path = 'M';
    let range = {min: -1, max: 1};
    let step = (range.max - range.min) / graph_size;
    let x = range.min;

    for (let i = 0; i < graph_size; i++) {
        let y = myFunction(x);
        let svgX = i;  // map x directly to pixel x-coordinate
        let svgY = graph_size / 2 - (y * graph_size/2);  // scale y and invert, adjust scale factor as needed

        _path += `${svgX} ${svgY} `;
        x += step;
    }

    path.setAttribute('d', _path);
    path.setAttribute('stroke', 'black');
    path.setAttribute('stroke-width', '2');
    path.setAttribute('fill', 'none');

    // Add labels for -1 and 1 on both the X and Y axes
    function addLabel(text, x, y) {
        const label = document.createElementNS("http://www.w3.org/2000/svg", 'text');
        label.setAttribute('x', x);
        label.setAttribute('y', y);
        label.textContent = text;
        label.setAttribute('font-family', 'sans-serif');
        label.setAttribute('font-size', '10px');
        label.setAttribute('fill', 'black');
        svg.appendChild(label);
    }

     // Add labels for -1 and 1 on both the X and Y axes with optional rotation
    function addLabel(text, x, y, rotation, anchor, valign) {
        const label = document.createElementNS("http://www.w3.org/2000/svg", 'text');
        label.setAttribute('x', x);
        label.setAttribute('y', y);
        label.textContent = text;
        label.setAttribute('font-family', 'sans-serif');
        label.setAttribute('font-size', '10px');
        label.setAttribute('fill', 'black');
        if (rotation) {
            label.setAttribute('transform', `rotate(${rotation} ${x}, ${y})`);
        }
        if (anchor) {
            label.setAttribute('text-anchor', anchor);
        }
        if (valign) {
            label.setAttribute('alignment-baseline', valign);
        }
        svg.appendChild(label);
    }

    addLabel('-1', 5, height - 2, 0, 'start', 'baseline');
    addLabel('input', graph_size / 2, height - 11, 0, 'middle', 'hanging');
    addLabel('1', graph_size - 5, height - 2,0, 'end', 'baseline');
    addLabel('-1', graph_size + 3, graph_size - 5, 90, 'middle', 'baseline');
    addLabel('1', graph_size + 13, 10, 90, 'middle', 'hanging');
    addLabel('output', graph_size + 3, graph_size / 2, 90, 'middle', 'baseline'); // Rotated "output" label

}

/****************************************

SPECTROGRAM

****************************************/
;

/**
 * Represents a Spectrogram that visualizes the frequency spectrum of audio signals.
 * 
 * @param {string} _target - The ID of the HTML element where the spectroscope will be displayed.
 * 
 * @class
 */

const Spectrogram = function (_target, height = 100) {
    this.target = document.getElementById(_target);

    // Canvas setup
    this.canvas = document.createElement('canvas');
    this.context = this.canvas.getContext('2d');
    this.width = this.target.offsetWidth;
    this.height = height;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.target.appendChild(this.canvas);
    this.context.fillStyle = "lightgrey";
    this.context.fillRect(0, 0, this.width, this.height);

    // Audio context and analyser node
    this.audioContext = window.audioContext || new (window.AudioContext || window.webkitAudioContext)();
    this.analyserNode = this.audioContext.createAnalyser();
    this.analyserNode.smoothingTimeConstant = 0.0;
    this.input= new Tone.Multiply()
    this._gain = new Tone.Signal(0.1)
    this.input.connect( this.analyserNode )
    this._gain.connect( this.input.factor )
    this.analyserNode.fftSize = 4096; // Default FFT size
    this.bufferLength = this.analyserNode.frequencyBinCount;
    this.dataArray = new Uint8Array(this.bufferLength);

    // Spectrogram settings
    this._maxFrequency = 24000; // Default max frequency
    this._minFrequency = 0;     // Default min frequency
    this._timeResolution = 2;  // Number of pixels per time frame
    this.currentX = 0;        // Current horizontal position
    this.running = false;

    // Color mapping (amplitude to color)
    const getColor = (amplitude) => {
        // let intensity = [
        // amplitude * 3,
        // (amplitude-20) * 2 ,
        // (amplitude-40) * 1 ,
        // ]; // Normalize amplitude
        let intensity = [
        //Math.sin((amplitude/255) * Math.PI * 2.5)*255,
        Math.sin((amplitude/255-.25) * Math.PI * 3)*255,
        amplitude<128?0 : Math.sin(((amplitude-128)/255) * Math.PI * 1)*255,
        Math.sin((amplitude/255) * Math.PI * 2.5)*255,
        ]; // Normalize amplitude
        intensity = intensity.map(x=> Math.min(255, Math.max(0, x)))
        return `rgb(${intensity[0]}, ${intensity[1]}, ${intensity[2]})`;
    };

    Object.defineProperty(this, 'gain', {
        get: () => this._gain.value,
        set: (value) => {
            this._gain.value = value;
        },
    });

    // Frequency range setters and getters
    Object.defineProperty(this, 'minFrequency', {
        get: () => this._minFrequency,
        set: (value) => {
            this._minFrequency = Math.max(0, Math.min(value, this.maxFrequency));
        },
    });

    Object.defineProperty(this, 'maxFrequency', {
        get: () => this._maxFrequency,
        set: (value) => {
            this._maxFrequency = Math.max(this.minFrequency, Math.min(value, this.audioContext.sampleRate / 2));
        },
    });

    // Time resolution setter and getter
    Object.defineProperty(this, 'timeResolution', {
        get: () => this._timeResolution,
        set: (value) => {
            this._timeResolution = Math.max(1, value);
        },
    });

    // Time resolution setter and getter
    Object.defineProperty(this, 'fftSize', {
        get: () => this._timeResolution,
        set: (val) => {
            if (Math.log2(val) % 1 !== 0) {
                val = Math.pow(2, Math.floor(Math.log2(val)))
                console.log("FFT size must be a power of two.")
            }
            console.log("Setting FFT size to ", val)
            
            this.analyserNode.fftSize = val;
            this.bufferLength = this.analyserNode.frequencyBinCount;
            this.dataArray = new Uint8Array(this.bufferLength);
        },
    });

    this.drawSpectrogram = function () {
    // Get frequency data
    this.analyserNode.getByteFrequencyData(this.dataArray);

    // Clear the current frame column
    this.context.clearRect(this.currentX, 0, this._timeResolution, this.height);

    const freqRange = this._maxFrequency - this._minFrequency;
    const binWidth = (this.audioContext.sampleRate / 2) / this.bufferLength;
    const startBin = Math.floor(this._minFrequency / binWidth);
    const endBin = Math.ceil(this._maxFrequency / binWidth);

    // Calculate vertical scaling
    const binHeight = this.height / (endBin - startBin);

    for (let i = startBin; i <= endBin; i++) {
        const freq = i * binWidth;

        // Map frequency to vertical position
        const y = this.height - Math.floor((freq - this._minFrequency) * (this.height / freqRange));

        // Get amplitude and map to color
        //const amplitude = Math.min(255, Math.max(0, this.dataArray[i]));
        const amplitude = this.dataArray[i];
        const color = getColor(amplitude);
        //if(i<10) console.log(this.dataArray[i],amplitude, color)

        this.context.fillStyle = color;

        // Adjust height based on binHeight
        if (binHeight >= 1) {
            // Scale bin to cover multiple vertical pixels
            this.context.fillRect(this.currentX, y - binHeight, this._timeResolution, Math.ceil(binHeight));
        } else {
            // Draw as a single pixel
            this.context.fillRect(this.currentX, y, this._timeResolution, 1);
        }
    }

        // Move to the next frame position
        this.currentX += this._timeResolution;
        if (this.currentX >= this.width) {
            this.currentX = 0;
        }

        // Continue animation if running
        if (this.running) {
            requestAnimationFrame(this.drawSpectrogram);
        }
    }.bind(this);

    this.start = function () {
        this.running = true;
        requestAnimationFrame(this.drawSpectrogram);
    }.bind(this);

    this.stop = function () {
        this.running = false;
    }.bind(this);

    this.destroy = function () {
        this.stop();
        this.target.removeChild(this.canvas);
        this.analyserNode.disconnect();
        this.audioContext.close();
    }.bind(this);

    // Start the spectrogram by default
    this.start();
};

/****************************************

SPECTROSCOPE

****************************************/
;

/**
 * Represents a Spectroscope that visualizes the frequency spectrum of audio signals.
 * 
 * @param {string} _target - The ID of the HTML element where the spectroscope will be displayed.
 * 
 * @class
 */
const Spectroscope = function(_target, ratio= 4/10) {
    //var _drawWave, _bufferLength, _dataArray;

    //this.target = document.querySelector(target);
    this.target = document.getElementById(_target)

    // Set the dimensions based on the target container
    this.width = this.target.offsetWidth;
    this.height = this.target.offsetWidth*ratio;

    // Create the oscilloscope wave element
    this.wave = document.createElementNS("http://www.w3.org/2000/svg", 'path');
    this.wave.setAttribute('class', 'oscilloscope__wave');

    // Create the oscilloscope svg element
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute('width', this.width);
    this.svg.setAttribute('height', this.height);
    this.svg.setAttribute('class', 'oscilloscope__svg');
    this.svg.appendChild(this.wave);

    // Append the svg element to the target container
    this.target.appendChild(this.svg);

    // Add the audio context or create a new one
    this.audioContext = window.audioContext;

    // Indicates if the oscilloscope is running
    this.running = false;

    // Is the oscilloscope analyser-node connected to the audio-context' destination
    this.hasAudio = false;

     // Create the oscilloscope analyser-node
    // Create the oscilloscope analyser-node
    this.input= new Tone.Multiply()
    this.gain = new Tone.Signal(0.1)
    this.analyserNode = this.audioContext.createAnalyser();
    this.input.connect( this.analyserNode )
    this.gain.connect( this.input.factor )

    this.analyserNode.fftSize = 4096; // Default fftSize
    this.bufferLength = this.analyserNode.frequencyBinCount;
    this.dataArray = new Uint8Array(this.bufferLength);
    this.yScaling = 1;
    this.maxFrequency = 24000;
    this.minFrequency = 0;
    this.xScaling = 2;
    this.binWidth = 24000 / this.analyserNode.frequencyBinCount;

    // Set-up the analyser-node which we're going to use to get the oscillation wave
    /**
     * Set the FFT size for the analyser node.
     * 
     * @memberof Spectroscope
     * @param {number} val - The FFT size to set. Must be a power of two.
     */
    this.setFftSize = function(val){
        if (Math.log2(val) % 1 !== 0) {
            val = Math.pow(2, Math.floor(Math.log2(val)))
            console.log("FFT size must be a power of two.")
        }
        console.log("Setting FFT size to ", val)
        
        this.analyserNode.fftSize = val;
        this.bufferLength = this.analyserNode.frequencyBinCount;
        this.dataArray = new Uint8Array(this.bufferLength);
        this.binWidth = 24000 / this.bufferLength;
    }.bind(this);

    /*
     * Draw the oscillation wave
     */
    this.drawWave = function() {
        var path = 'M';

        this.analyserNode.getByteFrequencyData(this.dataArray);

        let x = this.width;
        let y = this.height / 2;

        const maxValue = Math.max(...this.dataArray);
        const minValue = Math.min(...this.dataArray);

        ////scale y axis. . . not implemented
        // if(this.yScaling > 1) this.yScaling *= 0.99;
        // if(maxValue > this.yScaling) this.yScaling = maxValue;
        // if(Math.abs(minValue) > this.yScaling) this.yScaling = Math.abs(minValue);

        x = 0
        y = this.height;

        path += `${x} ${y}, `;
        for (var i = 0 ; i < this.bufferLength; i++) {

            let freqDivider = 24000 / (this.maxFrequency-this.minFrequency)
            let freqOffset = this.minFrequency / this.binWidth

            //To do: get minFrequency working
            //console.log(this.binWidth, freqOffset, freqDivider)

            let val = (255-this.dataArray[i+freqOffset]) * (1/this.yScaling);
            x = (((this.width + (this.width / this.bufferLength)) / this.bufferLength) * (i));
            x = x * freqDivider;
            y = ((this.height / 2) * (val / 128.0));


            // Check if the x-coordinate is beyond the width of the scope
            if (x > this.width) break; // Exit the loop if x exceeds width

            path += `${x} ${y}, `;
        }

        x += 1
        y = this.height;

        path += `${x} ${y}, `;

        this.wave.setAttribute('d', path);
        this.wave.setAttribute('stroke', 'black');
        //this.wave.setAttribute('stroke-width', '2');
        //this.wave.setAttribute('fill', 'none');

        if (this.running) {
            //console.log(this.dataArray)
            window.requestAnimationFrame(this.drawWave);
        }
    }.bind(this);


    /**
     * Start the Spectroscope
     * @memberof Spectroscope
     */
    this.start = function() {
        this.running = true;

        window.requestAnimationFrame(this.drawWave);
    }.bind(this);

    /**
     * Stop the Spectroscope
     * @memberof Spectroscope
     */
    this.stop = function(){
        this.running = false;
    }.bind(this)

    this.disconnect = function(){
        this.target.removeChild(this.svg);
    }.bind(this)

    this.connect = function(_target){
        this.target = document.getElementById(_target)
        this.target.appendChild(this.svg);
    }

    this.start();

    this.destroy = function() {
        this.stop();

        setTimeout(()=>{
            // Remove the SVG element from the DOM
            if (this.target.contains(this.svg)) {
                this.target.removeChild(this.svg);
            }

            // Disconnect the analyser node and nullify object references to free memory
            this.analyserNode.disconnect();
            this.input.disconnect();
            this.gain.dispose();

            // Nullify all references to help with garbage collection
            this.target = null;
            this.wave = null;
            this.svg = null;
            this.audioContext = null;
            this.input = null;
            this.gain = null;
            this.analyserNode = null;
            this.dataArray = null;

            console.log("Spectroscope destroyed.");
        }, 100)
        
    }.bind(this);
};

;
;
;
;


                    function acknowledgeWarning() {
                        document.getElementById('volumeWarning').style.display = 'none';
                        runCode();
                    }

                    // Initialize ASCII
                    window.enableAsciiInput = asciiCallbackInstance.enable.bind(asciiCallbackInstance);
                    window.disableAsciiInput = asciiCallbackInstance.disable.bind(asciiCallbackInstance);
                    window.setAsciiHandler = asciiCallbackInstance.setHandler.bind(asciiCallbackInstance);

                    // Initialize MIDI
                    window.midiHandlerInstance = midiHandlerInstance;
                    window.setNoteOnHandler = midiHandlerInstance.setNoteOnHandler.bind(midiHandlerInstance);
                    window.setNoteOffHandler = midiHandlerInstance.setNoteOffHandler.bind(midiHandlerInstance);
                    window.setCCHandler = midiHandlerInstance.setCCHandler.bind(midiHandlerInstance);
                    window.sendCC = midiHandlerInstance.sendCC.bind(midiHandlerInstance);
                    window.sendNote = midiHandlerInstance.sendNoteOn.bind(midiHandlerInstance);
                    window.sendNoteOff = midiHandlerInstance.sendNoteOff.bind(midiHandlerInstance);

                    // Function to run user code
                    async function runCode() {
                        try {
                            // Start audio context
                            await Tone.start();
                            window.audioContext = Tone.context.rawContext;
                            
                            // Clear previous state
                            Tone.Transport.stop();
                            Tone.Transport.cancel();
                            
                            // Clear all previous canvases
                            Canvas.innerHTML = "";
                            
                            // Run user code
                            eval(document.getElementById('userCode').textContent);

                            updateBPM(Theory.tempo);
                        } catch (error) {
                            console.error('Error running code:', error);
                            alert('Error running code: ' + error.message);
                        }
                    }

                    // Function to stop all sound (just reloads the page, there is too much to fix otherwise)
                    function stopCode() {
                        location.reload();
                    }

                    function updateBPM(value) {
                        Theory.tempo = parseInt(value);
                        document.getElementById('bpmValue').textContent = value;
                        document.getElementById('bpmSlider').value = value;
                        document.getElementById('bpmInput').value = value;
                    }
                </script>

                <!-- User Code -->
                <script id="userCode" type="text/javascript">
                    // Musical settings
Theory.tempo = 180
enableAsciiInput();

// Audio objects and connections
const gui = new p5(sketch, Canvas)
const d = new DrumSampler()
const output = new Tone.Multiply(.1).toDestination()
const verb = new Diffuseur()
d.connect(output)
d.connect(verb), verb.connect(output)

// Load drum kit and start
d.loadKit('Acoustic')
d.sequence('*', '4n', 0)
d.gui = gui
d.start()

// Key mapping configuration
const triggerKeys = {
  "q": { drum: 'O', label: "kick: q" },
  "a": { drum: 'X', label: "snare: a" },
  "z": { drum: '^', label: "open hat: z" },
  "w": { drum: '1', label: "tom 1: w" },
  "s": { drum: '2', label: "tom 2: s" },
  "x": { drum: '3', label: "tom 3: x" }
};

const sequencingKeys = {
  "m": { drum: '*', duration: '32n', label: "closed hat (32n): m" },
  ",": { drum: '*', duration: '16n', label: "closed hat (16n): ," },
  ".": { drum: '*', duration: '8n', label: "closed hat (8n): ." },
  "k": { drum: '1', duration: '32n', label: "tom 1 (32n): k" },
  "l": { drum: '1', duration: '16n', label: "tom 1 (16n): l" },
  ";": { drum: '1', duration: '8n', label: "tom 1 (8n): ;" },
  "o": { drum: '^', duration: '32n', label: "open hat (32n): o" },
  "p": { drum: '^', duration: '16n', label: "open hat (16n): p" },
  "[": { drum: '^', duration: '8n', label: "open hat (8n): [" }
};

// Assign sequence numbers to each key
let sequenceCounter = 1;
Object.keys(sequencingKeys).forEach(key => {
  sequencingKeys[key].sequence = sequenceCounter++;
});
// Give trigger the last sequence
const triggerSequencer = sequenceCounter;


let config;
// Key handlers
const handleOn = (key) => {
  if (triggerKeys[key]) {
    d.triggerDrum(triggerKeys[key].drum, triggerSequencer, Tone.immediate());
    keyMappingElements[key].textColor = [255, 0, 0];
  } else if (sequencingKeys[key]) {
    config = sequencingKeys[key];
    d.sequence(config.drum, config.duration, config.sequence);
    keyMappingElements[key].textColor = [255, 0, 0];
  }
}

const handleOff = (key) => {
  if (sequencingKeys[key]) {
    d.sequence('.', '8n', sequencingKeys[key].sequence);
  }
  if (keyMappingElements[key]) {
    keyMappingElements[key].textColor = [0, 0, 0];
  }
}

// GUI elements
const toggleDrumSampler = (state) => {
  if (state) {
    d.sequence('*', '4n', 0)
  } else {
    d.sequence('.', '4n', 0)
  }
}

const hatToggle = d.gui.Toggle({
  label: "BG closed\nhat"
});
hatToggle.x = 20;
hatToggle.y = 10;
hatToggle.size = 0.8;
hatToggle.textSize = 1;
hatToggle.rawValue = 1;
hatToggle.callback = toggleDrumSampler;

// Section headers
const presets = d.gui.Text({
  label: "Presets:",
});
presets.x = 77;
presets.y = 11.5;
presets.textSize = 1.75;
presets.border = 0;

const keyboardMap = d.gui.Text({
  label: "Keyboard Mappings",
});
keyboardMap.x = 87;
keyboardMap.y = 19;
keyboardMap.textSize = 1.75;
keyboardMap.border = 0;

const triggerMap = d.gui.Text({
  label: "Triggers (tap):",
});
triggerMap.x = 81.3;
triggerMap.y = 24;
triggerMap.textSize = 1.75;
triggerMap.border = 0;

const sequencingMap = d.gui.Text({
  label: "Sequencing (hold):",
});
sequencingMap.x = 92.3;
sequencingMap.y = 24;
sequencingMap.textSize = 1.75;
sequencingMap.border = 0;

// Create individual text elements for each key mapping
const keyMappingElements = {};

// Helper function to create text elements
const createKeyElement = (key, config, x, y, index) => {
  const element = d.gui.Text({
    label: config.label
  });
  element.x = x;
  element.y = y + (index * 3);
  element.textSize = 1.5;
  element.border = 0;
  
  // Store reference to the element
  keyMappingElements[key] = element;
  
  return element;
};

// Create text elements for trigger keys
let triggerIndex = 0;
Object.entries(triggerKeys).forEach(([key, config]) => {
  createKeyElement(key, config, 81.3, 30, triggerIndex++);
});

// Create text elements for sequencing keys
let sequencingIndex = 0;
Object.entries(sequencingKeys).forEach(([key, config]) => {
  createKeyElement(key, config, 92.3, 30, sequencingIndex++);
});

// Set up key press handler
setAsciiHandler((key, state) => { 
  switch (state) {
    case "down": handleOn(key); break;
    case "up": handleOff(key); break;
  }    
});

d.initGui(gui)
// Set opacity of preset-dropdown
d.gui_elements[d.gui_elements.length - 1].style = 2
console.log(d.gui_elements[d.gui_elements.length - 1])
                </script>
            </body>
            </html>
        